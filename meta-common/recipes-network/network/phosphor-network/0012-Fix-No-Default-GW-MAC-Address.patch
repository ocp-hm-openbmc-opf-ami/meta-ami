diff --git a/src/ethernet_interface.cpp b/src/ethernet_interface.cpp
index eb31b46..a504dac 100644
--- a/src/ethernet_interface.cpp
+++ b/src/ethernet_interface.cpp
@@ -23,6 +23,10 @@
 #include <variant>
 #include <xyz/openbmc_project/Common/error.hpp>
 
+#include <sys/ioctl.h>        /* macro ioctl is defined */
+#include <linux/if_packet.h>  /* struct sockaddr_ll (see man 7 packet) */
+#include <netinet/ether.h>
+
 namespace phosphor
 {
 namespace network
@@ -239,7 +243,7 @@ ObjectPath EthernetInterface::ip(IP::Protocol protType, std::string ipaddress,
                 gateway = ToAddr<in_addr>{}(ipgateway);
                 ip_address::isValidIPv4Addr((in_addr*)&addr, ip_address::Type::IP4_ADDRESS);
                 ip_address::isValidIPv4Addr((in_addr*)&gateway, ip_address::Type::GATEWAY4_ADDRESS);
-                EthernetInterfaceIntf::defaultGateway(ipgateway);
+                defaultGateway(ipgateway);
                 break;
             case IP::Protocol::IPv6:
                 addr = ToAddr<in6_addr>{}(ipaddress);
@@ -249,7 +253,7 @@ ObjectPath EthernetInterface::ip(IP::Protocol protType, std::string ipaddress,
                         gateway = ToAddr<in6_addr>{}(ipgateway);
                         ip_address::isValidIPv6Addr((in6_addr*)&gateway, ip_address::Type::GATEWAY6_ADDRESS);
                 }
-                EthernetInterfaceIntf::defaultGateway6(ipgateway);
+                defaultGateway6(ipgateway);
                 break;
             default:
                 throw std::logic_error("Exhausted protocols");
@@ -371,8 +375,19 @@ bool EthernetInterface::ipv6AcceptRA(bool value)
 
 bool EthernetInterface::dhcp4(bool value)
 {
-    if (dhcp4() != EthernetInterfaceIntf::dhcp4(value))
-    {
+    if (dhcp4() != value) {
+        if (value) {
+            if (!EthernetInterfaceIntf::defaultGateway().empty()) {
+                manager.removeNeighbor(
+                    NeighborInfo{
+                        .ifidx=ifIdx,
+                        .addr=ToAddr<in_addr>{}(EthernetInterfaceIntf::defaultGateway())
+                    }
+                );
+            } //
+        }
+
+        EthernetInterfaceIntf::dhcp4(value);
         writeConfigurationFile();
         manager.reloadConfigs();
     }
@@ -892,8 +907,14 @@ std::string EthernetInterface::defaultGateway(std::string gateway)
     {
         return gateway;
     }
+    manager.removeNeighbor(
+        NeighborInfo{
+            .ifidx=ifIdx,
+             .addr=ToAddr<in_addr>{}(EthernetInterfaceIntf::defaultGateway())
+       }
+    );
     EthernetInterfaceIntf::defaultGateway(gateway);
-
+    setDwMacAddrByIP(gateway);
     writeConfigurationFile();
     manager.reloadConfigs();
 
@@ -1243,5 +1264,174 @@ bool EthernetInterface::sysctlConfig(const std::string& cmd)
     return ((outConfig.empty())?1:0);
 }
 
+int EthernetInterface::setDwMacAddrByIP(std::string gateway) {
+    int ret = 0;
+    std::ifstream ifs("/proc/net/arp");
+    if (!ifs) {
+        log<level::INFO>("/proc/net/arp not opened\n");
+        return std::string::npos;
+    }
+    std::string line, mac;
+    std::vector<std::string> vv;
+    while (!ifs.eof()) {
+        ifs >> line ;
+        if (line == gateway) {
+            ifs >> line >> line >> mac >> line >> line;
+            if (line == interfaceName() && ether_aton(mac.c_str()) != nullptr) {
+                neighbor(gateway, mac);
+                return 0;
+            }
+        }
+    }
+
+    int s = -1;
+
+    struct ifreq ifr;
+    struct sockaddr_ll srcsock,dstsock,recvsock;
+    int retry = 2;
+    uint8_t buf[256] = {0};
+    uint8_t packet[4096] = {0};
+    uint8_t preMAC[6] = {0};
+    struct arphdr *arph = NULL;
+    socklen_t alen;
+    fd_set rfds;
+    struct timeval tv;
+    int retval=0;
+    int nfds = 0;
+    uint8_t *p = NULL;;
+
+
+    s = socket(PF_PACKET, SOCK_DGRAM, 0);
+    if (s < 0) {
+        ret = std::string::npos;
+        goto end;
+    }
+
+    memset(&ifr, 0, sizeof(ifr));
+    ret = snprintf(ifr.ifr_name,sizeof(ifr.ifr_name),"%s",interfaceName().c_str());
+    if(ret < 0 || ret >= (signed int)sizeof(ifr.ifr_name)) {
+        log<level::ERR>("Buffer Overflow\n");
+        ret = std::string::npos;
+        goto close;
+    }
+
+    if (ioctl(s, SIOCGIFINDEX, &ifr) < 0) {
+        log<level::ERR>(fmt::format("Interface {} not found\n", interfaceName()).c_str());
+        ret = std::string::npos;
+        goto close;
+    }
+
+    srcsock.sll_family = AF_PACKET;
+    srcsock.sll_ifindex = if_nametoindex(interfaceName().c_str());
+    srcsock.sll_protocol = htons(ETH_P_ARP);
+    if (bind(s, (struct sockaddr *)&srcsock, sizeof(srcsock)) == -1) {
+        log<level::ERR>(fmt::format("Failure in Binding Interface {}'s index = {}\n", interfaceName(), srcsock.sll_ifindex).c_str());
+        ret = std::string::npos;
+        goto close;
+    }
+
+    alen = sizeof(srcsock);
+    if (getsockname(s, (struct sockaddr *)& srcsock, &alen)) {
+        log<level::ERR>("Failure in getsockname\n");
+        ret = std::string::npos;
+        goto close;
+    }
+
+    if (srcsock.sll_halen == 0) {
+        log<level::ERR>(fmt::format("Interface {} is not able to communicate\n", interfaceName()).c_str());
+        ret = std::string::npos;
+        goto close;
+    }
+
+    for (auto& addr : addrs) {
+        if (addr.second->type() == IP::Protocol::IPv4 && addr.second->origin() != IP::AddressOrigin::LinkLocal) {
+            retry = 2;
+            while(retry) {
+                dstsock = srcsock;
+                memset(dstsock.sll_addr, -1, dstsock.sll_halen);
+                in_addr addrTmp = ToAddr<in_addr>{}(addr.second->address());
+                uint8_t *ip = (uint8_t *)&addrTmp.s_addr;
+                ip = (uint8_t *)(&addrTmp.s_addr);
+                memset(buf, 0, sizeof(buf));
+                memset(packet, 0, sizeof(packet));
+
+                arph = (struct arphdr *)buf;
+                p = (uint8_t *)(arph+1);
+
+                arph->ar_hrd = htons(ARPHRD_ETHER);
+                arph->ar_pro = htons(ETH_P_IP);
+                arph->ar_hln = srcsock.sll_halen;
+                arph->ar_pln = 4;
+                arph->ar_op = htons(ARPOP_REQUEST);
+                memcpy(p, &srcsock.sll_addr, arph->ar_hln);
+                p += arph->ar_hln;
+
+                memcpy(p, &ip[0], arph->ar_pln);
+                p += arph->ar_pln;
+
+                memcpy(p, &dstsock.sll_addr, arph->ar_hln);
+                p += arph->ar_hln;
+
+                addrTmp = ToAddr<in_addr>{}(gateway);
+                ip = (uint8_t *)(&addrTmp.s_addr);
+                memcpy(p, &ip[0], arph->ar_pln);
+                p += arph->ar_pln;
+
+                if( 0 == sendto(s, buf, p - buf, 0, (struct sockaddr *)&dstsock, sizeof(dstsock)))
+                {
+                    continue;
+                }
+
+                arph = (struct arphdr *) packet;
+                p = (unsigned char *) (arph + 1);
+
+                FD_ZERO(&rfds);
+                FD_SET(s, &rfds);
+                tv.tv_sec = 2;
+                tv.tv_usec = 0;
+                nfds = s + 1;
+                retval = select(nfds, &rfds, NULL, NULL, &tv);
+                if (retval == -1)
+                    log<level::ERR>("select() error\n");
+                else if (retval)
+                {
+                    if(FD_ISSET (s, &rfds))
+                    {
+                        if (recvfrom(s, packet, sizeof(packet), 0,(struct sockaddr *) &recvsock, &alen) < 0)
+                        {
+                            log<level::ERR>("Failed in Recvfrom\n");
+                        }
+                        //If IpAddr and the ip from response are not the same, then set MAC address all zero
+                        if( ip[0] != p[6] || ip[1] != p[7]|| ip[2] != p[8] || ip[3] != p[9] )
+                        {
+                            memset(p, 0, 6);
+                        }
+                    }
+                }
+                else
+                {
+                    goto close;
+                }
+                if(retry == 2)
+                {
+                    memcpy(preMAC, p, 6);
+                }
+                retry--;
+            }
+
+            if(0 == memcmp(p,preMAC,6)) {
+                neighbor(gateway, fmt::format("{:0>2x}:{:0>2x}:{:0>2x}:{:0>2x}:{:0>2x}:{:0>2x}", p[0],p[1],p[2],p[3],p[4],p[5]));
+                ret = 0;
+                goto close;
+            } // if
+        }
+    }
+
+close:
+    close(s);
+end:
+    return ret;
+}
+
 } // namespace network
 } // namespace phosphor
diff --git a/src/ethernet_interface.hpp b/src/ethernet_interface.hpp
index 0c1078c..50eb1eb 100644
--- a/src/ethernet_interface.hpp
+++ b/src/ethernet_interface.hpp
@@ -242,6 +242,10 @@ class EthernetInterface : public Ifaces
      */
     uint64_t gratuitousARPInterval(uint64_t interval) override;
 
+    /** @brief set the Default Gateway MAC Addess.
+     *  @param[in] gateway - Gateway4 address.
+     */
+    int setDwMacAddrByIP(std::string gateway);
 
     using ChannelAccessIntf::maxPrivilege;
     using EthernetInterfaceIntf::interfaceName;
diff --git a/src/network_manager.cpp b/src/network_manager.cpp
index 2932f33..23eed07 100644
--- a/src/network_manager.cpp
+++ b/src/network_manager.cpp
@@ -489,6 +489,7 @@ void Manager::addDefGw(unsigned ifidx, InAddrAny addr)
                     {
                         it->second->EthernetInterfaceIntf::defaultGateway(
                             std::to_string(addr));
+                        it->second->setDwMacAddrByIP(std::to_string(addr));
                     }
                     else if constexpr (std::is_same_v<in6_addr, decltype(addr)>)
                     {
@@ -545,6 +546,14 @@ void Manager::removeDefGw(unsigned ifidx, InAddrAny addr)
                         if (it->second->defaultGateway() ==
                             std::to_string(addr))
                         {
+                            if (!it->second->EthernetInterfaceIntf::defaultGateway().empty()) {
+                                removeNeighbor(
+                                    NeighborInfo{
+                                        .ifidx=if_nametoindex(it->second->interfaceName().c_str()),
+                                        .addr=ToAddr<in_addr>{}(it->second->EthernetInterfaceIntf::defaultGateway())
+                                    }
+                                );
+                            }
                             it->second->EthernetInterfaceIntf::defaultGateway(
                                 "");
                         }
