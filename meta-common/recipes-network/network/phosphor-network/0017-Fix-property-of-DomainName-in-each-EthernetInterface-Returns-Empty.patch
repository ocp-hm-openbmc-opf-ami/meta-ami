From b2016cb1e81ba93124ad284dc0ae582fc48566c7 Mon Sep 17 00:00:00 2001
From: Ethan Wei <ethanwei@ami.com>
Date: Tue, 4 Jul 2023 11:24:52 +0800
Subject: [PATCH] Fix property of DomainName in each EthernetInterface returns
 empty 	modified:   src/dhcp_configuration.cpp 	modified:  
 src/dns_updater.cpp 	modified:   src/ethernet_interface.cpp 	modified:  
 src/ethernet_interface.hpp 	modified:   src/network_manager.cpp

---
 src/dhcp_configuration.cpp |   1 +
 src/dns_updater.cpp        |  26 ++++---
 src/ethernet_interface.cpp | 143 ++++++++++++++++++++++++++++++-------
 src/ethernet_interface.hpp |  13 +++-
 src/network_manager.cpp    |   2 +-
 5 files changed, 150 insertions(+), 35 deletions(-)

diff --git a/src/dhcp_configuration.cpp b/src/dhcp_configuration.cpp
index e70bb86..4f64e18 100644
--- a/src/dhcp_configuration.cpp
+++ b/src/dhcp_configuration.cpp
@@ -55,6 +55,7 @@ Configuration::Configuration(sdbusplus::bus_t& bus,
 
     ConfigIntf::dnsEnabled(getDHCPProp(conf, "UseDNS"), true);
     ConfigIntf::ntpEnabled(getDHCPProp(conf, "UseNTP"), true);
+    ConfigIntf::domainEnabled(getDHCPProp(conf, "UseDomains"), ConfigIntf::dnsEnabled());
     ConfigIntf::hostNameEnabled(getDHCPProp(conf, "UseHostname"), true);
     ConfigIntf::sendHostNameEnabled(getDHCPProp(conf, "SendHostname"), true);
 
diff --git a/src/dns_updater.cpp b/src/dns_updater.cpp
index 00ce926..a2e6c88 100644
--- a/src/dns_updater.cpp
+++ b/src/dns_updater.cpp
@@ -157,20 +157,16 @@ void Configuration::registerSignal(sdbusplus::bus_t& bus) {
                     msg.read(iface, props);
                     for (const auto& t : props)
                     {
-                        if (t.first == "DomainEnabled")
+                        if (t.first == "DNSEnabled")
                         {
                             value = std::get<bool>(t.second);
+                            dnsEnabled(value);
                             if (value == true && dnsEnabled())
                                 domainConf(std::make_tuple(true,1, ""));
                             else {
                                 domainConf(std::make_tuple(false,0, std::get<2>(ddnsIface::domainConf())));
                             }
                         }
-                        else if (t.first == "DNSEnabled")
-                        {
-                            value = std::get<bool>(t.second);
-                            dnsEnabled(value);
-                        }
                         else if (t.first == "SendNsupdateEnabled")
                         {
                             value = std::get<bool>(t.second);
@@ -484,7 +480,10 @@ int16_t Configuration::setDomainConf(bool dhcp, uint8_t priority,std::string dom
 
     for (auto i = manager.interfaces.begin(); i != manager.interfaces.end(); i++) {
         if (i->second->linkUp()) {
-            i->second->domainName({});
+            if (!dhcp)
+                i->second->domainName(tmpVec);
+            else
+                i->second->domainName({});
         }
     }
 
@@ -611,7 +610,16 @@ std::string Configuration::getDomainName(std::string interface) {
         }
     }
     else {
-        return name;
+        auto iface = manager.interfaces.find(interface);
+        if (iface != manager.interfaces.end() ) {
+            if (iface->second->domainName().size() > 0) {
+                return iface->second->domainName().at(0);
+            }
+            return name;
+        }
+        else {
+            return name;
+        }
     }
 }
 
@@ -650,7 +658,7 @@ std::vector<std::string> Configuration::getDNSServer(std::string interface) {
         servers.push_back(std::to_string(addrFromBuf(addrFamily, stdplus::raw::asView<char>(ipaddress))));
     }
 
-    return std::move(servers);
+    return servers;
 }
 
 
diff --git a/src/ethernet_interface.cpp b/src/ethernet_interface.cpp
index 912ddaa..6db9728 100644
--- a/src/ethernet_interface.cpp
+++ b/src/ethernet_interface.cpp
@@ -40,7 +40,11 @@ using NotAllowedArgument = xyz::openbmc_project::Common::NotAllowed;
 using Argument = xyz::openbmc_project::Common::InvalidArgument;
 using std::literals::string_view_literals::operator""sv;
 constexpr auto RESOLVED_SERVICE = "org.freedesktop.resolve1";
+constexpr auto RESOLVD_OBJ_PATH = "/org/freedesktop/resolve1";
 constexpr auto RESOLVED_INTERFACE = "org.freedesktop.resolve1.Link";
+constexpr auto RESOLVD_MANAGER_INTERFACE = "org.freedesktop.resolve1.Manager";
+constexpr auto DHCP_PROP_INTERFACE = "xyz.openbmc_project.Network.DHCPConfiguration";
+constexpr auto DHCP_SERVICE_PATH = "/xyz/openbmc_project/network/dhcp";
 constexpr auto PROPERTY_INTERFACE = "org.freedesktop.DBus.Properties";
 constexpr auto RESOLVED_SERVICE_PATH = "/org/freedesktop/resolve1/link/";
 
@@ -147,6 +151,8 @@ EthernetInterface::EthernetInterface(sdbusplus::bus_t& bus, Manager& manager,
         addStaticNeigh(neigh);
     }
 
+    signals = initSignals();
+    registerSignal(bus);
     manager.getDNSConf().addInterfaceConf(interfaceName());
 }
 
@@ -572,10 +578,13 @@ void EthernetInterface::loadNameServers(const config::Parser& config)
         config.map.getValueStrings("Network", "DNS"));
 }
 
-void EthernetInterface::loadStaticDomainNames()
+void EthernetInterface::loadDomainNames()
 {
     auto [dhcp, priority, name] = manager.getDNSConf().domainConf();
-    if (!dhcp) {
+    if (manager.getDHCPConf().domainEnabled() && manager.getDHCPConf().dnsEnabled() && dhcp) {
+        EthernetInterfaceIntf::domainName(getDomainNamesFromResolvd());
+    }
+    else {
         EthernetInterfaceIntf::domainName(std::vector<std::string>{name});
     }
 }
@@ -656,6 +665,37 @@ ServerList EthernetInterface::getNameServerFromResolvd()
     return servers;
 }
 
+ServerList EthernetInterface::getDomainNamesFromResolvd()
+{
+    ServerList DomainNames;
+    auto OBJ_PATH = fmt::format("{}{}", RESOLVED_SERVICE_PATH, ifIdx);
+
+    using type = std::vector<std::tuple<std::string, bool>>;
+    std::variant<type> name; // Variable to capture the DNS property
+    auto method = bus.new_method_call(RESOLVED_SERVICE, OBJ_PATH.c_str(),
+                                      PROPERTY_INTERFACE, METHOD_GET);
+
+    method.append(RESOLVED_INTERFACE, "Domains");
+
+    try
+    {
+        auto reply = bus.call(method);
+        reply.read(name);
+    }
+    catch (const sdbusplus::exception_t& e)
+    {
+        log<level::ERR>("Failed to get DNS information from Systemd-Resolved");
+    }
+    auto tupleVector = std::get_if<type>(&name);
+    for (auto i = tupleVector->begin(); i != tupleVector->end(); ++i)
+    {
+        auto [domainName, fromRoute] = (*i);
+        DomainNames.push_back(domainName);
+    }
+
+    return DomainNames;
+}
+
 ObjectPath EthernetInterface::createVLAN(uint16_t id)
 {
     auto intfName = fmt::format(FMT_COMPILE("{}.{}"), interfaceName(), id);
@@ -755,9 +795,9 @@ void EthernetInterface::writeConfigurationFile()
     }
     {
         auto& network = config.map["Network"].emplace_back();
-        auto& lla = network["LinkLocalAddressing"];
-#ifdef LINK_LOCAL_AUTOCONFIGURATION
         {
+            auto& lla = network["LinkLocalAddressing"];
+#ifdef LINK_LOCAL_AUTOCONFIGURATION
             switch (EthernetInterfaceIntf::linkLocalAutoConf()) {
                 case EthernetInterface::LinkLocalConf::v4:
                     lla.emplace_back("ipv4");
@@ -766,33 +806,39 @@ void EthernetInterface::writeConfigurationFile()
                     lla.emplace_back("no");
                     break;
                 case EthernetInterface::LinkLocalConf::v6:
-                    lla.emplace_back("ipv6");
-                    break;
                 case EthernetInterface::LinkLocalConf::both:
                 default:
-                    lla.emplace_back("yes");
+                    if (std::string{LINK_LOCAL_AUTOCONFIGURATION} == "ipv6")
+                        lla.emplace_back("ipv6");
+                    else
+                        lla.emplace_back("yes");
                     break;
             }
-        }
 #else
-        lla.emplace_back("no");
+            lla.emplace_back("no");
 #endif
-        config::Parser IfaceState;
-        auto& state = IfaceState.map["Network"].emplace_back();
-        state["IPv4Enable"].emplace_back(EthernetInterfaceIntf::ipv4Enable() ? "true" : "false");
-        state["IPv6Enable"].emplace_back(EthernetInterfaceIntf::ipv6Enable() ? "true" : "false");
-        IfaceState.writeFile(fs::path{fmt::format("{}/{}", manager.ifaceConfDir.generic_string(), interfaceName()).c_str()});
-
-        network["IPv6AcceptRA"].emplace_back(EthernetInterfaceIntf::ipv6Enable() && ipv6AcceptRA() ? "true" : "false");
-        network["DHCP"].emplace_back(dhcp4() ? (dhcp6() ? "true" : "ipv4")
-                                             : (dhcp6() ? "ipv6" : "false"));
-
-        std::string s("");
-        for (int i = 0; i < (int)domainName().size(); i++) {
-            s += domainName().at(i);
         }
-        network["Domains"].emplace_back(s);
-
+        {
+            config::Parser IfaceState;
+            auto& state = IfaceState.map["Network"].emplace_back();
+            state["IPv4Enable"].emplace_back(EthernetInterfaceIntf::ipv4Enable() ? "true" : "false");
+            state["IPv6Enable"].emplace_back(EthernetInterfaceIntf::ipv6Enable() ? "true" : "false");
+            IfaceState.writeFile(fs::path{fmt::format("{}/{}", manager.ifaceConfDir.generic_string(), interfaceName()).c_str()});
+
+            network["IPv6AcceptRA"].emplace_back(EthernetInterfaceIntf::ipv6Enable() && ipv6AcceptRA() ? "true" : "false");
+            network["DHCP"].emplace_back(dhcp4() ? (dhcp6() ? "true" : "ipv4")
+                                                : (dhcp6() ? "ipv6" : "false"));
+        }
+        {
+            std::string s("");
+            auto [dominaDHCP, domainPriority, DomainDN] = manager.getDNSConf().domainConf();
+            if (!(manager.getDHCPConf().dnsEnabled() && manager.getDHCPConf().domainEnabled() && dominaDHCP)) {
+                for (int i = 0; i < (int)domainName().size(); i++) {
+                    s += domainName().at(i) + " ";
+                }
+                network["Domains"].emplace_back(s);
+            }
+        }
         {
             auto& vlans = network["VLAN"];
             for (const auto& [_, intf] : manager.interfaces)
@@ -1610,7 +1656,56 @@ end:
     return ret;
 }
 
+std::map<std::string, std::unique_ptr<sdbusplus::bus::match_t>> EthernetInterface::initSignals() {
+    std::map<std::string, std::unique_ptr<sdbusplus::bus::match_t>> mp;
+    mp["DHCPSignal"] = nullptr;
+    mp["ResolvdSignal"] = nullptr;
+    return mp;
+}
 
+void EthernetInterface::registerSignal(sdbusplus::bus::bus& bus) {
+    for (auto& signal : signals) {
+        if (signal.second == nullptr && signal.first == "DHCPSignal") {
+            signal.second = std::make_unique<sdbusplus::bus::match_t>(
+                bus,
+                sdbusplus::bus::match::rules::propertiesChanged(DHCP_SERVICE_PATH, DHCP_PROP_INTERFACE),
+                [&](sdbusplus::message::message& msg) {
+                    std::map<std::string, std::variant<bool>> props;
+                    std::string iface;
+                    bool value;
+                    msg.read(iface, props);
+                    for (const auto& t : props)
+                    {
+                        if (t.first == "DNSEnabled")
+                        {
+                            value = std::get<bool>(t.second);
+                            if (value) {
+                                EthernetInterfaceIntf::domainName({});
+                            }
+                        }
+                    }
+                }
+            );
+        }
+        else if (signal.second == nullptr && signal.first == "ResolvdSignal") {
+            signal.second = std::make_unique<sdbusplus::bus::match_t>(
+                bus,
+                sdbusplus::bus::match::rules::propertiesChanged(RESOLVD_OBJ_PATH, RESOLVD_MANAGER_INTERFACE),
+                [&](sdbusplus::message::message& msg) {
+                    std::map<std::string, std::variant<std::vector<std::tuple<int, std::string, bool>>,std::vector<std::tuple<int, int, std::vector<uint8_t>>>>> props;
+                    std::string iface;
+                    std::vector<std::tuple<std::string, bool>> value;
+                    msg.read(iface, props);
+                    for (const auto& t : props)
+                    {
+                        auto vector = getDomainNamesFromResolvd();
+                        EthernetInterfaceIntf::domainName(getDomainNamesFromResolvd());
+                    }
+                }
+            );
+        }
+    }
+}
 
 } // namespace network
 } // namespace phosphor
diff --git a/src/ethernet_interface.hpp b/src/ethernet_interface.hpp
index 506a5cf..88e2e33 100644
--- a/src/ethernet_interface.hpp
+++ b/src/ethernet_interface.hpp
@@ -126,7 +126,7 @@ class EthernetInterface : public Ifaces
 
     /** @brief Function used to load the domainNames.
      */
-    void loadStaticDomainNames();
+    void loadDomainNames();
 
     /** @brief Function to create ipAddress dbus object.
      *  @param[in] addressType - Type of ip address.
@@ -299,6 +299,15 @@ class EthernetInterface : public Ifaces
      */
     virtual ServerList getNameServerFromResolvd();
 
+    /** @brief get the domain names details from the network conf
+     *
+     */
+    virtual ServerList getDomainNamesFromResolvd();
+
+    std::map<std::string, std::unique_ptr<sdbusplus::bus::match_t>> initSignals();
+
+    void registerSignal(sdbusplus::bus::bus& bus);
+
     /** @brief Persistent sdbusplus DBus bus connection. */
     sdbusplus::bus_t& bus;
 
@@ -318,6 +327,8 @@ class EthernetInterface : public Ifaces
     };
     std::optional<VlanProperties> vlan;
 
+    std::map<std::string, std::unique_ptr<sdbusplus::bus::match_t>> signals ;
+
     friend class TestEthernetInterface;
     friend class TestNetworkManager;
 
diff --git a/src/network_manager.cpp b/src/network_manager.cpp
index fff9e71..3cd1bfb 100644
--- a/src/network_manager.cpp
+++ b/src/network_manager.cpp
@@ -304,7 +304,7 @@ void Manager::createInterface(const AllIntfInfo& info, bool enabled)
         bus, *this, info, objPath.str, config, enabled);
     intf->loadNameServers(config);
     intf->loadNTPServers(config);
-    intf->loadStaticDomainNames();
+    intf->loadDomainNames();
     auto ptr = intf.get();
     interfaces.insert_or_assign(*info.intf.name, std::move(intf));
     interfacesByIdx.insert_or_assign(info.intf.idx, ptr);
-- 
2.25.1

