From 8ca913c9d61432d3542f5858bf1dd1f5289fed61 Mon Sep 17 00:00:00 2001
From: Ethan Wei <ethanwei@ami.com>
Date: Tue, 3 Oct 2023 03:55:30 -0700
Subject: [PATCH] Add Index of IPAddress and its Related Function. 1. Create
 another DBus Function to Create IP and Index only for IPMI 2. Set the Proper
 Index for IP Address when Set IP via WebUI, Redfish or Directly in Console 3.
 Write the Index Info into File and Delete Index when IPAddress Gets Removed 
 modified:   src/config_parser.cpp 	modified:   src/config_parser.hpp 
 modified:   src/ethernet_interface.cpp 	modified:  
 src/ethernet_interface.hpp 	modified:   src/ipaddress.cpp 	modified:  
 src/ipaddress.hpp 	modified:   src/network_manager.cpp 	modified:  
 src/types.hpp 	modified:   src/util.cpp 	modified:   src/util.hpp 
 modified:   yaml/xyz/openbmc_project/Network/IP/Create.interface.yaml

---
 src/config_parser.cpp                         |   5 +
 src/config_parser.hpp                         |   1 +
 src/ethernet_interface.cpp                    | 331 ++++++++++++++++--
 src/ethernet_interface.hpp                    |  46 +++
 src/ipaddress.cpp                             |  12 +-
 src/ipaddress.hpp                             |   6 +-
 src/network_manager.cpp                       |   7 +
 src/types.hpp                                 |   3 +-
 src/util.cpp                                  |  21 ++
 src/util.hpp                                  |  10 +
 .../Network/IP/Create.interface.yaml          |  34 ++
 11 files changed, 449 insertions(+), 27 deletions(-)

diff --git a/src/config_parser.cpp b/src/config_parser.cpp
index 7fa0742..57fa59e 100644
--- a/src/config_parser.cpp
+++ b/src/config_parser.cpp
@@ -66,6 +66,11 @@ fs::path pathForIntfDev(const fs::path& dir, std::string_view intf)
     return dir / fmt::format(FMT_COMPILE("{}.netdev"), intf);
 }
 
+fs::path pathForIntfInfo(const fs::path& dir, std::string_view intf)
+{
+    return dir / intf;
+}
+
 const std::string*
     SectionMap::getLastValueString(std::string_view section,
                                    std::string_view key) const noexcept
diff --git a/src/config_parser.hpp b/src/config_parser.hpp
index 5ac378c..afa8c3f 100644
--- a/src/config_parser.hpp
+++ b/src/config_parser.hpp
@@ -40,6 +40,7 @@ enum class ReturnCode
 
 fs::path pathForIntfConf(const fs::path& dir, std::string_view intf);
 fs::path pathForIntfDev(const fs::path& dir, std::string_view intf);
+fs::path pathForIntfInfo(const fs::path& dir, std::string_view intf);
 
 template <typename T, typename Check>
 class Checked
diff --git a/src/ethernet_interface.cpp b/src/ethernet_interface.cpp
index a096f6f..8a9204e 100644
--- a/src/ethernet_interface.cpp
+++ b/src/ethernet_interface.cpp
@@ -139,6 +139,18 @@ EthernetInterface::EthernetInterface(stdplus::PinnedRef<sdbusplus::bus_t> bus,
         EthernetInterfaceIntf::ipv6StaticRtrAddr(getIP6StaticRtrAddr(ifaceConfig), true);
     }
 
+    auto [ipv4List, ipv6List] = getIndexList(ifaceConfig);
+    if (!EthernetInterfaceIntf::dhcp4()) {
+        ipv4IndexUsedList = std::move(ipv4List);
+    }
+
+    if (!EthernetInterfaceIntf::dhcp6()) {
+        ipv6IndexUsedList = std::move(ipv6List);
+    }
+
+    ipv4IndexUsedList.resize(IPV4_MAX_NUM+1, std::nullopt);
+    ipv6IndexUsedList.resize(IPV6_MAX_NUM+1, std::nullopt);
+
     this->loadARPControl();
     emit_object_added();
 
@@ -218,9 +230,19 @@ void EthernetInterface::addAddr(const AddressInfo& info)
     auto it = addrs.find(info.ifaddr);
     if (it == addrs.end())
     {
+        int idx = 0;
+        if (origin == IP::AddressOrigin::Static) {
+            auto tmpAddr = std::to_string(info.ifaddr.getAddr());
+            if (tmpAddr.find(":") != std::string::npos) {
+                idx = getProperIpIdx<IP::Protocol::IPv6>(ipv6IndexUsedList, info.ifaddr.getAddr());
+            } // if
+            else if (tmpAddr.find(".") != std::string::npos) {
+                idx = getProperIpIdx<IP::Protocol::IPv4>(ipv4IndexUsedList, info.ifaddr.getAddr());
+            }
+        }
         addrs.emplace(info.ifaddr, std::make_unique<IPAddress>(
                                        bus, std::string_view(objPath), *this,
-                                       info.ifaddr, origin));
+                                       info.ifaddr, origin, idx));
     }
     else
     {
@@ -259,9 +281,70 @@ void EthernetInterface::addStaticNeigh(const NeighborInfo& info)
     }
 }
 
-ObjectPath EthernetInterface::ip(IP::Protocol protType, std::string ipaddress,
-                                 uint8_t prefixLength, std::string ipgateway)
-{
+void EthernetInterface::updateIpIndex(IfAddr addr, std::variant<bool, int> index) {
+    int idx = 0;
+
+    try {
+        if (std::get_if<bool>(&index)) {
+            std::string ipaddress = std::to_string(addr.getAddr());
+            if (ipaddress.find(":") != std::string::npos) {
+                idx = getProperIpIdx<IP::Protocol::IPv6>(ipv6IndexUsedList, addr.getAddr());
+            } // if
+            else if (ipaddress.find(".") != std::string::npos) {
+                idx = getProperIpIdx<IP::Protocol::IPv4>(ipv4IndexUsedList, addr.getAddr());
+            }
+        } // if
+        else {
+            idx = *std::get_if<int>(&index);
+        } // else
+
+        std::string ipaddress = std::to_string(addr.getAddr());
+        if (ipaddress.find(":") != std::string::npos) {
+            for (const auto& v : ipv6IndexUsedList) {
+                if (v == ipaddress) {
+                    goto EXIT;
+                } // if
+            }
+
+            if (ipv6IndexUsedList.size() <= idx) {
+                ipv6IndexUsedList.resize(idx+1, std::nullopt);
+            }
+            ipv6IndexUsedList.at(idx) = std::move(ipaddress);
+        } // if
+        else if (ipaddress.find(".") != std::string::npos) {
+            for (const auto& v : ipv4IndexUsedList) {
+                if (v == ipaddress) {
+                    goto EXIT;
+                } // if
+            }
+
+            if (ipv4IndexUsedList.size() <= idx) {
+                ipv4IndexUsedList.resize(idx+1, std::nullopt);
+            }
+            ipv4IndexUsedList.at(idx) = std::move(ipaddress);
+        }
+    } catch (const std::exception& e) {
+        log<level::INFO>(fmt::format("Couldn't update index: {}\n", e.what()).c_str());
+    }
+
+    try {
+        auto it = addrs.find(addr);
+        if (it != addrs.end()) {
+            it->second->IP::idx(idx);
+        }
+        else {
+            throw std::logic_error("No matched IP address found");
+        }
+    } catch (const std::exception& e) {
+        log<level::INFO>(fmt::format("Couldn't update index: {}\n", e.what()).c_str());
+    }
+
+EXIT:
+    return;
+}
+
+std::tuple<bool, ObjectPath> EthernetInterface::createStaticIP(IP::Protocol protType, std::string ipaddress,
+                                              uint8_t prefixLength, std::string ipgateway) {
     InAddrAny addr, gateway;
     try
     {
@@ -332,21 +415,151 @@ ObjectPath EthernetInterface::ip(IP::Protocol protType, std::string ipaddress,
         it = std::get<0>(addrs.emplace(
             ifaddr,
             std::make_unique<IPAddress>(bus, std::string_view(objPath), *this,
-                                        ifaddr, IP::AddressOrigin::Static)));
+                                        ifaddr, IP::AddressOrigin::Static, 0)));
     }
     else
     {
         if (it->second->origin() == IP::AddressOrigin::Static)
         {
-            return it->second->getObjPath();
+            return std::make_tuple(false, it->second->getObjPath());
         }
         it->second->IPIfaces::origin(IP::AddressOrigin::Static);
     }
 
-    writeConfigurationFile();
-    manager.get().reloadConfigs();
+    return std::make_tuple(true, it->second->getObjPath());
 
-    return it->second->getObjPath();
+}
+
+ObjectPath EthernetInterface::ip(IP::Protocol protType, std::string ipaddress,
+                                 uint8_t prefixLength, std::string ipgateway)
+{
+    try {
+        int count = 0;
+        if (protType == IP::Protocol::IPv6) {
+            std::for_each(ipv6IndexUsedList.begin(), ipv6IndexUsedList.end(),
+                [&](const std::optional<std::string> v) {
+                    if (v.has_value()) {
+                        count += 1;
+                    }
+                });
+            if (count >= IPV6_MAX_NUM) {
+                auto msg = fmt::format("The number of IPv6 address id out of limit {}. ", IPV6_MAX_NUM);
+                throw std::logic_error(msg.c_str());
+            }
+        } // if
+        else if (protType == IP::Protocol::IPv4) {
+            std::for_each(ipv4IndexUsedList.begin(), ipv4IndexUsedList.end(),
+                [&](const std::optional<std::string> v) {
+                    if (v.has_value()) {
+                        count += 1;
+                    }
+                });
+            if (count >= IPV4_MAX_NUM) {
+                auto msg = fmt::format("The number of IPv4 address id out of limit {}. ", IPV4_MAX_NUM);
+                throw std::logic_error(msg.c_str());
+            } // if
+        } // else if
+    } catch (const std::exception& e) {
+        elog<InvalidArgument>(Argument::ARGUMENT_NAME("ipaddress"), Argument::ARGUMENT_VALUE(ipaddress.c_str()));
+    }
+
+    auto [reload, path] = createStaticIP(protType, ipaddress, prefixLength, ipgateway);
+    IfAddr ifaddr;
+    try {
+        if (IP::Protocol::IPv4 == protType) {
+            ifaddr = {ToAddr<in_addr>{}(ipaddress), prefixLength};
+        }
+        else if (IP::Protocol::IPv6 == protType) {
+            ifaddr = {ToAddr<in6_addr>{}(ipaddress), prefixLength};
+        } // else if
+    } catch(const std::exception& e) {
+    }
+    if (reload) {
+        updateIpIndex(ifaddr, false);
+        writeConfigurationFile();
+        manager.get().reloadConfigs();
+    } // if
+
+    return path;
+}
+
+ObjectPath EthernetInterface::ipWithIndex(IP::Protocol protType, std::string ipaddress,
+                                 uint8_t prefixLength, uint8_t idx,std::string ipgateway)
+{
+    int count = 0;
+    try {
+        if (protType == IP::Protocol::IPv6) {
+            std::for_each(ipv6IndexUsedList.begin(), ipv6IndexUsedList.end(),
+                [&](const std::optional<std::string> v) {
+                    if (v.has_value()) {
+                        count += 1;
+                    }
+                });
+            if (idx >= IPV6_MAX_NUM || count >= IPV6_MAX_NUM) {
+                auto errMsg = fmt::format("IPv6 Index {} is out of limit {}. ", idx, IPV6_MAX_NUM);
+                throw std::logic_error(errMsg);
+            } // if
+            else if (ipv6IndexUsedList.size() > idx && ipv6IndexUsedList.at(idx).has_value()) {
+                throw std::logic_error(fmt::format("IPv6 The Index #{} is already used\n", idx).c_str());
+            }
+        } // if
+        else if (protType == IP::Protocol::IPv4) {
+            std::for_each(ipv4IndexUsedList.begin(), ipv4IndexUsedList.end(),
+                [&](const std::optional<std::string> v) {
+                    if (v.has_value()) {
+                        count += 1;
+                    }
+                });
+            if (idx >= IPV4_MAX_NUM || count >= IPV4_MAX_NUM) {
+                auto errMsg = fmt::format("IPv4 Index {} is out of limit {}. ", idx, IPV4_MAX_NUM);
+                throw std::logic_error(errMsg);
+            } // if
+            else if (ipv4IndexUsedList.size() > idx && ipv4IndexUsedList.at(idx).has_value()) {
+                throw std::logic_error(fmt::format("IPv4 The Index #{} is already used.\n", idx).c_str());
+            }
+        } // else if
+    } catch (const std::exception& e) {
+        elog<InvalidArgument>(Argument::ARGUMENT_NAME("idx"), Argument::ARGUMENT_VALUE(std::to_string(idx).c_str()));
+        elog<InvalidArgument>(Argument::ARGUMENT_NAME("ipaddress"), Argument::ARGUMENT_VALUE(ipaddress.c_str()));
+    }
+
+    auto [reload, path] = createStaticIP(protType, ipaddress, prefixLength, ipgateway);
+    IfAddr ifaddr;
+
+    if (IP::Protocol::IPv4 == protType) {
+        ifaddr = {ToAddr<in_addr>{}(ipaddress), prefixLength};
+    }
+    else if (IP::Protocol::IPv6 == protType) {
+        ifaddr = {ToAddr<in6_addr>{}(ipaddress), prefixLength};
+    } // else if
+
+
+    if (reload) {
+        updateIpIndex(ifaddr, idx);
+        writeConfigurationFile();
+        manager.get().reloadConfigs();
+    } // if
+
+    return path;
+}
+
+void EthernetInterface::delIpIdx(std::string address, IP::Protocol protocolType) {
+    if (protocolType == IP::Protocol::IPv4) {
+        for (int i = 0; i < IPV4_MAX_NUM; i++) {
+            if (ipv4IndexUsedList.at(i).value_or("0.0.0.0") == address) {
+                ipv4IndexUsedList.at(i) = std::nullopt;
+                break;
+            } // if
+        } // for
+    } // if
+    else if (protocolType == IP::Protocol::IPv6) {
+        for (int i = 0; i < IPV6_MAX_NUM; i++) {
+            if (ipv6IndexUsedList.at(i).value_or("::") == address) {
+                ipv6IndexUsedList.at(i) = std::nullopt;
+                break;
+            } // if
+        } // for
+    }
 }
 
 ObjectPath EthernetInterface::neighbor(std::string ipAddress,
@@ -431,6 +644,9 @@ bool EthernetInterface::dhcp4(bool value)
                     }
                 );
             }
+
+            ipv4IndexUsedList.clear();
+            ipv4IndexUsedList.assign(IPV4_MAX_NUM+1, std::nullopt);
         }
 
         EthernetInterfaceIntf::dhcp4(value);
@@ -448,6 +664,10 @@ bool EthernetInterface::dhcp6(bool value)
     }
     if (dhcp6() != EthernetInterfaceIntf::dhcp6(value))
     {
+        if (value) {
+            ipv6IndexUsedList.clear();
+            ipv6IndexUsedList.assign(IPV6_MAX_NUM+1, std::nullopt);
+        } // if
         writeConfigurationFile();
         manager.get().reloadConfigs();
     }
@@ -853,22 +1073,46 @@ void EthernetInterface::writeConfigurationFile()
         }
         {
             config::Parser IfaceState;
-            auto& state = IfaceState.map["Network"].emplace_back();
-            state["IPv4Enable"].emplace_back(EthernetInterfaceIntf::ipv4Enable() ? "true" : "false");
-            state["IPv6Enable"].emplace_back(EthernetInterfaceIntf::ipv6Enable() ? "true" : "false");
-
-            auto& router = IfaceState.map["IPv6Router"].emplace_back();
-            router["IPv6EnableStaticRtr"].emplace_back(EthernetInterfaceIntf::ipv6EnableStaticRtr() ? "true" : "false");
-            if (EthernetInterfaceIntf::ipv6EnableStaticRtr()) {
-                router["IPv6StaticRtrAddr"].emplace_back(EthernetInterfaceIntf::ipv6StaticRtrAddr());
-                if (!EthernetInterfaceIntf::ipv6StaticRtrAddr().empty()) {
-                    if (auto it = staticNeighbors.find(ToAddr<in6_addr>{}(EthernetInterfaceIntf::ipv6StaticRtrAddr())); it != staticNeighbors.end()) {
-                        router["IPv6StaticRtrPrefix"].emplace_back(std::to_string(it->second->prefixLength()));
+            {
+                auto& state = IfaceState.map["Network"].emplace_back();
+                state["IPv4Enable"].emplace_back(EthernetInterfaceIntf::ipv4Enable() ? "true" : "false");
+                state["IPv6Enable"].emplace_back(EthernetInterfaceIntf::ipv6Enable() ? "true" : "false");
+
+                auto& router = IfaceState.map["IPv6Router"].emplace_back();
+                router["IPv6EnableStaticRtr"].emplace_back(EthernetInterfaceIntf::ipv6EnableStaticRtr() ? "true" : "false");
+                if (EthernetInterfaceIntf::ipv6EnableStaticRtr()) {
+                    router["IPv6StaticRtrAddr"].emplace_back(EthernetInterfaceIntf::ipv6StaticRtrAddr());
+                    if (!EthernetInterfaceIntf::ipv6StaticRtrAddr().empty()) {
+                        if (auto it = staticNeighbors.find(ToAddr<in6_addr>{}(EthernetInterfaceIntf::ipv6StaticRtrAddr())); it != staticNeighbors.end()) {
+                            router["IPv6StaticRtrPrefix"].emplace_back(std::to_string(it->second->prefixLength()));
+                        }
                     }
                 }
             }
-            IfaceState.writeFile(fs::path{fmt::format("{}/{}", manager.get().ifaceConfDir.generic_string(), interfaceName()).c_str()});
+            {
+                if (!dhcp4() || !dhcp6()) {
+                    auto& index = IfaceState.map["Address"].emplace_back()["Index"];
+                    if (!dhcp4() && EthernetInterfaceIntf::ipv4Enable()) {
+                        for (auto i = 0; i < ipv4IndexUsedList.size(); i++) {
+                            if (ipv4IndexUsedList.at(i).has_value()) {
+                                index.emplace_back(fmt::format("{}/{}", ipv4IndexUsedList.at(i).value(), i));
+                            }
+                        } // for
+                    } // if
 
+                    if (!dhcp6() && EthernetInterfaceIntf::ipv6Enable()) {
+                        for (auto i = 0; i < ipv6IndexUsedList.size(); i++) {
+                            if (ipv6IndexUsedList.at(i).has_value()) {
+                                index.emplace_back(fmt::format("{}/{}", ipv6IndexUsedList.at(i).value(), i));
+                            }
+                        } // for
+                    } // if
+                } // if
+            }
+
+            IfaceState.writeFile(fs::path{fmt::format("{}/{}", manager.get().ifaceConfDir.generic_string(), interfaceName()).c_str()});
+        }
+        {
             network["IPv6AcceptRA"].emplace_back(EthernetInterfaceIntf::ipv6Enable() && ipv6AcceptRA() ? "true" : "false");
             network["DHCP"].emplace_back(dhcp4() ? (dhcp6() ? "true" : "ipv4")
                                                 : (dhcp6() ? "ipv6" : "false"));
@@ -918,6 +1162,9 @@ void EthernetInterface::writeConfigurationFile()
                     }
                 }
             }
+        }
+        {
+
         }
         {
             auto& gateways = network["Gateway"];
@@ -1062,6 +1309,11 @@ void EthernetInterface::deleteAll()
 {
     // clear all the ip on the interface
     addrs.clear();
+    ipv4IndexUsedList.clear();
+    ipv4IndexUsedList.assign(IPV4_MAX_NUM+1, std::nullopt);
+
+    ipv6IndexUsedList.clear();
+    ipv6IndexUsedList.assign(IPV6_MAX_NUM+1, std::nullopt);
 
     writeConfigurationFile();
     manager.get().reloadConfigs();
@@ -1190,6 +1442,9 @@ void EthernetInterface::VlanProperties::delete_()
     std::filesystem::remove(config::pathForIntfConf(confDir, intf), ec);
     std::filesystem::remove(config::pathForIntfDev(confDir, intf), ec);
 
+    const auto& infoDir = eth.get().manager.get().getIfaceConfDir();
+    std::filesystem::remove(config::pathForIntfInfo(infoDir, intf), ec);
+
     if (eth.get().ifIdx > 0)
     {
         eth.get().manager.get().interfacesByIdx.erase(eth.get().ifIdx);
@@ -1806,5 +2061,39 @@ void EthernetInterface::registerSignal(sdbusplus::bus::bus& bus) {
     }
 }
 
+template<sdbusplus::common::xyz::openbmc_project::network::IP::Protocol family>
+int EthernetInterface::getProperIpIdx(std::vector<std::optional<std::string>>& list, InAddrAny addr) {
+    auto delimeter = ":";
+    int idx = 0;
+    int minIdx = IPV6_MAX_NUM;
+    int MAX_NUM = IPV6_MAX_NUM;
+    if (IP::Protocol::IPv4 == family) {
+        delimeter = ".";
+        minIdx = IPV4_MAX_NUM;
+        MAX_NUM = IPV4_MAX_NUM;
+    } // if
+    auto tmpAddr = std::to_string(addr);
+    if (tmpAddr.find(delimeter) != std::string::npos) {
+        for (int i = 0; i < MAX_NUM; i++) {
+            if (list.size() > i && !list.at(i).has_value() && minIdx == MAX_NUM) {
+                minIdx = i;
+            } // if
+            if (list.size() > i && list.at(i).has_value() && list.at(i).value() == tmpAddr) {
+                idx = i;
+                break;
+            } // if
+        } // for
+
+        if (idx == 0 && minIdx == 0) {
+            idx = 0;
+        } // if
+        else if (minIdx != MAX_NUM && idx == 0) {
+            idx = minIdx;
+        } // else if
+    }
+
+    return idx;
+}
+
 } // namespace network
 } // namespace phosphor
diff --git a/src/ethernet_interface.hpp b/src/ethernet_interface.hpp
index 880d54a..4955f40 100644
--- a/src/ethernet_interface.hpp
+++ b/src/ethernet_interface.hpp
@@ -137,6 +137,20 @@ class EthernetInterface : public Ifaces
     ObjectPath ip(IP::Protocol addressType, std::string ipAddress,
                   uint8_t prefixLength, std::string ipgateway) override;
 
+    /** @brief Implementation for IPWithIndex
+     *  Create ipaddress object with index.
+     *
+     *  @param[in] protocolType - protocol type can be IPv4 or IPv6 etc.
+     *  @param[in] address - IP Address.
+     *  @param[in] prefixLength - Prefix Length.
+     *  @param[in] idx - Default index is 0. Index value for IPv4 is 0. Index value for IPv6.
+     *  @param[in] gateway - Gateway Address.
+     *
+     *  @return path[sdbusplus::message::object_path] - The path for the created ipaddress object.
+     */
+    ObjectPath ipWithIndex(IP::Protocol protocolType, std::string address,
+                           uint8_t prefixLength, uint8_t idx, std::string gateway) override;
+
     /** @brief Function to create static neighbor dbus object.
      *  @param[in] ipAddress - IP address.
      *  @param[in] macAddress - Low level MAC address.
@@ -272,6 +286,9 @@ class EthernetInterface : public Ifaces
     /** Set value of IPv6StaticRtrAddr */
     std::string ipv6StaticRtrAddr(std::string value) override;
 
+    /** Delete the index according to given IP address*/
+    void delIpIdx(std::string address, IP::Protocol protocolType);
+
     using ChannelAccessIntf::maxPrivilege;
     using EthernetInterfaceIntf::interfaceName;
     using EthernetInterfaceIntf::linkUp;
@@ -387,6 +404,35 @@ class EthernetInterface : public Ifaces
      */
     int getCreatedVLANNum(std::filesystem::__cxx11::path confFile);
 
+    /** @brief Return the minimun index or the existing index by given address
+     *  @param[in] list - The list of IP address
+     *  @param[in] addr - The new IP address need giving index
+     *  @return Index of IP address in the list
+     */
+    template<sdbusplus::common::xyz::openbmc_project::network::IP::Protocol family>
+    int getProperIpIdx(std::vector<std::optional<std::string>>& list, InAddrAny addr);
+
+    /** @brief Update index table by the given address
+     *  @param[in] addr - The new IP address need adding into table
+     *  @param[in] index - The index of IP address
+     */
+    void updateIpIndex(IfAddr addr, std::variant<bool, int> index);
+
+    /** @brief Function to create ipAddress dbus object.
+     *  @param[in] protType - Type of ip address.
+     *  @param[in] ipAddress- IP address.
+     *  @param[in] prefixLength - Length of prefix.
+     *  @param[in] ipgateway - Gateway address.
+     *  @return A tuple containing whether the IP address exists and the object path
+     */
+    std::tuple<bool, ObjectPath> createStaticIP(IP::Protocol protType, std::string ipaddress,
+                                uint8_t prefixLength, std::string ipgateway);
+
+    /** List to save index and IPv4 Address */
+    std::vector<std::optional<std::string>> ipv4IndexUsedList;
+
+    /** List to save index and IPv6 Address */
+    std::vector<std::optional<std::string>> ipv6IndexUsedList;
 };
 
 } // namespace network
diff --git a/src/ipaddress.cpp b/src/ipaddress.cpp
index 3392da6..f40604f 100644
--- a/src/ipaddress.cpp
+++ b/src/ipaddress.cpp
@@ -47,14 +47,14 @@ struct Proto<in6_addr>
 
 IPAddress::IPAddress(sdbusplus::bus_t& bus, std::string_view objRoot,
                      stdplus::PinnedRef<EthernetInterface> parent, IfAddr addr,
-                     AddressOrigin origin) :
-    IPAddress(bus, makeObjPath(objRoot, addr), parent, addr, origin)
+                     AddressOrigin origin, uint8_t idx) :
+    IPAddress(bus, makeObjPath(objRoot, addr), parent, addr, origin, idx)
 {}
 
 IPAddress::IPAddress(sdbusplus::bus_t& bus,
                      sdbusplus::message::object_path objPath,
                      stdplus::PinnedRef<EthernetInterface> parent, IfAddr addr,
-                     AddressOrigin origin) :
+                     AddressOrigin origin, uint8_t idx) :
     IPIfaces(bus, objPath.str.c_str(), IPIfaces::action::defer_emit),
     parent(parent), objPath(std::move(objPath))
 {
@@ -64,6 +64,7 @@ IPAddress::IPAddress(sdbusplus::bus_t& bus,
                         addr.getAddr()),
              true);
     IP::origin(origin, true);
+    IP::idx(idx,true);
     emit_object_added();
 
 #ifdef AMI_IP_ADVANCED_ROUTING_SUPPORT
@@ -96,6 +97,10 @@ uint8_t IPAddress::prefixLength(uint8_t /*value*/)
 {
     elog<NotAllowed>(Reason("Property update is not allowed"));
 }
+uint8_t IPAddress::idx(uint8_t /*value*/)
+{
+    elog<NotAllowed>(Reason("Property update is not allowed"));
+}
 std::string IPAddress::gateway(std::string /*gateway*/)
 {
     elog<NotAllowed>(Reason("Property update is not allowed"));
@@ -127,6 +132,7 @@ void IPAddress::delete_()
         {
             ptr = std::move(it->second);
             addrs.erase(it);
+            parent.get().delIpIdx(this->address(), this->type());
             break;
         }
     }
diff --git a/src/ipaddress.hpp b/src/ipaddress.hpp
index 5272750..51148e1 100644
--- a/src/ipaddress.hpp
+++ b/src/ipaddress.hpp
@@ -41,11 +41,12 @@ class IPAddress : public IPIfaces
      */
     IPAddress(sdbusplus::bus_t& bus, std::string_view objRoot,
               stdplus::PinnedRef<EthernetInterface> parent, IfAddr addr,
-              IP::AddressOrigin origin);
+              IP::AddressOrigin origin, uint8_t idx);
     ~IPAddress();
 
     std::string address(std::string ipAddress) override;
     uint8_t prefixLength(uint8_t) override;
+    uint8_t idx(uint8_t) override;
     std::string gateway(std::string gateway) override;
     IP::Protocol type(IP::Protocol type) override;
     IP::AddressOrigin origin(IP::AddressOrigin origin) override;
@@ -59,6 +60,7 @@ class IPAddress : public IPIfaces
     using IP::origin;
     using IP::prefixLength;
     using IP::type;
+    using IP::idx;
 
     inline const auto& getObjPath() const
     {
@@ -74,7 +76,7 @@ class IPAddress : public IPIfaces
 
     IPAddress(sdbusplus::bus_t& bus, sdbusplus::message::object_path objPath,
               stdplus::PinnedRef<EthernetInterface> parent, IfAddr addr,
-              IP::AddressOrigin origin);
+              IP::AddressOrigin origin, uint8_t idx);
 };
 
 } // namespace network
diff --git a/src/network_manager.cpp b/src/network_manager.cpp
index b8602bd..c691454 100644
--- a/src/network_manager.cpp
+++ b/src/network_manager.cpp
@@ -681,6 +681,13 @@ void Manager::reset()
         std::error_code ec;
         std::filesystem::remove(dirent.path(), ec);
     }
+
+    for (const auto& dirent : std::filesystem::directory_iterator(ifaceConfDir))
+    {
+        std::error_code ec;
+        std::filesystem::remove(dirent.path(), ec);
+    }
+
     lg2::info("Network data purged.");
 
     if (!createDefaultARPControlFiles(true))
diff --git a/src/types.hpp b/src/types.hpp
index c0100e6..b7814fa 100644
--- a/src/types.hpp
+++ b/src/types.hpp
@@ -108,11 +108,12 @@ struct AddressInfo
     IfAddr ifaddr;
     uint8_t scope;
     uint32_t flags;
+    uint8_t idx;
 
     constexpr bool operator==(const AddressInfo& rhs) const noexcept
     {
         return ifidx == rhs.ifidx && ifaddr == rhs.ifaddr &&
-               scope == rhs.scope && flags == rhs.flags;
+               scope == rhs.scope && flags == rhs.flags && idx == rhs.idx;
     }
 };
 
diff --git a/src/util.cpp b/src/util.cpp
index 7d6535d..e2b3ba5 100644
--- a/src/util.cpp
+++ b/src/util.cpp
@@ -262,6 +262,27 @@ std::string getGarpInterval(const config::Parser& parser)
        }
 }
 
+std::tuple<std::vector<std::optional<std::string>>,std::vector<std::optional<std::string>>> getIndexList(const config::Parser& parser) {
+    auto list = parser.map.getValueStrings("Address", "Index");
+    std::vector<std::optional<std::string>> ipv4List(IPV4_MAX_NUM);
+    std::vector<std::optional<std::string>> ipv6List(IPV6_MAX_NUM);
+
+    for (std::string vv : list) {
+        bool ipv6 = vv.find(":") == std::string::npos ? false : true;
+        auto delimeterIdx = vv.find_first_of("/");
+        std::string addr(vv.begin(), vv.begin()+delimeterIdx);
+        int idx = std::stoi(std::string(vv.begin()+delimeterIdx+1,vv.end()));
+        if (ipv6) {
+            ipv6List.at(idx) = addr;
+        } // if
+        else {
+            ipv4List.at(idx) = addr;
+        }
+    }
+
+    return std::make_tuple(ipv4List, ipv6List);
+}
+
 namespace ip_address {
 
 bool in6AddrIetfProtocolAssignment(in6_addr* addr) {
diff --git a/src/util.hpp b/src/util.hpp
index cc30746..16d66ca 100644
--- a/src/util.hpp
+++ b/src/util.hpp
@@ -8,6 +8,11 @@
 #include <string>
 #include <string_view>
 #include <unordered_set>
+#include <tuple>
+#include <vector>
+
+constexpr auto IPV4_MAX_NUM = 1;
+constexpr auto IPV6_MAX_NUM = 16;
 
 namespace phosphor
 {
@@ -129,6 +134,11 @@ bool getIP4Enable(const config::Parser& config);
  */
 bool getIP6Enable(const config::Parser& config);
 
+/** @brief read the Index of IP address from the configuration file
+ *  @param[in] config - The parsed configuration.
+ */
+std::tuple<std::vector<std::optional<std::string>>,std::vector<std::optional<std::string>>> getIndexList(const config::Parser& parser);
+
 /** @brief read the DHCP value from the configuration file
  *  @param[in] config - The parsed configuration.
  */
diff --git a/yaml/xyz/openbmc_project/Network/IP/Create.interface.yaml b/yaml/xyz/openbmc_project/Network/IP/Create.interface.yaml
index 61bd676..eba1094 100644
--- a/yaml/xyz/openbmc_project/Network/IP/Create.interface.yaml
+++ b/yaml/xyz/openbmc_project/Network/IP/Create.interface.yaml
@@ -28,3 +28,37 @@ methods:
       errors:
           - xyz.openbmc_project.Common.Error.InvalidArgument
           - xyz.openbmc_project.Common.Error.NotAllowed
+    - name: IPWithIndex
+      description: >
+          Create ipaddress object with index.
+      parameters:
+          - name: ProtocolType
+            type: enum[xyz.openbmc_project.Network.IP.Protocol]
+            description: >
+                protocol type can be IPv4 or IPv6 etc.
+          - name: Address
+            type: string
+            description: >
+                IP Address.
+          - name: PrefixLength
+            type: byte
+            description: >
+                Prefix Length.
+          - name: idx
+            type: byte
+            description: >
+                Default index is 0.
+                Index value for IPv4 is 0.
+                Index value for IPv6.
+          - name: Gateway
+            type: string
+            description: >
+                Gateway Address.
+      returns:
+          - name: Path
+            type: object_path
+            description: >
+                The path for the created ipaddress object.
+      errors:
+          - xyz.openbmc_project.Common.Error.InvalidArgument
+          - xyz.openbmc_project.Common.Error.NotAllowed
-- 
2.25.1

