From bb4652ad6bbff5f8790a15382190fd9e2e896d09 Mon Sep 17 00:00:00 2001
From: Mohammed Javith Akthar M <mohammedjavitham@ami.com>
Date: Wed, 14 Jun 2023 10:17:49 +0530
Subject: [PATCH 2/2] Upstream obmc-ikvm server from ASPEED SDK v08.05

Enables partial JPEG capture support in KVM server. This method captures
only modified screen region as smaller rectangle.

This approach saves network bandwidth compared to current KVM server
configuration (full frame JPEG compression). Also compatible with 3rd
party VNC clients such as TightVNC.

Signed-off-by: Mohammed Javith Akthar M <mohammedjavitham@ami.com>
---
 ikvm_args.cpp       |  27 +++++----
 ikvm_args.hpp       |   8 ++-
 ikvm_manager.cpp    |   3 +-
 ikvm_server.cpp     |  54 +++++++++++++++---
 ikvm_video.cpp      | 130 +++++++++++++++++++++++++++++++++-----------
 ikvm_video.hpp      |  73 +++++++++++++++++++++++--
 start-ipkvm.service |   2 +-
 7 files changed, 237 insertions(+), 60 deletions(-)

diff --git a/ikvm_args.cpp b/ikvm_args.cpp
index 4887870..b83da7a 100644
--- a/ikvm_args.cpp
+++ b/ikvm_args.cpp
@@ -7,21 +7,18 @@
 
 namespace ikvm
 {
-
 Args::Args(int argc, char* argv[]) :
-    frameRate(30), subsampling(0), calcFrameCRC{false}, commandLine(argc, argv)
+    frameRate(60), subsampling(0), format(2), calcFrameCRC{false},
+    commandLine(argc, argv)
 {
     int option;
-    const char* opts = "f:s:h:k:p:u:v:c";
-    struct option lopts[] = {{"frameRate", 1, 0, 'f'},
-                             {"subsampling", 1, 0, 's'},
-                             {"help", 0, 0, 'h'},
-                             {"keyboard", 1, 0, 'k'},
-                             {"mouse", 1, 0, 'p'},
-                             {"udcName", 1, 0, 'u'},
-                             {"videoDevice", 1, 0, 'v'},
-                             {"calcCRC", 0, 0, 'c'},
-                             {0, 0, 0, 0}};
+    const char* opts = "f:s:m:h:k:p:u:v:c";
+    struct option lopts[] = {
+        {"frameRate", 1, 0, 'f'}, {"subsampling", 1, 0, 's'},
+        {"format", 1, 0, 'm'},    {"help", 0, 0, 'h'},
+        {"keyboard", 1, 0, 'k'},  {"mouse", 1, 0, 'p'},
+        {"udcName", 1, 0, 'u'},   {"videoDevice", 1, 0, 'v'},
+        {"calcCRC", 0, 0, 'c'},   {0, 0, 0, 0}};
 
     while ((option = getopt_long(argc, argv, opts, lopts, NULL)) != -1)
     {
@@ -37,6 +34,11 @@ Args::Args(int argc, char* argv[]) :
                 if (subsampling < 0 || subsampling > 1)
                     subsampling = 0;
                 break;
+            case 'm':
+                format = (int)strtol(optarg, NULL, 0);
+                if (format < 0 || format > 2 || format == 1)
+                    format = 0;
+                break;
             case 'h':
                 printUsage();
                 exit(0);
@@ -66,6 +68,7 @@ void Args::printUsage()
     fprintf(stderr, "Usage: obmc-ikvm [options]\n");
     fprintf(stderr, "-f frame rate          try this frame rate\n");
     fprintf(stderr, "-s subsampling         try this subsampling\n");
+    fprintf(stderr, "-m format              try this format\n");
     fprintf(stderr, "-h, --help             show this message and exit\n");
     fprintf(stderr, "-k device              HID keyboard gadget device\n");
     fprintf(stderr, "-p device              HID mouse gadget device\n");
diff --git a/ikvm_args.hpp b/ikvm_args.hpp
index cb3d3ad..6b4e93b 100644
--- a/ikvm_args.hpp
+++ b/ikvm_args.hpp
@@ -4,7 +4,6 @@
 
 namespace ikvm
 {
-
 /*
  * @class Args
  * @brief Command line argument parser and storage
@@ -80,6 +79,11 @@ class Args
         return subsampling;
     }
 
+    inline int getFormat() const
+    {
+        return format;
+    }
+
     /*
      * @brief Get the path to the USB keyboard device
      *
@@ -141,6 +145,8 @@ class Args
     int frameRate;
     /* @brief Desired subsampling (0: 444, 1: 420) */
     int subsampling;
+    /* @brief Desired format (0: standard, 1: aspeed, 2: partial jpeg) */
+    int format;
     /* @brief Path to the USB keyboard device */
     std::string keyboardPath;
     /* @brief Path to the USB mouse device */
diff --git a/ikvm_manager.cpp b/ikvm_manager.cpp
index 93fd1ce..3a0b815 100644
--- a/ikvm_manager.cpp
+++ b/ikvm_manager.cpp
@@ -4,12 +4,11 @@
 
 namespace ikvm
 {
-
 Manager::Manager(const Args& args) :
     continueExecuting(true), serverDone(false), videoDone(true),
     input(args.getKeyboardPath(), args.getPointerPath(), args.getUdcName()),
     video(args.getVideoPath(), input, args.getFrameRate(),
-          args.getSubsampling()),
+          args.getSubsampling(), args.getFormat()),
     server(args, input, video)
 {}
 
diff --git a/ikvm_server.cpp b/ikvm_server.cpp
index 141f6c6..0e6ccf9 100644
--- a/ikvm_server.cpp
+++ b/ikvm_server.cpp
@@ -8,9 +8,11 @@
 #include <phosphor-logging/log.hpp>
 #include <xyz/openbmc_project/Common/error.hpp>
 
+#define rfbEncodingAspeed 18
+#define ROUND_DOWN(x, r) ((x) & ~((r)-1))
+
 namespace ikvm
 {
-
 using namespace phosphor::logging;
 using namespace sdbusplus::xyz::openbmc_project::Common::Error;
 
@@ -94,9 +96,11 @@ void Server::run()
 void Server::sendFrame()
 {
     char* data = video.getData();
+    uint32_t frameCount = 0;
     rfbClientIteratorPtr it;
     rfbClientPtr cl;
     int64_t frame_crc = -1;
+    bool frame_sent = false;
 
     if (!data || pendingResize)
     {
@@ -109,6 +113,7 @@ void Server::sendFrame()
     {
         ClientData* cd = (ClientData*)cl->clientData;
         rfbFramebufferUpdateMsg* fu = (rfbFramebufferUpdateMsg*)cl->updateBuf;
+        auto i = video.buffersDone.front();
 
         if (!cd)
         {
@@ -146,6 +151,7 @@ void Server::sendFrame()
         }
 
         cd->needUpdate = false;
+        frame_sent = true;
 
         if (cl->enableLastRectEncoding)
         {
@@ -160,11 +166,39 @@ void Server::sendFrame()
         cl->ublen = sz_rfbFramebufferUpdateMsg;
         rfbSendUpdateBuf(cl);
 
-        cl->tightEncoding = rfbEncodingTight;
-        rfbSendTightHeader(cl, 0, 0, video.getWidth(), video.getHeight());
+        if (video.getFormat() == 1)
+        {
+            cl->tightEncoding = rfbEncodingAspeed;
+            rfbSendTightHeader(cl, 0, 0, video.getWidth(), video.getHeight());
+
+            frameCount = video.getFrameCount(i);
+            cl->updateBuf[cl->ublen++] = (char)(0);
+            cl->updateBuf[cl->ublen++] = (char)(frameCount >> 24 & 0xff);
+            cl->updateBuf[cl->ublen++] = (char)(frameCount >> 16 & 0xff);
+            cl->updateBuf[cl->ublen++] = (char)(frameCount >> 8 & 0xff);
+            cl->updateBuf[cl->ublen++] = (char)(frameCount & 0xff);
+            cl->updateBuf[cl->ublen++] = (char)(video.getSubsampling());
+            cl->updateBuf[cl->ublen++] =
+                (char)(0x00); // the value of quality if changed
+        }
+        else
+        {
+            cl->tightEncoding = rfbEncodingTight;
+            if (video.getFormat() == 2)
+            {
+                v4l2_rect r = video.getBoundingBox(i);
 
-        cl->updateBuf[cl->ublen++] = (char)(rfbTightJpeg << 4);
-        rfbSendCompressedDataTight(cl, data, video.getFrameSize());
+                rfbSendTightHeader(cl, r.left, r.top, r.width, r.height);
+            }
+            else
+            {
+                rfbSendTightHeader(cl, 0, 0, video.getWidth(),
+                                   video.getHeight());
+            }
+
+            cl->updateBuf[cl->ublen++] = (char)(rfbTightJpeg << 4);
+        }
+        rfbSendCompressedDataTight(cl, data, video.getFrameSize(i));
 
         if (cl->enableLastRectEncoding)
         {
@@ -175,6 +209,9 @@ void Server::sendFrame()
     }
 
     rfbReleaseClientIterator(it);
+
+    if (frame_sent)
+        video.releaseFrames();
 }
 
 void Server::clientFramebufferUpdateRequest(
@@ -210,8 +247,8 @@ enum rfbNewClientAction Server::newClient(rfbClientPtr cl)
 {
     Server* server = (Server*)cl->screen->screenData;
 
-    cl->clientData =
-        new ClientData(server->video.getFrameRate(), &server->input);
+    cl->clientData = new ClientData(ROUND_DOWN(server->video.getFrameRate(), 8),
+                                    &server->input);
     cl->clientGoneHook = clientGone;
     cl->clientFramebufferUpdateRequestHook = clientFramebufferUpdateRequest;
     if (!server->numClients++)
@@ -248,8 +285,9 @@ void Server::doResize()
             continue;
         }
 
+        // let skipFrame round-down per interval of aspeed's I frame
         // delay video updates to give the client time to resize
-        cd->skipFrame = video.getFrameRate();
+        cd->skipFrame = ROUND_DOWN(video.getFrameRate(), 8);
     }
 
     rfbReleaseClientIterator(it);
diff --git a/ikvm_video.cpp b/ikvm_video.cpp
index 734294e..b908f87 100644
--- a/ikvm_video.cpp
+++ b/ikvm_video.cpp
@@ -19,9 +19,11 @@
 #include <xyz/openbmc_project/Common/Device/error.hpp>
 #include <xyz/openbmc_project/Common/File/error.hpp>
 
+#define V4L2_PIX_FMT_AJPG v4l2_fourcc('A', 'J', 'P', 'G')
+#define V4L2_PIX_FMT_FLAG_PARTIAL_JPG 0x00000004
+
 namespace ikvm
 {
-
 const int Video::bitsPerSample(8);
 const int Video::bytesPerPixel(4);
 const int Video::samplesPerPixel(3);
@@ -30,9 +32,9 @@ using namespace phosphor::logging;
 using namespace sdbusplus::xyz::openbmc_project::Common::File::Error;
 using namespace sdbusplus::xyz::openbmc_project::Common::Device::Error;
 
-Video::Video(const std::string& p, Input& input, int fr, int sub) :
+Video::Video(const std::string& p, Input& input, int fr, int sub, int fmt) :
     resizeAfterOpen(false), timingsError(false), fd(-1), frameRate(fr),
-    lastFrameIndex(-1), height(600), width(800), subSampling(sub), input(input),
+    height(600), width(800), subSampling(sub), format(fmt), input(input),
     path(p)
 {}
 
@@ -43,12 +45,21 @@ Video::~Video()
 
 char* Video::getData()
 {
-    if (lastFrameIndex >= 0)
+    if (buffersDone.empty())
     {
-        return (char*)buffers[lastFrameIndex].data;
+        return nullptr;
     }
 
-    return nullptr;
+    return (char*)buffers[buffersDone.front()].data;
+}
+
+char* Video::getData(unsigned int i)
+{
+    if (i >= buffers.size())
+    {
+        return nullptr;
+    }
+    return (char*)buffers[i].data;
 }
 
 void Video::getFrame()
@@ -58,12 +69,20 @@ void Video::getFrame()
     v4l2_buffer buf;
     fd_set fds;
     timeval tv;
+    v4l2_selection comp = {.type = V4L2_BUF_TYPE_VIDEO_CAPTURE,
+                           .target = V4L2_SEL_TGT_CROP_DEFAULT};
 
     if (fd < 0)
     {
         return;
     }
 
+    // Don't get more new frames until we run out of previous ones
+    if (!buffersDone.empty())
+    {
+        return;
+    }
+
     FD_ZERO(&fds);
     FD_SET(fd, &fds);
 
@@ -92,48 +111,73 @@ void Video::getFrame()
 
                 if (!(buf.flags & V4L2_BUF_FLAG_ERROR))
                 {
-                    lastFrameIndex = buf.index;
-                    buffers[lastFrameIndex].payload = buf.bytesused;
-                    break;
+                    buffers[buf.index].payload = buf.bytesused;
+                    buffers[buf.index].sequence = buf.sequence;
+                    if (format == 2)
+                    {
+                        rc = ioctl(fd, VIDIOC_G_SELECTION, &comp);
+                        if (rc)
+                        {
+                            log<level::ERR>("Failed to get selection box",
+                                            entry("ERROR=%s", strerror(errno)));
+                            comp.r.left = 0;
+                            comp.r.top = 0;
+                            comp.r.width = width;
+                            comp.r.height = height;
+                        }
+                        buffers[buf.index].box = comp.r;
+                    }
+                    buffersDone.push_back(buf.index);
                 }
                 else
                 {
                     buffers[buf.index].payload = 0;
+                    qbuf(buf.index);
                 }
             }
         } while (rc >= 0);
     }
 
     fcntl(fd, F_SETFL, fd_flags);
+}
+
+void Video::qbuf(int i)
+{
+    int rc;
+    v4l2_buffer buf;
 
-    for (unsigned int i = 0; i < buffers.size(); ++i)
+    if (!buffers[i].queued)
     {
-        if (i == (unsigned int)lastFrameIndex)
+        memset(&buf, 0, sizeof(v4l2_buffer));
+        buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        buf.memory = V4L2_MEMORY_MMAP;
+        buf.index = i;
+
+        rc = ioctl(fd, VIDIOC_QBUF, &buf);
+        if (rc)
         {
-            continue;
+            log<level::ERR>("Failed to queue buffer",
+                            entry("ERROR=%s", strerror(errno)));
         }
-
-        if (!buffers[i].queued)
+        else
         {
-            memset(&buf, 0, sizeof(v4l2_buffer));
-            buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-            buf.memory = V4L2_MEMORY_MMAP;
-            buf.index = i;
-
-            rc = ioctl(fd, VIDIOC_QBUF, &buf);
-            if (rc)
-            {
-                log<level::ERR>("Failed to queue buffer",
-                                entry("ERROR=%s", strerror(errno)));
-            }
-            else
-            {
-                buffers[i].queued = true;
-            }
+            buffers[i].queued = true;
         }
     }
 }
 
+void Video::releaseFrames()
+{
+    int i;
+
+    if (!buffersDone.empty())
+    {
+        i = buffersDone.front();
+        buffersDone.pop_front();
+        qbuf(i);
+    }
+}
+
 bool Video::needsResize()
 {
     int rc;
@@ -183,7 +227,7 @@ bool Video::needsResize()
                 xyz::openbmc_project::Common::File::Open::PATH(path.c_str()));
         }
 
-        lastFrameIndex = -1;
+        buffersDone.clear();
         return true;
     }
 
@@ -434,6 +478,30 @@ void Video::start()
                 CALLOUT_DEVICE_PATH(path.c_str()));
     }
 
+    switch (format)
+    {
+        case 2:
+            fmt.fmt.pix.flags = V4L2_PIX_FMT_FLAG_PARTIAL_JPG;
+        default:
+        case 0:
+            fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_JPEG;
+            break;
+        case 1:
+            fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_AJPG;
+            break;
+    }
+    rc = ioctl(fd, VIDIOC_S_FMT, &fmt);
+    if (rc < 0)
+    {
+        log<level::ERR>("Failed to set video device format",
+                        entry("ERROR=%s", strerror(errno)));
+        elog<ReadFailure>(
+            xyz::openbmc_project::Common::Device::ReadFailure::CALLOUT_ERRNO(
+                errno),
+            xyz::openbmc_project::Common::Device::ReadFailure::
+                CALLOUT_DEVICE_PATH(path.c_str()));
+    }
+
     memset(&sparm, 0, sizeof(v4l2_streamparm));
     sparm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
     sparm.parm.capture.timeperframe.numerator = 1;
@@ -477,7 +545,7 @@ void Video::stop()
         return;
     }
 
-    lastFrameIndex = -1;
+    buffersDone.clear();
 
     rc = ioctl(fd, VIDIOC_STREAMOFF, &type);
     if (rc)
diff --git a/ikvm_video.hpp b/ikvm_video.hpp
index 17477df..d8a7406 100644
--- a/ikvm_video.hpp
+++ b/ikvm_video.hpp
@@ -2,13 +2,15 @@
 
 #include "ikvm_input.hpp"
 
+#include <linux/videodev2.h>
+
+#include <deque>
 #include <mutex>
 #include <string>
 #include <vector>
 
 namespace ikvm
 {
-
 /*
  * @class Video
  * @brief Sets up the V4L2 video device and performs read operations
@@ -23,7 +25,8 @@ class Video
      * @param[in] input - Reference to the Input object
      * @param[in] fr    - desired frame rate of the video
      */
-    Video(const std::string& p, Input& input, int fr = 30, int sub = 0);
+    Video(const std::string& p, Input& input, int fr = 30, int sub = 0,
+          int fmt = 0);
     ~Video();
     Video(const Video&) = default;
     Video& operator=(const Video&) = default;
@@ -36,8 +39,11 @@ class Video
      * @return Pointer to the video frame data
      */
     char* getData();
+    char* getData(unsigned int i);
     /* @brief Performs read to grab latest video frame */
     void getFrame();
+    /* @brief Performs return done video frames back to driver */
+    void releaseFrames();
     /*
      * @brief Gets whether or not the video frame needs to be resized
      *
@@ -73,7 +79,28 @@ class Video
      */
     inline size_t getFrameSize() const
     {
-        return buffers[lastFrameIndex].payload;
+        if (buffersDone.empty())
+            return 0;
+        return buffers[buffersDone.front()].payload;
+    }
+    inline size_t getFrameSize(unsigned int i) const
+    {
+        return buffers[i].payload;
+    }
+    /*
+     * @brief Gets the video frame count in sequence
+     *
+     * @return Value of video frame count in sequence
+     */
+    inline size_t getFrameCount() const
+    {
+        if (buffersDone.empty())
+            return 0;
+        return buffers[buffersDone.front()].sequence;
+    }
+    inline size_t getFrameCount(unsigned int i) const
+    {
+        return buffers[i].sequence;
     }
     /*
      * @brief Gets the height of the video frame
@@ -111,6 +138,36 @@ class Video
     {
         subSampling = _sub;
     }
+    /*
+     * @brief Gets the jpeg format of the video frame
+     *
+     * @return Value of the jpeg format of video frame
+     *         0:standard jpeg, 1:aspeed(N/A) , 2:Partial jpeg
+     */
+    inline int getFormat() const
+    {
+        return format;
+    }
+    /*
+     * @brief Sets the jpeg format of the video frame
+     *
+     * @return Value of the jpeg format of video frame
+     *         0:standard jpeg, 1:aspeed(N/A) , 2:Partial jpeg
+     */
+    inline void setFormat(int _fmt)
+    {
+        format = _fmt;
+    }
+
+    /*
+     * @brief Gets the bounding-box of the partial-jpeg
+     *
+     * @return Bounding-box of the video frame
+     */
+    inline v4l2_rect getBoundingBox(unsigned int i) const
+    {
+        return buffers[i].box;
+    }
 
     /* @brief Number of bits per component of a pixel */
     static const int bitsPerSample;
@@ -118,8 +175,12 @@ class Video
     static const int bytesPerPixel;
     /* @brief Number of components in a pixel (i.e. 3 for RGB pixel) */
     static const int samplesPerPixel;
+    /* @brief done buffer storage */
+    std::deque<int> buffersDone;
 
   private:
+    void qbuf(int i);
+
     /*
      * @struct Buffer
      * @brief Store the address and size of frame data from streaming
@@ -139,6 +200,8 @@ class Video
         bool queued;
         size_t payload;
         size_t size;
+        uint32_t sequence;
+        v4l2_rect box;
     };
 
     /*
@@ -152,14 +215,14 @@ class Video
     int fd;
     /* @brief Desired frame rate of video stream in frames per second */
     int frameRate;
-    /* @brief Buffer index for the last video frame */
-    int lastFrameIndex;
     /* @brief Height in pixels of the video frame */
     size_t height;
     /* @brief Width in pixels of the video frame */
     size_t width;
     /* @brief jpeg's subsampling, 1:420/0:444 */
     int subSampling;
+    /* @brief jpeg format */
+    int format;
     /* @brief Reference to the Input object */
     Input& input;
     /* @brief Path to the V4L2 video device */
diff --git a/start-ipkvm.service b/start-ipkvm.service
index 10e4248..e193719 100644
--- a/start-ipkvm.service
+++ b/start-ipkvm.service
@@ -5,7 +5,7 @@ ConditionPathIsMountPoint=/sys/kernel/config
 [Service]
 Restart=always
 ExecStartPre=/usr/bin/create_usbhid.sh disconnect
-ExecStart=/usr/bin/obmc-ikvm -c -v /dev/video0 -k /dev/hidg0 -p /dev/hidg1
+ExecStart=/usr/bin/obmc-ikvm -v /dev/video0 -k /dev/hidg0 -p /dev/hidg1 -m 2 -f 60
 
 [Install]
 WantedBy=multi-user.target
-- 
2.25.1

