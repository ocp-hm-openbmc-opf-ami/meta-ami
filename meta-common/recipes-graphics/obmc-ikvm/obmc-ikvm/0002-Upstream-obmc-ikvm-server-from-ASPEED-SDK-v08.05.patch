From 463fdc59477b99c211966b84b553c457afa4ab26 Mon Sep 17 00:00:00 2001
From: Mohammed Javith Akthar M <mohammedjavitham@ami.com>
Date: Thu, 25 May 2023 14:31:05 +0530
Subject: [PATCH 2/2] Upstream obmc-ikvm server from ASPEED SDK v08.05

Enables partial JPEG capture support in KVM server. This method captures
only modified screen region as smaller rectangle.

This approach saves network bandwidth compared to current KVM server
configuration (full frame JPEG compression). Also compatible with 3rd
party VNC clients such as TightVNC.

Signed-off-by: Mohammed Javith Akthar M <mohammedjavitham@ami.com>
---
 ikvm_args.cpp       |  26 +++++----
 ikvm_args.hpp       |  22 +++-----
 ikvm_input.cpp      |  60 ++++++--------------
 ikvm_input.hpp      |  12 ++--
 ikvm_manager.cpp    |   8 +--
 ikvm_server.cpp     |  73 ++++++++++++++----------
 ikvm_server.hpp     |   4 +-
 ikvm_video.cpp      | 134 +++++++++++++++++++++++++++++++++-----------
 ikvm_video.hpp      |  73 ++++++++++++++++++++++--
 9 files changed, 263 insertions(+), 149 deletions(-)

diff --git a/ikvm_args.cpp b/ikvm_args.cpp
index 4887870..4f4f4cf 100644
--- a/ikvm_args.cpp
+++ b/ikvm_args.cpp
@@ -8,21 +8,23 @@
 namespace ikvm
 {
 
-Args::Args(int argc, char* argv[]) :
-    frameRate(30), subsampling(0), calcFrameCRC{false}, commandLine(argc, argv)
+Args::Args(int argc, char* argv[]) : frameRate(30), subsampling(0), format(0), calcFrameCRC{false},
+                                     commandLine(argc, argv)
 {
     int option;
-    const char* opts = "f:s:h:k:p:u:v:c";
+    const char* opts = "f:s:m:h:k:p:v:c";
     struct option lopts[] = {{"frameRate", 1, 0, 'f'},
                              {"subsampling", 1, 0, 's'},
+                             {"format", 1, 0, 'm'},
                              {"help", 0, 0, 'h'},
                              {"keyboard", 1, 0, 'k'},
                              {"mouse", 1, 0, 'p'},
-                             {"udcName", 1, 0, 'u'},
                              {"videoDevice", 1, 0, 'v'},
                              {"calcCRC", 0, 0, 'c'},
                              {0, 0, 0, 0}};
 
+    frameRate = 60;
+    format = 2;
     while ((option = getopt_long(argc, argv, opts, lopts, NULL)) != -1)
     {
         switch (option)
@@ -37,6 +39,11 @@ Args::Args(int argc, char* argv[]) :
                 if (subsampling < 0 || subsampling > 1)
                     subsampling = 0;
                 break;
+            case 'm':
+                format = (int)strtol(optarg, NULL, 0);
+                if (format < 0 || format > 2)
+                    format = 0;
+                break;
             case 'h':
                 printUsage();
                 exit(0);
@@ -46,9 +53,6 @@ Args::Args(int argc, char* argv[]) :
             case 'p':
                 pointerPath = std::string(optarg);
                 break;
-            case 'u':
-                udcName = std::string(optarg);
-                break;
             case 'v':
                 videoPath = std::string(optarg);
                 break;
@@ -57,6 +61,7 @@ Args::Args(int argc, char* argv[]) :
                 break;
         }
     }
+	
 }
 
 void Args::printUsage()
@@ -66,15 +71,12 @@ void Args::printUsage()
     fprintf(stderr, "Usage: obmc-ikvm [options]\n");
     fprintf(stderr, "-f frame rate          try this frame rate\n");
     fprintf(stderr, "-s subsampling         try this subsampling\n");
+    fprintf(stderr, "-m format              try this format\n");
     fprintf(stderr, "-h, --help             show this message and exit\n");
     fprintf(stderr, "-k device              HID keyboard gadget device\n");
     fprintf(stderr, "-p device              HID mouse gadget device\n");
-    fprintf(stderr,
-            "-u udc name            UDC that HID gadget will connect to\n");
     fprintf(stderr, "-v device              V4L2 device\n");
-    fprintf(
-        stderr,
-        "-c, --calcCRC          Calculate CRC for each frame to save bandwidth\n");
+    fprintf(stderr, "-c, --calcCRC          Calculate CRC for each frame to save bandwidth\n");
     rfbUsage();
 }
 
diff --git a/ikvm_args.hpp b/ikvm_args.hpp
index cb3d3ad..a39fc27 100644
--- a/ikvm_args.hpp
+++ b/ikvm_args.hpp
@@ -25,7 +25,8 @@ class Args
          * @param[in] v - Array of arguments
          */
         CommandLine(int c, char** v) : argc(c), argv(v)
-        {}
+        {
+        }
         ~CommandLine() = default;
         CommandLine(const CommandLine&) = default;
         CommandLine& operator=(const CommandLine&) = default;
@@ -80,6 +81,11 @@ class Args
         return subsampling;
     }
 
+    inline int getFormat() const
+    {
+        return format;
+    }
+
     /*
      * @brief Get the path to the USB keyboard device
      *
@@ -100,16 +106,6 @@ class Args
         return pointerPath;
     }
 
-    /*
-     * @brief Get the name of UDC
-     *
-     * @return Reference to the string storing the name of UDC
-     */
-    inline const std::string& getUdcName() const
-    {
-        return udcName;
-    }
-
     /*
      * @brief Get the path to the V4L2 video device
      *
@@ -141,12 +137,12 @@ class Args
     int frameRate;
     /* @brief Desired subsampling (0: 444, 1: 420) */
     int subsampling;
+	/* @brief Desired format (0: standard, 1: aspeed) */
+    int format;
     /* @brief Path to the USB keyboard device */
     std::string keyboardPath;
     /* @brief Path to the USB mouse device */
     std::string pointerPath;
-    /* @brief Name of UDC */
-    std::string udcName;
     /* @brief Path to the V4L2 video device */
     std::string videoPath;
     /* @brief Identical frames detection */
diff --git a/ikvm_input.cpp b/ikvm_input.cpp
index 107756b..c295091 100644
--- a/ikvm_input.cpp
+++ b/ikvm_input.cpp
@@ -1,7 +1,6 @@
 #include "ikvm_input.hpp"
 
 #include "ikvm_server.hpp"
-#include "scancodes.hpp"
 
 #include <err.h>
 #include <errno.h>
@@ -15,6 +14,8 @@
 #include <phosphor-logging/log.hpp>
 #include <xyz/openbmc_project/Common/File/error.hpp>
 
+#include "scancodes.hpp"
+
 namespace fs = std::filesystem;
 
 namespace ikvm
@@ -23,11 +24,9 @@ namespace ikvm
 using namespace phosphor::logging;
 using namespace sdbusplus::xyz::openbmc_project::Common::File::Error;
 
-Input::Input(const std::string& kbdPath, const std::string& ptrPath,
-             const std::string& udc) :
-    keyboardFd(-1),
-    pointerFd(-1), keyboardReport{0}, pointerReport{0}, keyboardPath(kbdPath),
-    pointerPath(ptrPath), udcName(udc)
+Input::Input(const std::string& kbdPath, const std::string& ptrPath) :
+    keyboardFd(-1), pointerFd(-1), keyboardReport{0}, pointerReport{0},
+    keyboardPath(kbdPath), pointerPath(ptrPath)
 {
     hidUdcStream.exceptions(std::ofstream::failbit | std::ofstream::badbit);
     hidUdcStream.open(hidUdcPath, std::ios::out | std::ios::app);
@@ -53,23 +52,17 @@ void Input::connect()
 {
     try
     {
-        if (udcName.empty())
+        for (const auto& port : fs::directory_iterator(usbVirtualHubPath))
         {
-            for (const auto& port : fs::directory_iterator(usbVirtualHubPath))
+            if (fs::is_directory(port) && !fs::is_symlink(port) &&
+                fs::exists(port.path() / "gadget") &&
+                !fs::exists(port.path() / "gadget/suspended"))
             {
-                if (fs::is_directory(port) && !fs::is_symlink(port) &&
-                    !fs::exists(port.path() / "gadget/suspended"))
-                {
-                    const std::string portId = port.path().filename();
-                    hidUdcStream << portId << std::endl;
-                    break;
-                }
+                const std::string portId = port.path().filename();
+                hidUdcStream << portId << std::endl;
+                break;
             }
         }
-        else // If UDC has been specified by '-u' parameter, connect to it.
-        {
-            hidUdcStream << udcName << std::endl;
-        }
     }
     catch (fs::filesystem_error& e)
     {
@@ -86,8 +79,8 @@ void Input::connect()
 
     if (!keyboardPath.empty())
     {
-        keyboardFd =
-            open(keyboardPath.c_str(), O_RDWR | O_CLOEXEC | O_NONBLOCK);
+        keyboardFd = open(keyboardPath.c_str(),
+                          O_RDWR | O_CLOEXEC | O_NONBLOCK);
         if (keyboardFd < 0)
         {
             log<level::ERR>("Failed to open input device",
@@ -221,25 +214,8 @@ void Input::pointerEvent(int buttonMask, int x, int y, rfbClientPtr cl)
         return;
     }
 
-    if (buttonMask > 4)
-    {
-        input->pointerReport[0] = 0;
-        if (buttonMask == 8)
-        {
-            input->pointerReport[5] = 1;
-        }
-        else if (buttonMask == 16)
-        {
-            input->pointerReport[5] = 0xff;
-        }
-    }
-    else
-    {
-        input->pointerReport[0] = ((buttonMask & 0x4) >> 1) |
-                                  ((buttonMask & 0x2) << 1) |
-                                  (buttonMask & 0x1);
-        input->pointerReport[5] = 0;
-    }
+    input->pointerReport[0] = ((buttonMask & 0x4) >> 1) |
+                              ((buttonMask & 0x2) << 1) | (buttonMask & 0x1);
 
     if (x >= 0 && (unsigned int)x < video.getWidth())
     {
@@ -511,7 +487,7 @@ uint8_t Input::keyToScancode(rfbKeySym key)
     return scancode;
 }
 
-bool Input::writeKeyboard(const uint8_t* report)
+bool Input::writeKeyboard(const uint8_t *report)
 {
     std::unique_lock<std::mutex> lk(keyMutex);
     uint retryCount = HID_REPORT_RETRY_MAX;
@@ -543,7 +519,7 @@ bool Input::writeKeyboard(const uint8_t* report)
     return false;
 }
 
-void Input::writePointer(const uint8_t* report)
+void Input::writePointer(const uint8_t *report)
 {
     std::unique_lock<std::mutex> lk(ptrMutex);
     uint retryCount = HID_REPORT_RETRY_MAX;
diff --git a/ikvm_input.hpp b/ikvm_input.hpp
index 83e4071..558251d 100644
--- a/ikvm_input.hpp
+++ b/ikvm_input.hpp
@@ -24,10 +24,8 @@ class Input
      *
      * @param[in] kbdPath - Path to the USB keyboard device
      * @param[in] ptrPath - Path to the USB mouse device
-     * @param[in] udc - Name of UDC
      */
-    Input(const std::string& kbdPath, const std::string& ptrPath,
-          const std::string& udc);
+    Input(const std::string& kbdPath, const std::string& ptrPath);
     ~Input();
     Input(const Input&) = default;
     Input& operator=(const Input&) = default;
@@ -63,7 +61,7 @@ class Input
   private:
     static constexpr int NUM_MODIFIER_BITS = 4;
     static constexpr int KEY_REPORT_LENGTH = 8;
-    static constexpr int PTR_REPORT_LENGTH = 6;
+    static constexpr int PTR_REPORT_LENGTH = 5;
 
     /* @brief HID modifier bits mapped to shift and control key codes */
     static constexpr uint8_t shiftCtrlMap[NUM_MODIFIER_BITS] = {
@@ -100,8 +98,8 @@ class Input
      */
     static uint8_t keyToScancode(rfbKeySym key);
 
-    bool writeKeyboard(const uint8_t* report);
-    void writePointer(const uint8_t* report);
+    bool writeKeyboard(const uint8_t *report);
+    void writePointer(const uint8_t *report);
 
     /* @brief File descriptor for the USB keyboard device */
     int keyboardFd;
@@ -115,8 +113,6 @@ class Input
     std::string keyboardPath;
     /* @brief Path to the USB mouse device */
     std::string pointerPath;
-    /* @brief Name of UDC */
-    std::string udcName;
     /*
      * @brief Mapping of RFB key code to report data index to keep track
      *        of which keys are down
diff --git a/ikvm_manager.cpp b/ikvm_manager.cpp
index 93fd1ce..6fcd203 100644
--- a/ikvm_manager.cpp
+++ b/ikvm_manager.cpp
@@ -7,11 +7,11 @@ namespace ikvm
 
 Manager::Manager(const Args& args) :
     continueExecuting(true), serverDone(false), videoDone(true),
-    input(args.getKeyboardPath(), args.getPointerPath(), args.getUdcName()),
-    video(args.getVideoPath(), input, args.getFrameRate(),
-          args.getSubsampling()),
+    input(args.getKeyboardPath(), args.getPointerPath()),
+    video(args.getVideoPath(), input, args.getFrameRate(), args.getSubsampling(), args.getFormat()),
     server(args, input, video)
-{}
+{
+}
 
 void Manager::run()
 {
diff --git a/ikvm_server.cpp b/ikvm_server.cpp
index 141f6c6..141afc4 100644
--- a/ikvm_server.cpp
+++ b/ikvm_server.cpp
@@ -2,12 +2,16 @@
 
 #include <rfb/rfbproto.h>
 
-#include <boost/crc.hpp>
 #include <phosphor-logging/elog-errors.hpp>
 #include <phosphor-logging/elog.hpp>
 #include <phosphor-logging/log.hpp>
 #include <xyz/openbmc_project/Common/error.hpp>
 
+#include <boost/crc.hpp>
+
+#define 	rfbEncodingAspeed   18
+#define ROUND_DOWN(x,r) ((x) & ~((r) - 1))
+
 namespace ikvm
 {
 
@@ -94,9 +98,10 @@ void Server::run()
 void Server::sendFrame()
 {
     char* data = video.getData();
+    uint32_t frameCount = 0;
     rfbClientIteratorPtr it;
     rfbClientPtr cl;
-    int64_t frame_crc = -1;
+    bool frame_sent = false;
 
     if (!data || pendingResize)
     {
@@ -109,6 +114,7 @@ void Server::sendFrame()
     {
         ClientData* cd = (ClientData*)cl->clientData;
         rfbFramebufferUpdateMsg* fu = (rfbFramebufferUpdateMsg*)cl->updateBuf;
+        auto i = video.buffersDone.front();
 
         if (!cd)
         {
@@ -126,26 +132,8 @@ void Server::sendFrame()
             continue;
         }
 
-        if (calcFrameCRC)
-        {
-            if (frame_crc == -1)
-            {
-                /* JFIF header contains some varying data so skip it for
-                 * checksum calculation */
-                frame_crc =
-                    boost::crc<32, 0x04C11DB7, 0xFFFFFFFF, 0xFFFFFFFF, true,
-                               true>(data + 0x30, video.getFrameSize() - 0x30);
-            }
-
-            if (cd->last_crc == frame_crc)
-            {
-                continue;
-            }
-
-            cd->last_crc = frame_crc;
-        }
-
         cd->needUpdate = false;
+        frame_sent = true;
 
         if (cl->enableLastRectEncoding)
         {
@@ -160,11 +148,34 @@ void Server::sendFrame()
         cl->ublen = sz_rfbFramebufferUpdateMsg;
         rfbSendUpdateBuf(cl);
 
-        cl->tightEncoding = rfbEncodingTight;
-        rfbSendTightHeader(cl, 0, 0, video.getWidth(), video.getHeight());
+        if (video.getFormat() == 1)
+        {
+            cl->tightEncoding = rfbEncodingAspeed;
+            rfbSendTightHeader(cl, 0, 0, video.getWidth(), video.getHeight());
+
+            frameCount = video.getFrameCount(i);
+            cl->updateBuf[cl->ublen++] = (char)(0);
+            cl->updateBuf[cl->ublen++] = (char)(frameCount >> 24 & 0xff);
+            cl->updateBuf[cl->ublen++] = (char)(frameCount >> 16 & 0xff);
+            cl->updateBuf[cl->ublen++] = (char)(frameCount >> 8 & 0xff);
+            cl->updateBuf[cl->ublen++] = (char)(frameCount & 0xff);
+            cl->updateBuf[cl->ublen++] = (char)(video.getSubsampling());
+            cl->updateBuf[cl->ublen++] = (char)(0x00);	// the value of quality if changed
+        }
+        else
+        {
+            cl->tightEncoding = rfbEncodingTight;
+            if (video.getFormat() == 2) {
+                v4l2_rect r = video.getBoundingBox(i);
 
-        cl->updateBuf[cl->ublen++] = (char)(rfbTightJpeg << 4);
-        rfbSendCompressedDataTight(cl, data, video.getFrameSize());
+                rfbSendTightHeader(cl, r.left, r.top, r.width, r.height);
+            } else {
+                rfbSendTightHeader(cl, 0, 0, video.getWidth(), video.getHeight());
+            }
+
+            cl->updateBuf[cl->ublen++] = (char)(rfbTightJpeg << 4);
+        }
+        rfbSendCompressedDataTight(cl, data, video.getFrameSize(i));
 
         if (cl->enableLastRectEncoding)
         {
@@ -175,12 +186,15 @@ void Server::sendFrame()
     }
 
     rfbReleaseClientIterator(it);
+
+    if (frame_sent)
+        video.releaseFrames();
 }
 
 void Server::clientFramebufferUpdateRequest(
-    rfbClientPtr cl, rfbFramebufferUpdateRequestMsg* furMsg)
+    rfbClientPtr cl, rfbFramebufferUpdateRequestMsg *furMsg)
 {
-    ClientData* cd = (ClientData*)cl->clientData;
+    ClientData *cd = (ClientData *)cl->clientData;
 
     if (!cd)
         return;
@@ -211,7 +225,7 @@ enum rfbNewClientAction Server::newClient(rfbClientPtr cl)
     Server* server = (Server*)cl->screen->screenData;
 
     cl->clientData =
-        new ClientData(server->video.getFrameRate(), &server->input);
+        new ClientData(ROUND_DOWN(server->video.getFrameRate(), 8), &server->input);
     cl->clientGoneHook = clientGone;
     cl->clientFramebufferUpdateRequestHook = clientFramebufferUpdateRequest;
     if (!server->numClients++)
@@ -248,8 +262,9 @@ void Server::doResize()
             continue;
         }
 
+        // let skipFrame round-down per interval of aspeed's I frame
         // delay video updates to give the client time to resize
-        cd->skipFrame = video.getFrameRate();
+        cd->skipFrame = ROUND_DOWN(video.getFrameRate(), 8);
     }
 
     rfbReleaseClientIterator(it);
diff --git a/ikvm_server.hpp b/ikvm_server.hpp
index dcb984a..bfeb73b 100644
--- a/ikvm_server.hpp
+++ b/ikvm_server.hpp
@@ -94,8 +94,8 @@ class Server
      * @param[in] furMsg - Pointer of the FUR message
      */
     static void
-        clientFramebufferUpdateRequest(rfbClientPtr cl,
-                                       rfbFramebufferUpdateRequestMsg* furMsg);
+    clientFramebufferUpdateRequest(rfbClientPtr cl,
+                                   rfbFramebufferUpdateRequestMsg *furMsg);
     /*
      * @brief Handler for a client disconnecting
      *
diff --git a/ikvm_video.cpp b/ikvm_video.cpp
index 734294e..91d1da7 100644
--- a/ikvm_video.cpp
+++ b/ikvm_video.cpp
@@ -19,6 +19,9 @@
 #include <xyz/openbmc_project/Common/Device/error.hpp>
 #include <xyz/openbmc_project/Common/File/error.hpp>
 
+#define V4L2_PIX_FMT_AJPG     v4l2_fourcc('A', 'J', 'P', 'G')
+#define V4L2_PIX_FMT_FLAG_PARTIAL_JPG   0x00000004
+
 namespace ikvm
 {
 
@@ -30,11 +33,12 @@ using namespace phosphor::logging;
 using namespace sdbusplus::xyz::openbmc_project::Common::File::Error;
 using namespace sdbusplus::xyz::openbmc_project::Common::Device::Error;
 
-Video::Video(const std::string& p, Input& input, int fr, int sub) :
+Video::Video(const std::string& p, Input& input, int fr, int sub, int fmt) :
     resizeAfterOpen(false), timingsError(false), fd(-1), frameRate(fr),
-    lastFrameIndex(-1), height(600), width(800), subSampling(sub), input(input),
-    path(p)
-{}
+    height(600), width(800), subSampling(sub),
+	format(fmt), input(input), path(p)
+{
+}
 
 Video::~Video()
 {
@@ -43,12 +47,21 @@ Video::~Video()
 
 char* Video::getData()
 {
-    if (lastFrameIndex >= 0)
+    if (buffersDone.empty())
     {
-        return (char*)buffers[lastFrameIndex].data;
+        return nullptr;
     }
 
-    return nullptr;
+    return (char*)buffers[buffersDone.front()].data;
+}
+
+char* Video::getData(unsigned int i)
+{
+    if (i >= buffers.size())
+    {
+        return nullptr;
+    }
+    return (char*)buffers[i].data;
 }
 
 void Video::getFrame()
@@ -58,12 +71,19 @@ void Video::getFrame()
     v4l2_buffer buf;
     fd_set fds;
     timeval tv;
+    v4l2_selection comp = {.type = V4L2_BUF_TYPE_VIDEO_CAPTURE, .target = V4L2_SEL_TGT_CROP_DEFAULT};
 
     if (fd < 0)
     {
         return;
     }
 
+    // Don't get more new frames until we run out of previous ones
+    if (!buffersDone.empty())
+    {
+        return;
+    }
+
     FD_ZERO(&fds);
     FD_SET(fd, &fds);
 
@@ -92,48 +112,71 @@ void Video::getFrame()
 
                 if (!(buf.flags & V4L2_BUF_FLAG_ERROR))
                 {
-                    lastFrameIndex = buf.index;
-                    buffers[lastFrameIndex].payload = buf.bytesused;
-                    break;
+                    buffers[buf.index].payload = buf.bytesused;
+                    buffers[buf.index].sequence = buf.sequence;
+                    if (format == 2) {
+                        rc = ioctl(fd, VIDIOC_G_SELECTION, &comp);
+                        if (rc) {
+                            log<level::ERR>("Failed to get selection box",
+                                            entry("ERROR=%s", strerror(errno)));
+                            comp.r.left = 0;
+                            comp.r.top = 0;
+                            comp.r.width = width;
+                            comp.r.height = height;
+                        }
+                        buffers[buf.index].box = comp.r;
+                    }
+                    buffersDone.push_back(buf.index);
                 }
                 else
                 {
                     buffers[buf.index].payload = 0;
+                    qbuf(buf.index);
                 }
             }
         } while (rc >= 0);
     }
 
     fcntl(fd, F_SETFL, fd_flags);
+}
 
-    for (unsigned int i = 0; i < buffers.size(); ++i)
+void Video::qbuf(int i)
+{
+    int rc;
+    v4l2_buffer buf;
+
+    if (!buffers[i].queued)
     {
-        if (i == (unsigned int)lastFrameIndex)
+        memset(&buf, 0, sizeof(v4l2_buffer));
+        buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        buf.memory = V4L2_MEMORY_MMAP;
+        buf.index = i;
+
+        rc = ioctl(fd, VIDIOC_QBUF, &buf);
+        if (rc)
         {
-            continue;
+            log<level::ERR>("Failed to queue buffer",
+                            entry("ERROR=%s", strerror(errno)));
         }
-
-        if (!buffers[i].queued)
+        else
         {
-            memset(&buf, 0, sizeof(v4l2_buffer));
-            buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-            buf.memory = V4L2_MEMORY_MMAP;
-            buf.index = i;
-
-            rc = ioctl(fd, VIDIOC_QBUF, &buf);
-            if (rc)
-            {
-                log<level::ERR>("Failed to queue buffer",
-                                entry("ERROR=%s", strerror(errno)));
-            }
-            else
-            {
-                buffers[i].queued = true;
-            }
+            buffers[i].queued = true;
         }
     }
 }
 
+void Video::releaseFrames()
+{
+    int i;
+
+    if (!buffersDone.empty())
+    {
+        i = buffersDone.front();
+        buffersDone.pop_front();
+        qbuf(i);
+    }
+}
+
 bool Video::needsResize()
 {
     int rc;
@@ -183,7 +226,7 @@ bool Video::needsResize()
                 xyz::openbmc_project::Common::File::Open::PATH(path.c_str()));
         }
 
-        lastFrameIndex = -1;
+        buffersDone.clear();
         return true;
     }
 
@@ -434,6 +477,29 @@ void Video::start()
                 CALLOUT_DEVICE_PATH(path.c_str()));
     }
 
+    switch (format) {
+        case 2:
+            fmt.fmt.pix.flags = V4L2_PIX_FMT_FLAG_PARTIAL_JPG;
+        default:
+        case 0:
+            fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_JPEG;
+            break;
+        case 1:
+            fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_AJPG;
+            break;
+    }
+    rc = ioctl(fd, VIDIOC_S_FMT, &fmt);
+    if (rc < 0)
+    {
+        log<level::ERR>("Failed to set video device format",
+                        entry("ERROR=%s", strerror(errno)));
+        elog<ReadFailure>(
+            xyz::openbmc_project::Common::Device::ReadFailure::CALLOUT_ERRNO(
+                errno),
+            xyz::openbmc_project::Common::Device::ReadFailure::
+                CALLOUT_DEVICE_PATH(path.c_str()));
+    }
+
     memset(&sparm, 0, sizeof(v4l2_streamparm));
     sparm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
     sparm.parm.capture.timeperframe.numerator = 1;
@@ -446,8 +512,8 @@ void Video::start()
     }
 
     ctrl.id = V4L2_CID_JPEG_CHROMA_SUBSAMPLING;
-    ctrl.value = subSampling ? V4L2_JPEG_CHROMA_SUBSAMPLING_420
-                             : V4L2_JPEG_CHROMA_SUBSAMPLING_444;
+    ctrl.value = subSampling
+	       ? V4L2_JPEG_CHROMA_SUBSAMPLING_420 : V4L2_JPEG_CHROMA_SUBSAMPLING_444;
     rc = ioctl(fd, VIDIOC_S_CTRL, &ctrl);
     if (rc < 0)
     {
@@ -477,7 +543,7 @@ void Video::stop()
         return;
     }
 
-    lastFrameIndex = -1;
+    buffersDone.clear();
 
     rc = ioctl(fd, VIDIOC_STREAMOFF, &type);
     if (rc)
diff --git a/ikvm_video.hpp b/ikvm_video.hpp
index 17477df..ccfb089 100644
--- a/ikvm_video.hpp
+++ b/ikvm_video.hpp
@@ -5,6 +5,8 @@
 #include <mutex>
 #include <string>
 #include <vector>
+#include <deque>
+ #include <linux/videodev2.h>
 
 namespace ikvm
 {
@@ -23,7 +25,7 @@ class Video
      * @param[in] input - Reference to the Input object
      * @param[in] fr    - desired frame rate of the video
      */
-    Video(const std::string& p, Input& input, int fr = 30, int sub = 0);
+    Video(const std::string& p, Input& input, int fr = 30, int sub = 0, int fmt = 0);
     ~Video();
     Video(const Video&) = default;
     Video& operator=(const Video&) = default;
@@ -36,8 +38,11 @@ class Video
      * @return Pointer to the video frame data
      */
     char* getData();
+    char* getData(unsigned int i);
     /* @brief Performs read to grab latest video frame */
     void getFrame();
+    /* @brief Performs return done video frames back to driver */
+    void releaseFrames();
     /*
      * @brief Gets whether or not the video frame needs to be resized
      *
@@ -73,7 +78,28 @@ class Video
      */
     inline size_t getFrameSize() const
     {
-        return buffers[lastFrameIndex].payload;
+        if (buffersDone.empty())
+            return 0;
+        return buffers[buffersDone.front()].payload;
+    }
+    inline size_t getFrameSize(unsigned int i) const
+    {
+        return buffers[i].payload;
+    }
+    /*
+     * @brief Gets the video frame count in sequence
+     *
+     * @return Value of video frame count in sequence
+     */
+    inline size_t getFrameCount() const
+    {
+        if (buffersDone.empty())
+            return 0;
+        return buffers[buffersDone.front()].sequence;
+    }
+    inline size_t getFrameCount(unsigned int i) const
+    {
+        return buffers[i].sequence;
     }
     /*
      * @brief Gets the height of the video frame
@@ -111,6 +137,36 @@ class Video
     {
         subSampling = _sub;
     }
+    /*
+     * @brief Gets the jpeg format of the video frame
+     *
+     * @return Value of the jpeg format of video frame
+     *         0:standard jpeg, 1:aspeed(N/A) , 2:Partial jpeg
+     */
+    inline int getFormat() const
+    {
+        return format;
+    }
+    /*
+     * @brief Sets the jpeg format of the video frame
+     *
+     * @return Value of the jpeg format of video frame
+     *         0:standard jpeg, 1:aspeed(N/A) , 2:Partial jpeg
+     */
+    inline void setFormat(int _fmt)
+    {
+        format = _fmt;
+    }
+
+    /*
+     * @brief Gets the bounding-box of the partial-jpeg
+     *
+     * @return Bounding-box of the video frame
+     */
+    inline v4l2_rect getBoundingBox(unsigned int i) const
+    {
+        return buffers[i].box;
+    }
 
     /* @brief Number of bits per component of a pixel */
     static const int bitsPerSample;
@@ -118,8 +174,12 @@ class Video
     static const int bytesPerPixel;
     /* @brief Number of components in a pixel (i.e. 3 for RGB pixel) */
     static const int samplesPerPixel;
+    /* @brief done buffer storage */
+    std::deque<int> buffersDone;
 
   private:
+    void qbuf(int i);
+
     /*
      * @struct Buffer
      * @brief Store the address and size of frame data from streaming
@@ -128,7 +188,8 @@ class Video
     struct Buffer
     {
         Buffer() : data(nullptr), queued(false), payload(0), size(0)
-        {}
+        {
+        }
         ~Buffer() = default;
         Buffer(const Buffer&) = default;
         Buffer& operator=(const Buffer&) = default;
@@ -139,6 +200,8 @@ class Video
         bool queued;
         size_t payload;
         size_t size;
+        uint32_t sequence;
+        v4l2_rect box;
     };
 
     /*
@@ -152,14 +215,14 @@ class Video
     int fd;
     /* @brief Desired frame rate of video stream in frames per second */
     int frameRate;
-    /* @brief Buffer index for the last video frame */
-    int lastFrameIndex;
     /* @brief Height in pixels of the video frame */
     size_t height;
     /* @brief Width in pixels of the video frame */
     size_t width;
     /* @brief jpeg's subsampling, 1:420/0:444 */
     int subSampling;
+    /* @brief jpeg format */
+    int format;
     /* @brief Reference to the Input object */
     Input& input;
     /* @brief Path to the V4L2 video device */
-- 
2.25.1

