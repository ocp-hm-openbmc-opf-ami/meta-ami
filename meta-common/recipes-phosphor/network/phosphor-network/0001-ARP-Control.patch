--- /dev/null
+++ b/meson.build	2022-10-20 15:34:59.634932388 +0530
@@ -82,6 +82,18 @@
     pkgconfig: 'systemdsystemunitdir'))
 
 configure_file(
+  input: 'xyz.openbmc_project.GARPControl.service.in',
+  output: 'xyz.openbmc_project.GARPControl.service',
+  configuration: {
+    'SYSTEMD_TARGET': 'multi-user.target',
+    'DEFAULT_BUSNAME': default_busname,
+  },
+  install: true,
+  install_dir: dependency('systemd').get_variable(
+    pkgconfig: 'systemdsystemunitdir'))
+
+
+configure_file(
   input: 'xyz.openbmc_project.Network.conf.in',
   output: 'xyz.openbmc_project.Network.conf',
   configuration: {'DEFAULT_BUSNAME': default_busname},
--- a/src/ethernet_interface.cpp       2022-11-06 05:11:03.729422103 -0500
+++ b/src/ethernet_interface.cpp      2022-11-06 05:29:18.871513855 -0500
@@ -2,7 +2,6 @@

 #include "ethernet_interface.hpp"

-#include "config_parser.hpp"
 #include "ipaddress.hpp"
 #include "neighbor.hpp"
 #include "network_manager.hpp"
@@ -38,6 +37,7 @@
 namespace network
 {

+using namespace std::string_literals;
 using namespace phosphor::logging;
 using namespace sdbusplus::xyz::openbmc_project::Common::Error;
 using NotAllowed = sdbusplus::xyz::openbmc_project::Common::Error::NotAllowed;
@@ -49,6 +49,12 @@
 constexpr auto RESOLVED_SERVICE_PATH = "/org/freedesktop/resolve1/link/";
 constexpr auto METHOD_GET = "Get";

+constexpr auto garpControlService = "xyz.openbmc_project.GARPControl.service";
+constexpr auto sysctlConfigPrefix ="/proc/sys/net/ipv4/conf/";
+constexpr auto sysctlConfigSurffix = "/arp_ignore";
+std::string arpResponseDisable = "echo 8 >";
+std::string arpResponseEnable = "echo 0 >";
+
 static constexpr const char* networkChannelCfgFile =
     "/var/channel_intf_data.json";
 static constexpr const char* defaultChannelPriv = "priv-admin";
@@ -123,7 +129,7 @@
     EthernetInterfaceIntf::speed(std::get<0>(ifInfo));
 #endif
     getChannelPrivilege(intfName);
-
+    this->loadARPControl();
     // Emit deferred signal.
     if (emitSignal)
     {
@@ -1326,5 +1332,146 @@
     return ChannelAccessIntf::maxPrivilege(std::move(priv));
 }

+
+/** @brief load the ARP Control Configurations.
+ */
+void EthernetInterface::loadARPControl()
+{
+    fs::path confPath = manager.getARPConfDir();
+    std::string fileName = phosphor::network::arpPrefix +
+                           interfaceName() + phosphor::network::arpSurffix;
+    confPath /= fileName;
+    config::Parser parser(confPath.string());
+
+    auto garpEnable = getArpGarpEnabled(parser, "GARP");
+    auto arpEnable = getArpGarpEnabled(parser, "ARP_Response");
+    auto garpInt = getGarpInterval(parser);
+    ARPControlIface::arpResponse(arpEnable);
+    ARPControlIface::gratuitousARP(garpEnable);
+    ARPControlIface::gratuitousARPInterval(strtoul(garpInt.c_str(), nullptr,10));
+
+    auto cmd = ((!arpEnable)?arpResponseDisable:arpResponseEnable) + sysctlConfigPrefix +
+                    interfaceName() + sysctlConfigSurffix;
+
+    this->sysctlConfig(cmd);
+}
+
+/** @brief set the Enable/Disable of ARP Response.
+ *  @param[in] value - Enable/Disable.
+ *  @return the status of ARP Response
+ */
+bool EthernetInterface::arpResponse(bool value)
+{
+    auto val = ARPControlIface::arpResponse();
+    if (val == value)
+    {
+        return val;
+    }
+
+    val = ARPControlIface::arpResponse(value);
+    writeConfiguration();
+    auto cmd = ((!val)?arpResponseDisable:arpResponseEnable) + sysctlConfigPrefix +
+                    interfaceName() + sysctlConfigSurffix;
+
+    this->sysctlConfig(cmd);
+
+    return val;
+}
+
+/** @brief set the Enable/Disable of GratuitousARP.
+ *  @param[in] value - Enable/Disable.
+ *  @return the status of GratuitousARP Broadcasting
+ */
+bool EthernetInterface::gratuitousARP(bool value)
+{
+    auto val = ARPControlIface::gratuitousARP();
+    if (val == value)
+    {
+        return val;
+    }
+
+    val = ARPControlIface::gratuitousARP(value);
+    writeConfiguration();
+    manager.reloadConfigs();
+
+    return val;
+}
+
+/** @brief set the gratuitousARP interval.
+ *  @param[in] interval - interval in milliseconds.
+ */
+uint64_t EthernetInterface::gratuitousARPInterval(uint64_t interval)
+{
+    auto garpInterval = ARPControlIface::gratuitousARPInterval();
+    if (garpInterval == interval)
+    {
+        return garpInterval;
+    }
+
+    garpInterval = ARPControlIface::gratuitousARPInterval(interval);
+    writeConfiguration();
+    manager.reloadConfigs();
+
+    return garpInterval;
+}
+
+/** @brief write the ARPControl configuration into the conf file.
+ */
+void EthernetInterface::writeConfiguration()
+{
+    /* write all the ARPControl configuration in the garp conf file */
+    fs::path confPath = manager.getARPConfDir();
+    std::string fileName = phosphor::network::arpPrefix +
+                           interfaceName() + phosphor::network::arpSurffix;
+    confPath /= fileName;
+    std::fstream stream;
+
+    stream.open(confPath.c_str(), std::fstream::out);
+    if (!stream.is_open())
+    {
+        log<level::ERR>("Unable to open the file", entry("FILE=%s", confPath.c_str()));
+                elog<InternalFailure>();
+    }
+
+    config::Parser config;
+    std::string garpIntv;
+    garpIntv = std::to_string(ARPControlIface::gratuitousARPInterval());
+
+    auto& Garp = config.map["GARP"].emplace_back();
+    Garp["Interval"].emplace_back(garpIntv);
+    Garp["Enabled"].emplace_back((ARPControlIface::gratuitousARP())?"true":"false");
+
+    auto& ARPResp = config.map["ARP_Response"].emplace_back();
+    ARPResp["Enabled"].emplace_back((ARPControlIface::arpResponse())?"true":"false");
+    config.writeFile(confPath.string());
+
+
+}
+
+/** @brief set the ARP Response status in sysctl config for the ethernet interface.
+ *  @param[in] cmd - shell command.
+ *  @return status of the shell command execution
+ */
+bool EthernetInterface::sysctlConfig(const std::string& cmd)
+{
+    auto pPipe = ::popen(cmd.c_str(), "r");
+    if (pPipe == nullptr)
+    {
+        return false;
+    }
+
+    std::array<char, 256> buffer;
+    std::string outConfig = "";
+    while (not std::feof(pPipe))
+    {
+        auto bytes = std::fread(buffer.data(), 1, buffer.size(), pPipe);
+        outConfig.append(buffer.data(), bytes);
+    }
+    ::pclose(pPipe);
+
+    return ((outConfig.empty())?1:0);
+}
+
+
 } // namespace network
 } // namespace phosphor
 
--- a/src/ethernet_interface.hpp       2022-11-06 05:11:04.853482074 -0500
+++ b/src/ethernet_interface.hpp      2022-11-06 05:29:55.653428887 -0500
@@ -1,8 +1,11 @@
 #pragma once
 #include "types.hpp"
+#include "util.hpp"
+#include "config_parser.hpp"
 #include "xyz/openbmc_project/Channel/ChannelAccess/server.hpp"
 #include "xyz/openbmc_project/Network/IP/Create/server.hpp"
 #include "xyz/openbmc_project/Network/Neighbor/CreateStatic/server.hpp"
+#include <xyz/openbmc_project/Network/ARPControl/server.hpp>

 #include <map>
 #include <nlohmann/json.hpp>
@@ -21,6 +24,7 @@
 {

 using Ifaces = sdbusplus::server::object_t<
+    sdbusplus::xyz::openbmc_project::Network::server::ARPControl,
     sdbusplus::xyz::openbmc_project::Network::server::EthernetInterface,
     sdbusplus::xyz::openbmc_project::Network::server::MACAddress,
     sdbusplus::xyz::openbmc_project::Network::IP::server::Create,
@@ -36,6 +40,8 @@
     sdbusplus::xyz::openbmc_project::Network::server::MACAddress;
 using ChannelAccessIntf =
     sdbusplus::xyz::openbmc_project::Channel::server::ChannelAccess;
+using ARPControlIface =
+    sdbusplus::xyz::openbmc_project::Network::server::ARPControl;

 using ServerList = std::vector<std::string>;
 using ObjectPath = sdbusplus::message::object_path;
@@ -238,6 +244,23 @@
      *  @param[in] gateway - default v6 gateway of the interface.
      */
     std::string defaultGateway6(std::string gateway) override;
+
+    /** @brief set the Enable/Disable of ARP Response in sysctl config.
+     *  @param[in] value - Enable/Disable
+     *  @return the status of ARP Response in sysctl config
+     */
+    bool arpResponse(bool value) override;
+
+    /** @brief set the Enable/Disable of GratuitousARP.
+     *  @param[in] value - Enable/Disable
+     *  @return the status of GratuitousARP Broadcasting
+     */
+    bool gratuitousARP(bool value) override;
+
+    /** @brief set the GratuitousARP interval.
+     *  @param[in] interval - interval in milliseconds.
+     */
+    uint64_t gratuitousARPInterval(uint64_t interval) override;

     /** @brief sets the channel maxium privilege.
      *  @param[in] value - Channel privilege which needs to be set on the
@@ -252,6 +275,9 @@
     using EthernetInterfaceIntf::mtu;
     using EthernetInterfaceIntf::nicEnabled;
     using MacAddressIntf::macAddress;
+    using ARPControlIface::arpResponse;
+    using ARPControlIface::gratuitousARP;
+    using ARPControlIface::gratuitousARPInterval;

     using EthernetInterfaceIntf::defaultGateway;
     using EthernetInterfaceIntf::defaultGateway6;
@@ -388,6 +414,20 @@
      */
     int writeJsonFile(const std::string& configFile,
                       const nlohmann::json& jsonData);
+     /** @brief load the ARP Control Configurations.
+     */
+    void loadARPControl();
+
+    /** @brief write the ARP Control configuration into the conf file.
+     */
+    void writeConfiguration();
+
+    /** @brief set the ARP Response status in sysctl config for the ethernet interface.
+     *  @param[in] cmd - shell command.
+     *  @return status of the shell command execution
+     */
+    bool sysctlConfig(const std::string& cmd);
+
 };

 } // namespace network
--- a/src/meson.build  2022-11-06 05:11:05.677526038 -0500
+++ b/src/meson.build 2022-11-06 05:18:19.876633201 -0500
@@ -80,6 +80,21 @@
   include_directories: src_includes,
   dependencies: networkd_deps)

+executable(
+  'phosphor-garpcontrol',
+  'garp_control_main.cpp',
+  'util.cpp',
+  'config_parser.cpp',
+  'garp_control.cpp',
+  implicit_include_directories: false,
+  include_directories: src_includes,
+  dependencies: [
+    networkd_deps,
+    dependency('stdplus'),
+  ],
+  install: true,
+  install_dir: get_option('bindir'))
+
 networkd_dep = declare_dependency(
   sources: conf_header,
   dependencies: networkd_deps,
--- a/src/network_config.cpp  2022-11-05 15:43:28.935122065 +0530
+++ b/src/network_config.cpp      2022-11-05 15:46:07.865694341 +0530
@@ -45,6 +45,18 @@
         "true");
     config.writeFile(filename);
 }
+
+void writeARPControlDefault(const std::string& filename)
+{
+    config::Parser config;
+    auto& Garp = config.map["GARP"].emplace_back();
+    Garp["Interval"].emplace_back("2000");
+    Garp["Enabled"].emplace_back("false");
+    auto& ARPResp = config.map["ARP_Response"].emplace_back();
+    ARPResp["Enabled"].emplace_back("true");
+    config.writeFile(filename);
+}
+
 } // namespace bmc

 } // namespace network
--- /dev/null
+++ b/src/network_config.hpp	2022-10-20 15:34:59.642932492 +0530
@@ -10,6 +10,7 @@
 {
 void writeDHCPDefault(const std::filesystem::path& filename,
                       std::string_view interface);
+void writeARPControlDefault(const std::string& filename);
 }
 
 } // namespace network
--- /dev/null
+++ b/src/network_manager.cpp	2022-10-20 15:34:59.642932492 +0530
@@ -25,6 +25,7 @@
 constexpr char SYSTEMD_PATH[] = "/org/freedesktop/systemd1";
 constexpr char SYSTEMD_INTERFACE[] = "org.freedesktop.systemd1.Manager";
 constexpr auto FirstBootFile = "/var/lib/network/firstBoot_";
+constexpr char ARPCONTROL_CONF_DIR[] = "/etc/arpcontrol";
 
 constexpr char NETWORKD_BUSNAME[] = "org.freedesktop.network1";
 constexpr char NETWORKD_PATH[] = "/org/freedesktop/network1";
@@ -188,6 +189,63 @@
 
     return isCreated;
 }
+bool Manager::createDefaultARPControlFiles(bool force)
+{
+    auto isCreated = false;
+    try
+    {
+        // Directory would have created before with
+        // setConfDir function.
+        if (force)
+        {
+            // Factory Reset case
+            // we need to forcefully write the files
+            // so delete the existing ones.
+            if (fs::is_directory(arpConfDir))
+            {
+                for (const auto& file : fs::directory_iterator(arpConfDir))
+                {
+                    fs::remove(file.path());
+                }
+            }
+        }
+
+        auto interfaceStrList = getInterfaces();
+        for (const auto& interface : interfaceStrList)
+        {
+            // if the interface has '.' in the name, it means that this is a
+            // VLAN - don't create the network file.
+            if (interface.find(".") != std::string::npos)
+            {
+                continue;
+            }
+
+            auto fileName = phosphor::network::arpPrefix +
+                                   interface + phosphor::network::arpSurffix;
+
+            fs::path filePath = arpConfDir;
+            filePath /= fileName;
+
+            // create the interface specific network file
+            // if not exist or we forcefully wants to write
+            // the network file.
+
+            if (force || !fs::is_regular_file(filePath.string()))
+            {
+                bmc::writeARPControlDefault(filePath.string());
+                log<level::INFO>("Created the default ARP Control file.",
+                                 entry("INTERFACE=%s", interface.c_str()));
+                isCreated = true;
+            }
+        }
+    }
+    catch (std::exception& e)
+    {
+        log<level::ERR>("Unable to create the default ARP Control file");
+    }
+    return isCreated;
+}
+
 
 void Manager::setConfDir(const fs::path& dir)
 {
@@ -202,6 +260,20 @@
             elog<InternalFailure>();
         }
     }
+    fs::path arpDir(ARPCONTROL_CONF_DIR);
+    arpConfDir = arpDir;
+
+    if (!fs::exists(arpConfDir))
+    {
+        if (!fs::create_directories(arpConfDir))
+        {
+            log<level::ERR>("Unable to create the arpcontrol conf dir",
+                            entry("DIR=%s", arpConfDir.c_str()));
+            elog<InternalFailure>();
+        }
+    }
+
+
 }
 
 void Manager::createInterfaces()
@@ -298,6 +370,12 @@
     }
     createDefaultNetworkFiles();
     log<level::INFO>("Network Factory Reset queued.");
+    if (!createDefaultARPControlFiles(true))
+    {
+        log<level::ERR>("Network ARP Control Factory Reset failed.");
+        return;
+    }
+
 }
 
 // Need to merge the below function with the code which writes the
--- /dev/null
+++ b/src/network_manager.hpp	2022-10-20 15:34:59.642932492 +0530
@@ -85,6 +85,14 @@
         return confDir;
     }
 
+     /** @brief gets the arp control conf directory.
+     */
+    fs::path getARPConfDir()
+    {
+        return arpConfDir;
+    }
+
+
     /** @brief gets the system conf object.
      *
      */
@@ -106,6 +114,7 @@
      */
     bool createDefaultNetworkFiles();
 
+    bool createDefaultARPControlFiles(bool force);
     /** @brief This function gets the MAC address from the VPD and
      *  sets it on the corresponding ethernet interface during first
      *  Boot, once it sets the MAC from VPD, it creates a file named
@@ -193,6 +202,8 @@
 
     /** @brief Network Configuration directory. */
     fs::path confDir;
+    /** @brief ARP Control Configuration directory. */
+    fs::path arpConfDir;
 
     /** @brief The routing table */
     route::Table routeTable;
--- a/src/network_manager_main.cpp    2022-11-06 05:43:57.893618093 -0500
+++ b/src/network_manager_main.cpp_vs 2022-11-06 06:00:04.400613826 -0500
@@ -297,6 +297,8 @@
         manager->reloadConfigs();
     }

+    phosphor::network::manager->createDefaultARPControlFiles(false);
+
     // RTNETLINK event handler
     rtnetlink::Server svr(eventPtr);

--- /dev/null
+++ b/xyz.openbmc_project.GARPControl.service.in
@@ -0,0 +1,9 @@
+[Unit]
+Description=Phosphor GARP Control
+After=systemd-networkd.service xyz.openbmc_project.Network.service 
+[Service]
+ExecStart=/usr/bin/env phosphor-garpcontrol
+SyslogIdentifier=phosphor-garpcontrol
+
+[Install]
+WantedBy=@SYSTEMD_TARGET@
--- /dev/null
+++ b/src/garp_control.cpp	2022-10-20 16:02:31.966869088 +0530
@@ -0,0 +1,365 @@
+#include "config.h"
+
+#include "garp_control.hpp" 
+#include <chrono>
+#include <thread>
+
+using namespace std;
+using std::this_thread::sleep_for;
+
+namespace network
+{
+    struct ethernetSocket
+    {
+        ethernetSocket(int domain, int type, int protocol)
+        {
+            if ((sock = socket(domain, type, protocol)) < 0)
+            {
+                cout<<"socket creation failed"<<endl;
+            }
+        }
+        ~ethernetSocket()
+        {
+            if (sock >= 0)
+            {
+                close(sock);
+            }
+        }
+
+        int sock{-1};
+    };
+
+    /** @brief retrive the all the interface
+     *  @returns list of interface.
+     */
+    InterfaceList getInterfaces()
+    {
+        InterfaceList interfaces{};
+        struct ifaddrs* ifaddr = nullptr;
+        
+        if (getifaddrs(&ifaddr) == -1)
+        {
+            std::cout<<"Error occurred during the getifaddrs call"<<std::endl;
+        }
+        
+        AddrPtr ifaddrPtr(ifaddr);
+        ifaddr = nullptr;
+        
+        for (ifaddrs* ifa = ifaddrPtr.get(); ifa != nullptr; ifa = ifa->ifa_next)
+        {
+            if (ifa->ifa_flags & IFF_LOOPBACK)
+            {
+                continue;
+            }
+            interfaces.emplace(ifa->ifa_name);
+        }
+
+        return interfaces;
+    }
+
+    /** @brief Converts the given interface name into a interface index
+     *  @param[in] mac - The interface name
+     *  @returns A valid interface index
+     */
+    unsigned ifIndex(const std::string& interfaceName)
+    {
+        unsigned idx = if_nametoindex(interfaceName.c_str());
+        if (idx == 0)
+        {
+            throw std::system_error(errno, std::generic_category(), "if_nametoindex");
+         }
+
+         return idx;
+    }
+
+    namespace ethernetMAC 
+    {
+        /** @brief Converts the given mac address into byte form
+         *  @param[in] str - The mac address in human readable form
+         *  @returns A mac address in network byte order
+         *  @throws std::runtime_error for bad mac
+         */
+        ether_addr fromString(const char* str)
+        {
+            struct ether_addr* mac = ether_aton(str);
+            if (mac == nullptr)
+            {
+                throw std::runtime_error("Invalid mac address string");
+            }
+
+            return *mac;
+        }
+
+        /** @brief Converts the given mac address bytes into a string
+         *  @param[in] mac - The mac address
+         *  @returns A valid mac address string
+         */	
+        std::string toString(const ether_addr& mac)
+        {
+            char buf[18] = {0};
+            snprintf(buf, 18, "%02x:%02x:%02x:%02x:%02x:%02x", mac.ether_addr_octet[0],
+			 mac.ether_addr_octet[1], mac.ether_addr_octet[2], mac.ether_addr_octet[3],
+			 mac.ether_addr_octet[4], mac.ether_addr_octet[5]);
+            return buf;
+        }
+
+        /** @brief get the mac address of the interface.
+         *  @return macaddress on success
+         */
+        std::string getMACaddress(const std::string& interfaceName)
+        {
+            ethernetSocket eifSocket(PF_INET, SOCK_DGRAM, IPPROTO_IP);
+
+            if (eifSocket.sock < 0)
+                return nullptr;
+        
+            ifreq ifr{0};
+            std::strncpy(ifr.ifr_name, interfaceName.c_str(), IFNAMSIZ - 1);
+            if (ioctl(eifSocket.sock, SIOCGIFHWADDR, &ifr) != 0)
+            {
+                cout<<"ioctl failed for SIOCGIFHWADDR"<<endl;
+                return nullptr;
+            }
+
+            static_assert(sizeof(ifr.ifr_hwaddr.sa_data) >= sizeof(ether_addr));
+            std::string_view hwaddr(reinterpret_cast<char*>(ifr.ifr_hwaddr.sa_data),
+                                    sizeof(ifr.ifr_hwaddr.sa_data));
+            return toString(stdplus::raw::copyFrom<ether_addr>(hwaddr));
+        }
+
+    }/*namespace ethernetMAC */
+
+    namespace ethernetIP 
+    {
+        /* @brief converts a String representation of the ip into
+         *  ip bytes.
+         * @param[in] address - The string representation ip address
+         * @returns sockaddr representation of the ip.
+         */
+        IPv4Addrs fromString(const std::string& address)
+        {
+            struct sockaddr_in sa{0};
+            int ret = inet_pton(AF_INET, address.c_str(), &(sa.sin_addr));
+            if (ret != 1)
+            {
+                throw std::runtime_error("Invalid IP address string");
+            }
+
+            return sa.sin_addr;
+        }
+
+        /* @brief converts the ip bytes into a string representation
+         * @param[in] ip - input ip byte address to convert.
+         * @returns String representation of the ip.
+         */	
+        std::string toString(const IPv4Addrs *ip)
+        {
+            char ipaddress [INET_ADDRSTRLEN];
+            auto ret = inet_ntop(AF_INET, ip, ipaddress, INET_ADDRSTRLEN);
+            if (ret == nullptr)
+            {
+                throw std::runtime_error("Invalid IP address string");
+            }
+
+            return ipaddress;
+        }
+
+        /* @brief checks that the given ip address is link local or not.
+         * @param[in] address - IP address.
+         * @returns true if it is linklocal otherwise false.
+         */
+        bool isLinkLocalIP(const std::string& address)
+        {
+            return address.find(IPV4_PREFIX) == 0 || address.find(IPV6_PREFIX) == 0;
+        }
+
+        /** @brief Gets the map of interface and the associated
+         *         address.
+         *  @returns map of interface and the address.
+         */
+        IntfAddrMap getIPaddrs(std::string& interfaceName)
+        {
+            IntfAddrMap intfMap{};
+            struct ifaddrs* ifaddr = nullptr;
+
+            /* attempt to fill struct with ifaddrs */
+            if (getifaddrs(&ifaddr) == -1)
+            {
+                cout<<"Error occurred during the getifaddrs call"<<endl;
+                return intfMap;
+            }
+
+            AddrPtr ifaddrPtr(ifaddr);
+            ifaddr = nullptr;
+            std::string intfName{};
+
+            for (ifaddrs* ifa = ifaddrPtr.get(); ifa != nullptr; ifa = ifa->ifa_next)
+            {
+                /* walk interfaces */
+                if (ifa->ifa_addr == nullptr)
+                {
+                    continue;
+                }
+
+                /* get only INET interfaces not ipv6 */
+                if (ifa->ifa_addr->sa_family == AF_INET)
+                {
+                    /* if loopback, or not running ignore */
+                    if ((ifa->ifa_flags & IFF_LOOPBACK) ||
+                        !(ifa->ifa_flags & IFF_RUNNING))
+                    {
+                        continue;
+                    }
+                    intfName = ifa->ifa_name;
+
+		    if (intfName == interfaceName)
+		    {
+                        AddrInfo info{};
+                        info.addrType = ifa->ifa_addr->sa_family;
+                        info.ipAddress = ((struct sockaddr_in*)(ifa->ifa_addr))->sin_addr;
+                        intfMap[intfName].push_back(info);
+		    }
+                }
+            }
+
+            return intfMap;
+        }
+    }/*namespace ethernetIP */
+
+    namespace garpControl 
+    {
+        /** @brief Constructor to put object onto bus at a dbus path.
+         *  @param[in] interfaceName - GARP Broadcasting interface name.
+         *  @param[in] interval - GARP interval .
+         */
+        GARP::GARP(const std::string& interfaceName, const int interval)
+        {
+            this->interface = interfaceName;
+            this->replyInterval = interval;
+        }
+
+        /** @brief Broadcast the GARP Packet into the ethernet interface.
+         *  @param[in] start - GARP Broadcast start .
+         */	
+        void GARP::broadcastPacket(bool start)
+        {
+            /* Main Loop*/
+            while(start)
+	    {
+                if (!getIfaceDetails())
+        	    continue;
+
+                auto ipAddrs = this->IPv4Address[interface];
+               
+                for (auto& addr : ipAddrs)
+                {
+                    if (!ethernetIP::isLinkLocalIP(ethernetIP::toString(&addr.ipAddress)))
+                    {
+                        this->ipAddr = addr.ipAddress;
+                        if (!sendPacket())
+        	        {
+        	            cout<<" Unable to Broadcaste GARP in "<<interface<<" IP: "
+				    <<ethernetIP::toString(&addr.ipAddress)<<endl;
+        	        }
+                    }
+                }     	
+                sleep_for(std::chrono::milliseconds(this->replyInterval));
+            }
+        }
+
+        /** @brief create the ethernet socket(raw socket) and write the GARP
+         *         Packet on it.
+         *  @returns true if successful or false.
+         */	
+        bool GARP::sendPacket() {
+            int frameLength, bytes; 
+            uint8_t ethernetHdr[IP_MAXPACKET];  
+            struct sockaddr_ll device;
+            ARPHeader arpHdr{0};
+
+            /*Fill out sockaddr_ll */
+            device.sll_family = AF_PACKET;
+            device.sll_ifindex = ifindex;
+            memset (device.sll_addr, 0x00, MAC_LENGTH * sizeof (uint8_t));
+            memcpy (device.sll_addr, mac.ether_addr_octet, MAC_LENGTH * sizeof (uint8_t));
+            device.sll_halen = htons (MAC_LENGTH);
+
+            GARPHeader(&arpHdr); 
+            frameLength = frameHeader(&arpHdr, ethernetHdr);
+
+            /* raw socket descriptor  */
+            ethernetSocket eifSocket(PF_PACKET, SOCK_RAW, htons (ETH_P_ALL));
+            if (eifSocket.sock < 0)
+        	return false;
+
+            /* Send ethernet frame to socket. */
+            if ((bytes = sendto (eifSocket.sock, ethernetHdr, frameLength, 0, (struct sockaddr *) &device, sizeof (device))) <= 0) {
+                return false;
+            }
+
+            return true;
+        }
+
+        /** @brief reads IP address, interface index and MAC address from ethernet
+         *  @returns true if successful or false.
+         */	
+        bool GARP::getIfaceDetails()
+        {
+	    this->IPv4Address.clear();
+            this->IPv4Address = ethernetIP::getIPaddrs(this->interface);
+            std::string sourceMAC = ethernetMAC::getMACaddress(this->interface);
+
+            if(sourceMAC.empty() || IPv4Address.empty())
+                return false;
+
+            this->mac = ethernetMAC::fromString(sourceMAC); 
+            this->ifindex = ifIndex(this->interface);
+
+            return true;
+        }
+
+        /** @brief create GARP header
+         *  @param[in] arphdr - GARP Header .
+         */	
+        void GARP::GARPHeader(ARPHeader *arpHdr)
+        {
+            /* ARP header*/
+            arpHdr->hardware_type = htons (HWTYPE_ETHER); /* Hardware type (16 bits): 1 for ethernet */
+            arpHdr->protocol_type = htons (ETH_P_IP);     /* Protocol type (16 bits): 2048 for IP */
+            arpHdr->hardware_len = MAC_LENGTH;            /* Hardware address length (8 bits): 6 bytes for MAC address */
+            arpHdr->protocol_len = IPV4_LENGTH;           /* Protocol address length (8 bits): 4 bytes for IPv4 address */
+            arpHdr->opcode = htons (ARP_OP_REPLY);        /* OpCode: 2 for ARP reply */
+            memcpy (&arpHdr->sender_mac, mac.ether_addr_octet, MAC_LENGTH * sizeof (uint8_t)); /* Sender hardware address (48 bits):
+												   MAC address */
+            memset (&arpHdr->target_mac, 0x00, MAC_LENGTH * sizeof (uint8_t));     /* Target hardware address (48 bits): zero */
+            memcpy (&arpHdr->sender_ip, &this->ipAddr, IPV4_LENGTH * sizeof (uint8_t)); /* Sender IP address */
+            memcpy (&arpHdr->target_ip, &this->ipAddr, IPV4_LENGTH * sizeof (uint8_t)); /* Target IP address */
+        }
+
+        /** @brief create the frame header with GARP header
+         *  @param[in] arpHdr - GARP Header .
+         *  @param[in] ethernetHdr - ethernet Frame Header .
+         *  @returns total frame length.
+         */	
+        int GARP::frameHeader(ARPHeader *arpHdr, uint8_t *ethernetHdr)
+        {
+            int frameLength = 0;
+
+            /* Fill out ethernet frame header*/
+            frameLength = MAC_LENGTH + MAC_LENGTH + ETHER_TYPE + ARP_HDRLEN; /* ethernet header (MAC + MAC + ethernet type)
+										 + ethernet data (ARP header) */
+            memset (ethernetHdr, 0xFF, MAC_LENGTH * sizeof (uint8_t));      /* Destination MAC addresses */
+            memcpy (ethernetHdr + MAC_LENGTH, mac.ether_addr_octet, MAC_LENGTH * sizeof (uint8_t));   /* Source MAC addresses */
+
+            /* Next is ethernet type code (ETH_P_ARP for ARP) */
+            ethernetHdr[12] = ETH_P_ARP / 256;
+            ethernetHdr[13] = ETH_P_ARP % 256;
+            /* Next is ethernet frame data (ARP header). */
+            memcpy (ethernetHdr + ETH_HDRLEN, arpHdr, ARP_HDRLEN * sizeof (uint8_t));
+
+            return frameLength;
+        }
+
+    } /* namespace garpControl */
+
+} /* namespace network */
--- /dev/null
+++ b/src/garp_control.hpp	2022-10-20 15:57:42.875305270 +0530
@@ -0,0 +1,220 @@
+#pragma once
+
+#include <sys/types.h>        /* needed for socket(), uint8_t, uint16_t */
+#include <sys/socket.h>       /* needed for socket() */
+#include <netinet/in.h>       /* IPPROTO_RAW */
+#include <netinet/ip.h>       /* IP_MAXPACKET (which is 65535) */
+#include <sys/ioctl.h>        /* macro ioctl is defined */
+#include <bits/ioctls.h>      /* defines values for argument "request" of ioctl. */
+#include <net/if.h>           /* struct ifreq */
+#include <linux/if_ether.h>   /* ETH_P_ARP = 0x0806 */
+#include <linux/if_packet.h>  /* struct sockaddr_ll (see man 7 packet) */
+#include <netinet/ether.h>
+#include <arpa/inet.h>
+#include <ifaddrs.h>
+#include <unistd.h>
+
+#include <stdplus/raw.hpp>
+#include <cstdlib>
+#include <cstring>
+#include <iostream>
+#include <array>
+#include <list>
+#include <map>
+#include <memory>
+#include <string>
+#include <variant>
+#include <vector>
+#include <set>
+
+/* Define some constans */
+#define ETH_HDRLEN 14      /* Ethernet header length */
+#define IP4_HDRLEN 20      /* IPv4 header length */
+#define ARP_HDRLEN 28      /* ARP header length */
+#define ARP_OP_REPLY 2     /* Taken from <linux/if_arp.h> */
+/* General defines */
+#define MAC_LENGTH 6
+#define IPV4_LENGTH 4
+#define HWTYPE_ETHER 1
+#define ETHER_TYPE 2
+
+namespace network /*namespace network */
+{
+    using IntfName = std::string;
+    using IPv4Addrs = struct in_addr;
+    using EthernetHeader = struct ethhdr;
+
+    struct AddrInfo
+    {
+        uint8_t addrType;
+        IPv4Addrs ipAddress;
+    };
+    /* Byte representations for common address types in network byte order */
+    using InAddrAny = std::variant<struct in_addr, struct in6_addr>;
+    using AddrList = std::list<AddrInfo>;
+    using IntfAddrMap = std::map<IntfName, AddrList>;
+    using InterfaceList = std::set<IntfName>;
+    using Addr_t = ifaddrs*;
+
+    struct AddrDeleter
+    {
+        void operator()(Addr_t ptr) const
+        {
+	    freeifaddrs(ptr);
+        }
+    };
+
+    using AddrPtr = std::unique_ptr<ifaddrs, AddrDeleter>;
+
+    constexpr auto IPV4_PREFIX = "169.254"; /* IPv4 link-local addresses are assigned from address 
+					       block 169.254.0.0/16 (169.254.0.0 through 169.254.255.255) */
+    constexpr auto IPV6_PREFIX = "fe80::"; /* IPv6 link-local addresses are assigned from address 
+					       block fe80::/10. */
+
+    /** @brief retrive the all the interface
+     *  @returns list of interface.
+     */
+    InterfaceList getInterfaces();
+
+    /** @brief Converts the given interface name into a interface index
+     *  @param[in] mac - The interface name
+     *  @returns A valid interface index
+     */
+    unsigned ifIndex(const std::string& interfaceName);
+
+    namespace ethernetMAC /*namespace ethernetMAC */
+    {
+
+        /** @brief Converts the given mac address into byte form
+         *  @param[in] str - The mac address in human readable form
+         *  @returns A mac address in network byte order
+         *  @throws std::runtime_error for bad mac
+         */
+        ether_addr fromString(const char* str);
+        inline ether_addr fromString(const std::string& str)
+        {
+            return fromString(str.c_str());
+        }
+
+        /** @brief Converts the given mac address bytes into a string
+         *  @param[in] mac - The mac address
+         *  @returns A valid mac address string
+         */
+        std::string toString(const ether_addr& mac);
+
+        /** @brief get the mac address of the interface.
+         *  @return macaddress on success
+         */
+        std::string getMACaddress(const std::string& interfaceName);
+
+    }/*namespace ethernetMAC */
+
+    namespace ethernetIP /*namespace ethernetIP */
+    {
+
+        /* @brief converts a String representation of the ip into
+         *  ip bytes.
+         * @param[in] address - The string representation ip address
+         * @returns sockaddr representation of the ip.
+         */
+        IPv4Addrs fromString(const std::string& address);
+
+        /* @brief converts the ip bytes into a string representation
+         * @param[in] ip - input ip byte address to convert.
+         * @returns String representation of the ip.
+         */
+        std::string toString(const IPv4Addrs *ip);
+
+        /* @brief checks that the given ip address is link local or not.
+         * @param[in] address - IP address.
+         * @returns true if it is linklocal otherwise false.
+         */
+        bool isLinkLocalIP(const std::string& address);
+
+        /** @brief Gets the map of interface and the associated
+         *         address.
+         * @param[in] interfaceName - Name of Interface.
+         *  @returns map of interface and the address.
+         */
+        IntfAddrMap getInterfaceAddrs(std::string& interfaceName);
+
+    }/* namespace ethernetIP */
+
+    namespace garpControl /* namespace garpControl */
+    {
+        // Define a struct for ARP header
+        typedef struct arp_header ARPHeader;
+        struct arp_header {
+          uint16_t hardware_type;
+          uint16_t protocol_type;
+          uint8_t hardware_len;
+          uint8_t protocol_len;
+          uint16_t opcode;
+          uint8_t sender_mac[MAC_LENGTH];
+          uint8_t sender_ip[IPV4_LENGTH];
+          uint8_t target_mac[MAC_LENGTH];
+          uint8_t target_ip[IPV4_LENGTH];
+        };
+
+        /** @class GARP
+         *  @brief Network Gratuitous-ARP Reply Broadcasting.
+         *  @details A concrete implementation for the
+         *  GARP Packet Broadcasting API.
+         */
+        class GARP
+        {
+          public:
+            GARP() = default;
+            GARP(const GARP&) = delete;
+            GARP& operator=(const GARP&) = delete;
+            GARP(GARP&&) = delete;
+            GARP& operator=(GARP&&) = delete;
+            ~GARP() = default;
+
+            /** @brief Constructor to put object onto bus at a dbus path.
+             *  @param[in] interfaceName - GARP Broadcasting interface name.
+             *  @param[in] interval - GARP interval .
+             */
+            GARP(const std::string& interfaceName, const int interval);
+
+            /** @brief Broadcast the GARP Packet into the ethernet interface.
+             *  @param[in] start - GARP Broadcast start .
+             */
+            void broadcastPacket(bool start);
+
+          private:
+            /** @brief create the ethernet socket(raw socket) and write the GARP
+             *         Packet on it.
+             *  @returns true if successful or false.
+             */
+            bool sendPacket();
+
+            /** @brief reads IP address, interface index and MAC address from ethernet
+             *  @returns true if successful or false.
+             */
+            bool getIfaceDetails();
+
+            /** @brief create GARP header 
+             *  @param[in] arpHdr - GARP Header .
+             */
+            void GARPHeader(ARPHeader *arpHdr);
+
+            /** @brief create the frame header with GARP header
+             *  @param[in] arpHdr - GARP Header .
+             *  @param[in] etherhdr - ethernet Frame Header .
+             *  @returns total frame length.
+             */
+            int frameHeader(ARPHeader *arpHdr, uint8_t *ethernetHdr);
+
+            unsigned int replyInterval; /* frequency of reply send */
+            unsigned int ifindex;       /* ethernet interface index */
+            ether_addr mac;             /* ethernet MAC address */
+            IntfAddrMap IPv4Address;    /* IPv4 address list of interface */
+            IPv4Addrs ipAddr;           /* ethernet IP address */
+            std::string interface;      /* ethernet interface Name */
+        };
+
+    } /* namespace garpControl */
+
+} /* namespace network */
+
--- /dev/null    2022-11-06 05:20:28.867482042 -0500
+++ b/src/garp_control_main.cpp       2022-11-06 05:18:28.953115292 -0500
@@ -0,0 +1,123 @@
+#include "config.h"
+#include "config_parser.hpp"
+#include "garp_control.hpp"
+#include <filesystem>
+#include <fstream>
+#include <sstream>
+#include <thread>
+#include <algorithm>
+
+#include "util.hpp"
+
+using namespace phosphor::network;
+
+
+
+constexpr char ARPCONTROL_CONF_DIR[] = "/etc/arpcontrol";
+//constexpr auto arpPrefix = "00-bmc-arpcontrol-";
+//constexpr auto arpSurffix = ".conf";
+std::string arpKey = "ARP_Response";
+std::string garpKey = "GARP";
+
+namespace arpControlConfig
+{
+    using ServerList = std::vector<std::string>;
+    namespace fs = std::filesystem;
+
+    /** @brief create the ARP Control config parser object
+     *  @returns parser object if success or null
+     */
+    bool parser(config::Parser& parser, std::string& fileName)
+    {
+        fs::path confPath = ARPCONTROL_CONF_DIR;
+        confPath /= fileName;
+
+        if (!fs::is_regular_file(confPath.string()))
+        {
+           return false;
+        }
+        config::Parser arpControl(confPath.string());
+        parser = arpControl;
+
+       return true;
+    }
+
+    /** @brief read the Enabled field from ARP Control config
+     *  @param[in] parser - parser object
+     *  @param[in] key - searching key
+     *  @returns value of Enabled field
+     */
+    bool enabled(config::Parser& parser, std::string& key)
+    {
+        ServerList values;
+        auto rc = config::ReturnCode::SUCCESS;
+
+        std::tie(rc, values) = parser.getValues(key, "Enabled");
+        if (rc == config::ReturnCode::SUCCESS && !values.empty())
+        {
+            std::transform(values[0].begin(),values[0].end(), values[0].begin(), ::tolower);
+            return (values[0] == "true");
+        }
+
+        return false;
+    }
+
+    /** @brief read the interval field from ARP Control config
+     *  @param[in] parser - parser object
+     *  @param[in] key - searching key
+     *  @returns value of interval field
+     */
+    unsigned interval(config::Parser& parser, std::string& key)
+    {
+        ServerList servers;
+        auto rc = config::ReturnCode::SUCCESS;
+        auto interval = 0;
+
+        std::tie(rc, servers) = parser.getValues(key, "Interval");
+        if (rc == config::ReturnCode::SUCCESS && !servers.empty())
+        {
+            std::stringstream garpInterval(servers[0]);
+            garpInterval>>interval;
+            return interval;
+        }
+
+        return interval;
+    }
+
+}/* namespace arpControlConfig*/
+
+void GARPTask(const std::string &interface, unsigned interval, bool enable)
+{
+    network::garpControl::GARP garp(interface, interval);
+    garp.broadcastPacket(enable);
+}
+
+int main()
+{
+
+    config::Parser arpControlParser;
+    network::InterfaceList interfaceList = network::getInterfaces();
+    network::InterfaceList::iterator it;
+    std::vector<std::thread> threads;
+
+    for (it = interfaceList.begin(); it != interfaceList.end(); ++it)
+    {
+       std::string fileName = arpPrefix + *it + arpSurffix;
+
+        if (!arpControlConfig::parser(arpControlParser, fileName))
+            continue;
+
+        auto garpEnabled = getArpGarpEnabled(arpControlParser, "GARP");
+       auto garpInt = getGarpInterval(arpControlParser);
+        auto garpInterval = strtoul(garpInt.c_str(),nullptr,10);
+
+        if(garpEnabled)
+            threads.push_back(std::thread(GARPTask, *it, garpInterval, garpEnabled));
+    }
+
+    for (auto &th : threads) {
+        th.join();
+    }
+
+    return 0;
+}

--- /dev/null
+++ b/src/config_parser.cpp	2022-10-20 16:52:40.566038101 +0530
@@ -74,7 +74,48 @@
     }
     return nullptr;
 }
+std::tuple<ReturnCode, KeyValueMapstr>
+    Parser::getSectionstr(const std::string& section)
+{
+    auto it = sections.find(section);
+    if (it == sections.end())
+    {
+        KeyValueMapstr keyValues;
+        return std::make_tuple(ReturnCode::SECTION_NOT_FOUND,
+                               std::move(keyValues));
+    }
+
+    return std::make_tuple(ReturnCode::SUCCESS, it->second);
+}
 
+
+std::tuple<ReturnCode, ValueListstr> Parser::getValues(const std::string& section,
+                                                    const std::string& key)
+{
+    ValueListstr values;
+    KeyValueMapstr keyValues{};
+    auto rc = ReturnCode::SUCCESS;
+
+   std::tie(rc, keyValues) = getSectionstr(section);
+    if (rc != ReturnCode::SUCCESS)
+    {
+        return std::make_tuple(rc, std::move(values));
+    }
+
+   auto it = keyValues.find(key);
+    if (it == keyValues.end())
+    {
+        return std::make_tuple(ReturnCode::KEY_NOT_FOUND, std::move(values));
+    }
+
+   for (; it != keyValues.end() && key == it->first; it++)
+    {
+        values.push_back(it->second);
+    }
+
+   return std::make_tuple(ReturnCode::SUCCESS, std::move(values));
+}
+
 std::vector<std::string> SectionMap::getValueStrings(std::string_view section,
                                                      std::string_view key) const
 {
--- /dev/null
+++ b/src/config_parser.hpp	2022-10-20 16:51:32.521087430 +0530
@@ -4,17 +4,21 @@
 #include <functional>
 #include <optional>
 #include <ostream>
+#include <fstream>
 #include <string>
 #include <string_view>
 #include <unordered_map>
 #include <vector>
-
+#include <map>
 namespace phosphor
 {
 namespace network
 {
 namespace config
 {
+using Sectionstr= std::string;
+using KeyValueMapstr = std::multimap<std::string, std::string>;
+using ValueListstr = std::vector<std::string>;
 
 /** @brief Compare in (case insensitive) vs expected (sensitive) */
 bool icaseeq(std::string_view in, std::string_view expected) noexcept;
@@ -23,6 +27,13 @@
 
 namespace fs = std::filesystem;
 
+enum class ReturnCode
+{
+    SUCCESS = 0x0,
+    SECTION_NOT_FOUND = 0x1,
+    KEY_NOT_FOUND = 0x2,
+};
+
 fs::path pathForIntfConf(const fs::path& dir, std::string_view intf);
 fs::path pathForIntfDev(const fs::path& dir, std::string_view intf);
 
@@ -172,6 +183,9 @@
     /** @brief Determine if there were warnings parsing the file
      *  @return The number of parsing issues in the file
      */
+    std::tuple<ReturnCode, ValueListstr> getValues(const std::string& section,
+                                                const std::string& key);
+
     inline const std::vector<std::string>& getWarnings() const noexcept
     {
         return warnings;
@@ -197,6 +211,9 @@
   private:
     fs::path filename;
     std::vector<std::string> warnings;
+
+    std::tuple<ReturnCode, KeyValueMapstr> getSectionstr(const std::string& section);
+    std::unordered_map<Sectionstr, KeyValueMapstr> sections;
 };
 
 } // namespace config
--- a/src/util.hpp     2022-11-06 06:06:14.475771123 -0500
+++ b/src/util.hpp    2022-11-06 05:18:19.876633201 -0500
@@ -27,6 +27,9 @@
 constexpr auto IPV4_MIN_PREFIX_LENGTH = 1;
 constexpr auto IPV4_MAX_PREFIX_LENGTH = 32;
 constexpr auto IPV6_MAX_PREFIX_LENGTH = 128;
+constexpr auto arpPrefix = "00-bmc-arpcontrol-";
+constexpr auto arpSurffix = ".conf";
+

 namespace mac_address
 {
@@ -140,6 +143,9 @@
  */
 bool getDHCPProp(const config::Parser& config, std::string_view key);

+bool getArpGarpEnabled(const config::Parser& config, std::string_view section);
+std::string getGarpInterval(const config::Parser& config);
+
 namespace internal
 {

--- a/src/util.cpp     2022-11-06 06:02:47.073144456 -0500
+++ b/src/util.cpp    2022-11-06 05:18:19.876633201 -0500
@@ -417,6 +417,22 @@
         .value_or(true);
 }

+bool getArpGarpEnabled(const config::Parser& config, std::string_view section){
+return systemdParseLast(config, section, "Enabled", config::parseBool)
+        .value_or(false);
+}
+
+std::string getGarpInterval(const config::Parser& parser)
+{
+    if (auto str = parser.map.getLastValueString("GARP", "Interval"); str == nullptr)
+    {
+               return "2000";//Default value as 2000
+       }
+       else{
+           return *str;
+       }
+}
+
 namespace mac_address
 {

