--- a/user_mgr.cpp	2022-07-18 13:53:24.661226519 -0400
+++ b/user_mgr.cpp	2022-07-18 13:51:47.271199724 -0400
@@ -61,6 +61,14 @@
 static constexpr const char* pamPasswdConfigFile = "/etc/pam.d/common-password";
 static constexpr const char* pamAuthConfigFile = "/etc/pam.d/common-auth";
 
+enum privMgrLevel
+{
+    PRIV_ADMIN,
+    PRIV_OPERATOR,
+    PRIV_USER,
+    PRIV_NOACCESS
+};
+
 // Object Manager related
 static constexpr const char* ldapMgrObjBasePath =
     "/xyz/openbmc_project/user/ldap";
@@ -685,30 +693,27 @@
     return objects;
 }
 
-std::string UserMgr::getLdapGroupName(const std::string& userName)
+std::vector<std::string> UserMgr::getLdapGroupName(const std::string& userName)
 {
     struct passwd pwd
     {};
     struct passwd* pwdPtr = nullptr;
     auto buflen = sysconf(_SC_GETPW_R_SIZE_MAX);
+    int members;
     if (buflen < -1)
     {
         // Use a default size if there is no hard limit suggested by sysconf()
         buflen = 1024;
     }
     std::vector<char> buffer(buflen);
-    gid_t gid = 0;
+    // gid_t gid = 0;
 
     auto status =
         getpwnam_r(userName.c_str(), &pwd, buffer.data(), buflen, &pwdPtr);
     // On success, getpwnam_r() returns zero, and set *pwdPtr to pwd.
     // If no matching password record was found, these functions return 0
     // and store NULL in *pwdPtr
-    if (!status && (&pwd == pwdPtr))
-    {
-        gid = pwd.pw_gid;
-    }
-    else
+    if (status && !(&pwd == pwdPtr))
     {
         log<level::ERR>("User does not exist",
                         entry("USER_NAME=%s", userName.c_str()));
@@ -716,14 +721,20 @@
     }
 
     struct group* groups = nullptr;
-    std::string ldapGroupName;
+    std::vector<std::string> ldapGroupName;
 
     while ((groups = getgrent()) != NULL)
     {
-        if (groups->gr_gid == gid)
+              members = 0;
+        // Search through group members
+        while (groups->gr_mem[members] != NULL)
         {
-            ldapGroupName = groups->gr_name;
-            break;
+            if (userName.compare(groups->gr_mem[members]) == 0)
+            {
+                ldapGroupName.push_back(groups->gr_name);
+                break;
+            }
+            ++members;
         }
     }
     // Call endgrent() to close the group database.
@@ -778,7 +789,7 @@
     }
     else
     {
-        std::string ldapGroupName = getLdapGroupName(userName);
+        std::vector<std::string> ldapGroupName = getLdapGroupName(userName);
         if (ldapGroupName.empty())
         {
             log<level::ERR>("Unable to get group name",
@@ -791,6 +802,8 @@
         std::string privilege;
         std::string groupName;
         std::string ldapConfigPath;
+	int currentPriv, i, level;
+        currentPriv = (int)privMgr.size() - 1;
 
         try
         {
@@ -845,9 +858,33 @@
                             {
                                 privilege = value;
                             }
-                            if (groupName == ldapGroupName)
+			    // if both groupname and pivilege are set then check
+                            // if user is part of group
+                            if (!groupName.empty() && !privilege.empty())
                             {
-                                userInfo["UserPrivilege"] = privilege;
+                                // check if user if in Group so we can give
+                                // privilege
+                                for (i = 0; i < (int)ldapGroupName.size(); ++i)
+                                {
+                                    if (groupName == ldapGroupName[i])
+                                    {
+                                        // check priv level
+                                        for (level = 0;
+                                             level < (int)privMgr.size();
+                                             ++level)
+                                        {
+                                            // update priv level if higher than
+                                            // current level AND if priv is set
+                                            if (privilege == privMgr[level] &&
+                                                level <= currentPriv)
+                                            {
+                                                currentPriv = level;
+                                                userInfo["UserPrivilege"] =
+                                                    privilege;
+                                            }
+                                        }
+                                    }
+                                }
                             }
                         }
                     }
--- a/user_mgr.hpp	2022-07-18 13:53:24.661226519 -0400
+++ b/user_mgr.hpp	2022-07-18 13:51:51.003277275 -0400
@@ -341,7 +341,8 @@
      *  @param[in] - userName
      *  @return - group name
      */
-    virtual std::string getLdapGroupName(const std::string& userName);
+    virtual std::vector<std::string>
+        getLdapGroupName(const std::string& userName);
 
     /** @brief get privilege mapper object
      *  method to get dbus privilege mapper object
