From 4028ba8febf9e0276b9d6eaf7a8f6abb4eecd617 Mon Sep 17 00:00:00 2001
From: ramadevip <ramadevip@ami.com>
Date: Mon, 3 Jul 2023 14:09:47 +0530
Subject: [PATCH] Timer support for Chassis & Systems

Signed-off-by: ramadevip <ramadevip@ami.com>
---
 src/power_control.cpp | 349 ++++++++++++++++++++++++++++--------------
 1 file changed, 230 insertions(+), 119 deletions(-)

diff --git a/src/power_control.cpp b/src/power_control.cpp
index 14a8dd9..a8bce67 100644
--- a/src/power_control.cpp
+++ b/src/power_control.cpp
@@ -32,6 +32,10 @@
 #include <filesystem>
 #include <fstream>
 #include <string_view>
+#include <stdio.h>
+#include <iostream>
+#include <chrono>
+#include <cstdint>
 
 namespace power_control
 {
@@ -43,6 +47,10 @@ PowerRestoreController powerRestore(io);
 static std::string node = "0";
 static const std::string appName = "power-control";
 
+uint16_t powerTimeOut;
+uint16_t timeOut = 0;
+uint16_t prop = 0;
+
 enum class DbusConfigType
 {
     name = 1,
@@ -170,6 +178,8 @@ static boost::asio::steady_timer restartCauseTimer(io);
 static boost::asio::steady_timer slotPowerCycleTimer(io);
 // Timer for register DBus OsStatus interface retries
 static boost::asio::steady_timer registerOsStateRetryTimer(io);
+// Time when to allow restart
+static boost::asio::steady_timer powerTransitionTimer(io);
 
 // GPIO Lines and Event Descriptors
 static gpiod::line psPowerOKLine;
@@ -2905,101 +2915,127 @@ int main(int argc, char* argv[])
     hostIface =
         hostServer.add_interface("/xyz/openbmc_project/state/host" + node,
                                  "xyz.openbmc_project.State.Host");
+
+    hostIface->register_property("HostTransitionTimeOut",  timeOut,
+                    [](const uint16_t& requested,  uint16_t& propertyValue) {
+
+                    propertyValue = requested;
+                    powerTimeOut = propertyValue;
+                    return true;
+                    });
+
     // Interface for IPMI/Redfish initiated host state transitions
     hostIface->register_property(
         "RequestedHostTransition",
         std::string("xyz.openbmc_project.State.Host.Transition.Off"),
         [](const std::string& requested, std::string& resp) {
-            if (requested == "xyz.openbmc_project.State.Host.Transition.Off")
-            {
-                // if power button is masked, ignore this
-                if (!powerButtonMask)
-                {
-                    sendPowerControlEvent(Event::gracefulPowerOffRequest);
-                    addRestartCause(RestartCause::command);
-                }
-                else
-                {
-                    lg2::info("Power Button Masked.");
-                    throw std::invalid_argument("Transition Request Masked");
-                    return 0;
-                }
-            }
-            else if (requested ==
-                     "xyz.openbmc_project.State.Host.Transition.On")
-            {
-                // if power button is masked, ignore this
-                if (!powerButtonMask)
-                {
-                    sendPowerControlEvent(Event::powerOnRequest);
-                    addRestartCause(RestartCause::command);
-                }
-                else
-                {
-                    lg2::info("Power Button Masked.");
-                    throw std::invalid_argument("Transition Request Masked");
-                    return 0;
-                }
-            }
-            else if (requested ==
-                     "xyz.openbmc_project.State.Host.Transition.Reboot")
-            {
-                // if power button is masked, ignore this
-                if (!powerButtonMask)
-                {
-                    sendPowerControlEvent(Event::powerCycleRequest);
-                    addRestartCause(RestartCause::command);
-                }
-                else
-                {
-                    lg2::info("Power Button Masked.");
-                    throw std::invalid_argument("Transition Request Masked");
-                    return 0;
-                }
-            }
-            else if (
-                requested ==
-                "xyz.openbmc_project.State.Host.Transition.GracefulWarmReboot")
-            {
-                // if reset button is masked, ignore this
-                if (!resetButtonMask)
-                {
-                    sendPowerControlEvent(Event::gracefulPowerCycleRequest);
-                    addRestartCause(RestartCause::command);
-                }
-                else
-                {
-                    lg2::info("Reset Button Masked.");
-                    throw std::invalid_argument("Transition Request Masked");
-                    return 0;
-                }
-            }
-            else if (
-                requested ==
-                "xyz.openbmc_project.State.Host.Transition.ForceWarmReboot")
-            {
-                // if reset button is masked, ignore this
-                if (!resetButtonMask)
-                {
-                    sendPowerControlEvent(Event::resetRequest);
-                    addRestartCause(RestartCause::command);
-                }
-                else
-                {
-                    lg2::info("Reset Button Masked.");
-                    throw std::invalid_argument("Transition Request Masked");
-                    return 0;
-                }
-            }
-            else
-            {
-                lg2::error("Unrecognized host state transition request.");
-                throw std::invalid_argument("Unrecognized Transition Request");
-                return 0;
-            }
-            resp = requested;
-            return 1;
-        });
+
+               	    auto interval = std::chrono::seconds(powerTimeOut);
+                    powerTransitionTimer.expires_after(std::chrono::seconds(interval));
+                    powerTransitionTimer.async_wait([requested](const boost::system::error_code ec) {
+
+		         if (ec)
+                         {
+                              // operation_aborted is expected if timer is canceled beforecompletion.
+                              if (ec != boost::asio::error::operation_aborted)
+                              {
+                                    lg2::error("Host Transition TimeOut async_wait failed: {ERROR_MSG}",
+                                                    "ERROR_MSG", ec.message());
+                                    return;
+                              }
+                         }
+                         hostIface->set_property("HostTransitionTimeOut", prop);
+			 
+			 if (requested == "xyz.openbmc_project.State.Host.Transition.Off")
+			 {
+			 
+			       // if power button is masked, ignore this
+			       if (!powerButtonMask)
+                               {
+			             sendPowerControlEvent(Event::gracefulPowerOffRequest);
+                                     addRestartCause(RestartCause::command);
+                               }
+                               else
+                               {
+                                     lg2::info("Power Button Masked.");
+                                     throw std::invalid_argument("Transition Request Masked");
+                                     return;
+                               }
+                         }
+			 else if (requested ==
+					 "xyz.openbmc_project.State.Host.Transition.On")
+			 {
+				 // if power button is masked, ignore this
+				 if (!powerButtonMask)
+				 {
+					 sendPowerControlEvent(Event::powerOnRequest);
+					 addRestartCause(RestartCause::command);
+                                 }
+                                 else
+                                 {
+                                         lg2::info("Power Button Masked.");
+                                         throw std::invalid_argument("Transition Request Masked");
+                                         return;
+                                 }
+                        }
+			else if (requested ==
+					"xyz.openbmc_project.State.Host.Transition.Reboot")
+                        {
+				// if power button is masked, ignore this
+				if (!powerButtonMask)
+				{
+					sendPowerControlEvent(Event::powerCycleRequest);
+                                        addRestartCause(RestartCause::command);
+                                }
+                                else
+                                {
+                                        lg2::info("Power Button Masked.");
+                                        throw std::invalid_argument("Transition Request Masked");
+                                        return;
+                                }
+                       }     
+		       else if (requested ==
+				       "xyz.openbmc_project.State.Host.Transition.GracefulWarmReboot")
+		       {
+			       // if reset button is masked, ignore this
+                               if (!resetButtonMask)
+                               {
+				       sendPowerControlEvent(Event::gracefulPowerCycleRequest);
+                                       addRestartCause(RestartCause::command);
+                               }
+                               else
+                               {
+                                       lg2::info("Reset Button Masked.");
+                                       throw std::invalid_argument("Transition Request Masked");
+                                       return;
+                               }
+		       }
+		       else if (requested ==
+				       "xyz.openbmc_project.State.Host.Transition.ForceWarmReboot")
+		       {
+			       // if reset button is masked, ignore this
+                               if (!resetButtonMask)
+                               {
+				       sendPowerControlEvent(Event::resetRequest);
+                                       addRestartCause(RestartCause::command);
+                               }
+                               else
+                               {
+				       lg2::info("Reset Button Masked.");
+                                       throw std::invalid_argument("Transition Request Masked");
+                                       return;
+                               }
+		       }
+                       else
+                       {
+			       lg2::error("Unrecognized host state transition request.");
+                               throw std::invalid_argument("Unrecognized Transition Request");
+                               return;
+                       }
+		    });
+		    resp = requested;
+                    return 1;
+	});
     hostIface->register_property("CurrentHostState",
                                  std::string(getHostState(powerState)));
 
@@ -3013,6 +3049,21 @@ int main(int argc, char* argv[])
     chassisIface =
         chassisServer.add_interface("/xyz/openbmc_project/state/chassis" + node,
                                     "xyz.openbmc_project.State.Chassis");
+    chassisIface->register_property("ChassisHostTransitionTimeOut",  timeOut,
+                    [](const uint16_t& requested,  uint16_t& propertyValue) {
+
+                    propertyValue = requested;
+                    powerTimeOut = propertyValue;
+                    return true;
+                    });
+
+     chassisIface->register_property("PowerTransitionTimeOut",  timeOut,
+                    [](const uint16_t& requested,  uint16_t& propertyValue) {
+
+                    propertyValue = requested;
+                    powerTimeOut = propertyValue;
+                    return true;
+                    });
 
     chassisIface->register_property(
         "RequestedPowerTransition",
@@ -3020,19 +3071,37 @@ int main(int argc, char* argv[])
         [](const std::string& requested, std::string& resp) {
             if (requested == "xyz.openbmc_project.State.Chassis.Transition.Off")
             {
-                // if power button is masked, ignore this
-                if (!powerButtonMask)
-                {
-                    sendPowerControlEvent(Event::powerOffRequest);
-                    addRestartCause(RestartCause::command);
-                }
-                else
-                {
-                    lg2::info("Power Button Masked.");
-                    throw std::invalid_argument("Transition Request Masked");
-                    return 0;
-                }
-            }
+	            auto interval = std::chrono::seconds(powerTimeOut);
+                    powerTransitionTimer.expires_after(std::chrono::seconds(interval));
+                    powerTransitionTimer.async_wait([](const boost::system::error_code ec) {
+				    
+		          if (ec)
+                          {
+                                // operation_aborted is expected if timer is canceled beforecompletion.
+                                if (ec != boost::asio::error::operation_aborted)
+                                { 
+				      lg2::error("Power Transition TimeOut async_wait failed: {ERROR_MSG}",
+                                                                "ERROR_MSG", ec.message());
+                                      return;
+                                }
+                          }
+                          chassisIface->set_property("PowerTransitionTimeOut", prop);
+			  
+			  
+			  // if power button is masked, ignore this
+			  if (!powerButtonMask)
+                          {
+			      sendPowerControlEvent(Event::powerOffRequest);
+                              addRestartCause(RestartCause::command);
+                          }
+                          else
+                          {
+                              lg2::info("Power Button Masked.");
+                              throw std::invalid_argument("Transition Request Masked");
+                              return;
+                          }
+		    });
+	    }
             else if (requested ==
                      "xyz.openbmc_project.State.Chassis.Transition.On")
             {
@@ -3052,19 +3121,36 @@ int main(int argc, char* argv[])
             else if (requested ==
                      "xyz.openbmc_project.State.Chassis.Transition.PowerCycle")
             {
-                // if power button is masked, ignore this
-                if (!powerButtonMask)
-                {
-                    sendPowerControlEvent(Event::powerCycleRequest);
-                    addRestartCause(RestartCause::command);
-                }
-                else
-                {
-                    lg2::info("Power Button Masked.");
-                    throw std::invalid_argument("Transition Request Masked");
-                    return 0;
-                }
-            }
+		    auto interval = std::chrono::seconds(powerTimeOut);
+                    powerTransitionTimer.expires_after(std::chrono::seconds(interval));
+                    powerTransitionTimer.async_wait([](const boost::system::error_code ec) {
+				 
+		        if (ec)
+                        {
+			       // operation_aborted is expected if timer is canceled beforecompletion.
+                               if (ec != boost::asio::error::operation_aborted)
+                               {
+                                     lg2::error("Power Transition TimeOut async_wait failed: {ERROR_MSG}",
+						     "ERROR_MSG", ec.message());
+                                     return;
+                               }
+                        }
+			chassisIface->set_property("ChassisHostTransitionTimeOut", prop);
+			
+			// if power button is masked, ignore this
+			if (!powerButtonMask)
+			{
+			    sendPowerControlEvent(Event::powerCycleRequest);
+                            addRestartCause(RestartCause::command);
+                        }
+                        else
+                        {
+                            lg2::info("Power Button Masked.");
+                            throw std::invalid_argument("Transition Request Masked");
+                            return;
+			}
+		    });
+	    }
             else
             {
                 lg2::error("Unrecognized chassis state transition request.");
@@ -3090,6 +3176,14 @@ int main(int argc, char* argv[])
         "/xyz/openbmc_project/state/chassis_system0",
         "xyz.openbmc_project.State.Chassis");
 
+    chassisSysIface->register_property("ChassisHostTransitionTimeOut",  timeOut,
+                    [](const uint16_t& requested,  uint16_t& propertyValue) {
+
+                    propertyValue = requested;
+                    powerTimeOut = propertyValue;
+                    return true;
+                    });
+
     chassisSysIface->register_property(
         "RequestedPowerTransition",
         std::string("xyz.openbmc_project.State.Chassis.Transition.On"),
@@ -3097,9 +3191,26 @@ int main(int argc, char* argv[])
             if (requested ==
                 "xyz.openbmc_project.State.Chassis.Transition.PowerCycle")
             {
-                systemReset();
-                addRestartCause(RestartCause::command);
-            }
+	        auto interval = std::chrono::seconds(powerTimeOut);
+                powerTransitionTimer.expires_after(std::chrono::seconds(interval));
+                powerTransitionTimer.async_wait([](const boost::system::error_code ec) {
+                            
+		     if (ec)
+                     {
+		           // operation_aborted is expected if timer is canceled beforecompletion.
+                           if (ec != boost::asio::error::operation_aborted)
+                           {
+                                lg2::error("Power Transition TimeOut async_wait failed: {ERROR_MSG}",
+                                                   "ERROR_MSG", ec.message());
+                                return;
+                           }
+                     }
+                     chassisSysIface->set_property("ChassisHostTransitionTimeOut", prop);
+		     
+		     systemReset();
+                     addRestartCause(RestartCause::command);
+		     });
+	    }
             else
             {
                 lg2::error(
-- 
2.25.1

