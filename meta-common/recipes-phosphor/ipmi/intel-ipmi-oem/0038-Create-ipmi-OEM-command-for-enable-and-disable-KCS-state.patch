From ed14f108d026aa84d23d83043fe3f6da8ddcb248 Mon Sep 17 00:00:00 2001
From: sonan <sonan@ami.com>
Date: Mon, 25 Dec 2023 20:36:38 +0530
Subject: [PATCH 38/38] 
 0038-Create-ipmi-OEM-command-for-enable-and-disable-KCS-state.patch

---
 include/oemcommands.hpp |   4 ++
 ipmi-allowlist.conf     |   2 +
 src/oemcommands.cpp     | 106 ++++++++++++++++++++++++++++++++++++++++
 3 files changed, 112 insertions(+)

diff --git a/include/oemcommands.hpp b/include/oemcommands.hpp
index 38353b6..07967b8 100644
--- a/include/oemcommands.hpp
+++ b/include/oemcommands.hpp
@@ -18,6 +18,8 @@
 
 #include <ipmid/api-types.hpp>
 #include <user_channel/user_layer.hpp>
+#define KCS_ENABLE 0x01
+#define KCS_DISABLE 0x00
 namespace ipmi
 {
 namespace intel
@@ -247,6 +249,8 @@ namespace general
 {
 static constexpr Cmd cmdOEMGetSELPolicy = 0x7E;
 static constexpr Cmd cmdOEMSetSELPolicy = 0x7F;
+static constexpr Cmd cmdOEMGetKCSStatus = 0x3E;
+static constexpr Cmd cmdOEMSetKCSStatus = 0x3F;
 } // namespace general
 } // namespace ami
 
diff --git a/ipmi-allowlist.conf b/ipmi-allowlist.conf
index fa632b6..d3e6ee9 100644
--- a/ipmi-allowlist.conf
+++ b/ipmi-allowlist.conf
@@ -327,6 +327,8 @@
 0x32:0x63:0xff7f   //<Intel OEM Platform>:<Get Tach Information>
 0x32:0x7E:0xff7f   //<AMI OEM General>::<Get SEL Policy>
 0x32:0x7F:0xff7f   //<AMI OEM General>::<Set SEL Policy>
+0x32:0x3E:0xff7f   //<AMI OEM General>::<Get KCS Status>
+0x32:0x3F:0xff7f   //<AMI OEM General>::<Set KCS Status>
 0x32:0x80:0xff7f   //<Intel OEM Platform>:<Get SOL Log Number>
 0x32:0x81:0xff7f   //<Intel OEM Platform>:<Get SOL Log Entry>
 0x32:0x83:0xff7f   //<Intel OEM Platform>:<Get SOL Control>
diff --git a/src/oemcommands.cpp b/src/oemcommands.cpp
index ac0d867..ca30102 100644
--- a/src/oemcommands.cpp
+++ b/src/oemcommands.cpp
@@ -153,6 +153,15 @@ static constexpr const char* multiNodeObjPath =
     "/xyz/openbmc_project/MultiNode/Status";
 static constexpr const char* multiNodeIntf =
     "xyz.openbmc_project.Chassis.MultiNode";
+const static constexpr char* systemDService = "org.freedesktop.systemd1";
+const static constexpr char* systemDObjPath = "/org/freedesktop/systemd1";
+const static constexpr char* systemDMgrIntf =
+    "org.freedesktop.systemd1.Manager";
+const static constexpr char* ipmiKcsService = "phosphor-ipmi-kcs@ipmi_kcs3.service";
+
+constexpr auto systemDInterfaceUnit = "org.freedesktop.DBus.Properties";
+constexpr auto activeState = "active";
+constexpr auto activatingState = "activating";
 
 enum class NmiSource : uint8_t
 {
@@ -5139,6 +5148,93 @@ ipmi::RspType<std::vector<uint8_t>> ipmiOEMReadCertficate(
     return ipmi::responseSuccess(respBuf);
 }
 
+ipmi::RspType<uint8_t> ipmiOEMGetKCSStatus(ipmi::Context::ptr ctx)
+{
+    try
+    {
+        // Establish a D-Bus connection
+        auto dbus = getSdBus();
+
+        // Create method call message to get the service unit properties
+        auto method = dbus->new_method_call(systemDService, systemDObjPath,
+                                           systemDMgrIntf,
+                                           "GetUnit");
+        method.append(ipmiKcsService);
+
+        auto reply = dbus->call(method);
+
+        // Process the reply to extract the service status
+        std::variant<std::string> currentState;
+        sdbusplus::message::object_path unitTargetPath;
+
+        reply.read(unitTargetPath);
+
+        method = dbus->new_method_call(
+            systemDService,
+            static_cast<const std::string&>(unitTargetPath).c_str(),
+            systemDInterfaceUnit, "Get");
+
+        method.append("org.freedesktop.systemd1.Unit", "ActiveState");
+  try
+        {
+            auto result = dbus->call(method);
+            result.read(currentState);
+        }
+        catch (const sdbusplus::exception_t& e)
+        {
+            syslog(LOG_WARNING, "Error in ActiveState Get:%s\n", e.what());
+            return ipmi::responseResponseError();
+        }
+        // Check the service state
+        const auto& currentStateStr = std::get<std::string>(currentState);
+
+        uint8_t kcsstate = 0;
+
+        if (currentStateStr == activeState || currentStateStr == activatingState)
+        {
+            kcsstate = 1;
+        }
+        else
+        {
+            kcsstate = 0;
+        }
+
+        return ipmi::responseSuccess(kcsstate);
+    }
+    catch (const sdbusplus::exception_t& e)
+    {
+        return ipmi::responseResponseError();
+    }
+}
+ipmi::RspType<> ipmiOEMSetKCSStatus(ipmi::Context::ptr ctx, uint8_t reqData)
+{
+
+   if (reqData == KCS_ENABLE || reqData == KCS_DISABLE)
+    {
+            try
+            {
+
+                auto dbus = getSdBus();
+                auto method = dbus->new_method_call(systemDService, systemDObjPath,
+                                            systemDMgrIntf,
+                                            reqData ? "StartUnit" : "StopUnit");
+                method.append(ipmiKcsService, "replace");
+                auto reply = dbus->call(method);
+                return ipmi::responseSuccess();
+            }
+            catch (const sdbusplus::exception_t& e)
+            {
+
+                return ipmi::responseResponseError();
+            }
+    }
+
+    else{
+
+            return ipmi::responseResponseError();
+    }
+
+}
 static void registerOEMFunctions(void)
 {
     phosphor::logging::log<phosphor::logging::level::INFO>(
@@ -5414,6 +5510,16 @@ static void registerOEMFunctions(void)
                     ami::general::cmdOEMGetSELPolicy, Privilege::User,
                     ipmiOEMGetSELPolicy);
 
+    //<Get KCS Status>
+    registerHandler(prioOemBase, ami::netFnGeneral,
+                    ami::general::cmdOEMGetKCSStatus, Privilege::User,
+                    ipmiOEMGetKCSStatus);
+
+    //<Set KCS Status>
+    registerHandler(prioOemBase, ami::netFnGeneral,
+                    ami::general::cmdOEMSetKCSStatus, Privilege::User,
+                    ipmiOEMSetKCSStatus);
+
 
 }
 
-- 
2.43.0

