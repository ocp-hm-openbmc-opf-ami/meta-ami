From e825c346a90a79b1022465150655429e2d0719ba Mon Sep 17 00:00:00 2001
From: Ethan Wei <ethanwei@ami.com>
Date: Mon, 10 Jul 2023 10:18:15 +0800
Subject: [PATCH] Get the number of VLAN intefaces and Ethernet Intefaces
 during channelCall and add pre-check brefore creating VLAN inteface for not
 creating VLAN interface over the pre-defined size. 	modified:  
 transporthandler.cpp 	modified:   transporthandler.hpp

---
 transporthandler.cpp | 20 +++++++++++++++++++-
 transporthandler.hpp |  5 +++++
 2 files changed, 24 insertions(+), 1 deletion(-)

diff --git a/transporthandler.cpp b/transporthandler.cpp
index 7160d04..12b1753 100644
--- a/transporthandler.cpp
+++ b/transporthandler.cpp
@@ -77,6 +77,8 @@ std::optional<ChannelParams> maybeGetChannelParams(sdbusplus::bus_t& bus,
     reply.read(objs);
 
     ChannelParams params;
+    params.numIntfVlan = 0;
+    params.numIntfEthernet = 0;
     for (const auto& [path, impls] : objs)
     {
         if (path.find(ifname) == path.npos)
@@ -91,10 +93,12 @@ std::optional<ChannelParams> maybeGetChannelParams(sdbusplus::bus_t& bus,
             {
                 if (intf == INTF_VLAN)
                 {
+                    params.numIntfVlan += 1;
                     vlan = true;
                 }
                 else if (intf == INTF_ETHERNET)
                 {
+                    params.numIntfEthernet += 1;
                     ethernet = true;
                 }
             }
@@ -676,6 +680,15 @@ void createVLAN(sdbusplus::bus::bus& bus, ChannelParams& params, uint16_t vlan)
     }
 }
 
+/** @brief Creates a new VLAN on the specified interface
+ *
+ *  @param[in] bus    - The bus object used for lookups
+ *  @param[in] params - The parameters for the channel
+ */
+int getVLANNum([[maybe_unused]]sdbusplus::bus::bus& bus, ChannelParams& params) {
+    return params.numIntfVlan;
+}
+
 /** @brief delete a VLAN on the specified interface
  *
  *  @param[in] bus    - The bus object used for lookups
@@ -1258,7 +1271,12 @@ RspType<> setLan(Context::ptr ctx, uint4_t channelBits, uint4_t reserved1,
             {
                 return responseInvalidFieldRequest();
             }
-            channelCall<createVLAN>(channel, vlan);
+            if ( channelCall<getVLANNum>(channel) >= VLAN_MAX_NUM ) {
+                log<level::ERR>("The number of VLAN interface of this parent interface is out of range, so skip this command...\n");
+                return responseCommandNotAvailable();
+            }
+            else
+                channelCall<createVLAN>(channel, vlan);
             return responseSuccess();
         }
         case LanParam::VLANPriority:
diff --git a/transporthandler.hpp b/transporthandler.hpp
index 0cf8f62..a2f6da5 100644
--- a/transporthandler.hpp
+++ b/transporthandler.hpp
@@ -169,6 +169,7 @@ constexpr Cc ccParamReadOnly = 0x82;
 // VLANs are a 12-bit value
 constexpr uint16_t VLAN_VALUE_MASK = 0x0fff;
 constexpr uint16_t VLAN_ENABLE_FLAG = 0x8000;
+constexpr uint8_t VLAN_MAX_NUM = 2;
 
 // Arbitrary v6 Address Limits to prevent too much output in ipmitool
 constexpr uint8_t MAX_IPV6_STATIC_ADDRESSES = 16;
@@ -197,6 +198,10 @@ struct ChannelParams
     std::string ifPath;
     /** @brief Logical adapter path used for address assignment */
     std::string logicalPath;
+    /** @brief Number of created VLAN interface */
+    int numIntfVlan;
+    /** @brief Number of created VLAN interface and non-VLAN interface */
+    int numIntfEthernet;
 };
 
 /** @brief A trivial helper used to determine if two PODs are equal
-- 
2.25.1

