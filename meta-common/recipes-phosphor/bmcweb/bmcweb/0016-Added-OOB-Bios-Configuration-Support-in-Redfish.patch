From 285f2e273ee8934fda20f6eec4b847bf92cce3e9 Mon Sep 17 00:00:00 2001
From: Abinaya L <abinayal@ami.com>
Date: Tue, 18 Jul 2023 16:42:02 +0530
Subject: [PATCH 16/16] 0016-Added-OOB-Bios-Configuration-Support-in-Redfish

---
 config/bmcweb.service.in             |    1 +
 config/pam-webserver                 |    2 +
 redfish-core/include/redfish.hpp     |    3 +-
 redfish-core/lib/account_service.hpp |   88 +-
 redfish-core/lib/bios.hpp            | 2233 ++++++++++++++++--------
 5 files changed, 1633 insertions(+), 694 deletions(-)

diff --git a/config/bmcweb.service.in b/config/bmcweb.service.in
index a0b6777..a07adbe 100644
--- a/config/bmcweb.service.in
+++ b/config/bmcweb.service.in
@@ -7,6 +7,7 @@ After=network.target
 [Service]
 ExecReload=kill -s HUP $MAINPID
 ExecStart=@MESON_INSTALL_PREFIX@/bin/bmcweb
+ExecStop=/bin/bash /usr/bin/delete-hi-user.sh
 Type=simple
 WorkingDirectory=/home/root
 
diff --git a/config/pam-webserver b/config/pam-webserver
index a5e7af4..b7755f5 100644
--- a/config/pam-webserver
+++ b/config/pam-webserver
@@ -4,5 +4,7 @@ auth     include  common-auth
 # skip redfish group check for non-local user (ldap)
 auth     [success=ok perm_denied=1 default=ignore] pam_localuser.so
 auth     required pam_succeed_if.so user ingroup redfish
+auth     sufficient pam_succeed_if.so user ingroup redfish
+auth     sufficient pam_succeed_if.so user ingroup redfish-hostiface
 account  include  common-account
 password include  common-password
diff --git a/redfish-core/include/redfish.hpp b/redfish-core/include/redfish.hpp
index 1f97d45..e8b8bc9 100644
--- a/redfish-core/include/redfish.hpp
+++ b/redfish-core/include/redfish.hpp
@@ -240,8 +240,9 @@ class RedfishService
         requestRoutesSystemResetActionInfo(app);
         requestRoutesBiosService(app);
         requestRoutesBiosSettings(app);
-        requestRoutesBiosAttributeRegistry(app);
+	//requestRoutesBiosAttributeRegistry(app);
         requestRoutesBiosReset(app);
+	requestRoutesBiosAttrRegistryService(app);
         requestRoutesBiosChangePassword(app);
 
 #ifdef BMCWEB_ENABLE_VM_NBDPROXY
diff --git a/redfish-core/lib/account_service.hpp b/redfish-core/lib/account_service.hpp
index 6b6e44a..a2f43fe 100644
--- a/redfish-core/lib/account_service.hpp
+++ b/redfish-core/lib/account_service.hpp
@@ -1676,19 +1676,81 @@ inline void handleAccountCollectionGet(
 
                 return;
             }
-
-            // As clarified by Redfish here:
-            // https://redfishforum.com/thread/281/manageraccountcollection-change-allows-account-enumeration
-            // Users without ConfigureUsers, only see their own
-            // account. Users with ConfigureUsers, see all
-            // accounts.
-            if (userCanSeeAllAccounts || (thisUser == user && userCanSeeSelf))
-            {
-                nlohmann::json::object_t member;
-                member["@odata.id"] = "/redfish/v1/AccountService/Accounts/" +
-                                      user;
-                memberArray.emplace_back(std::move(member));
-            }
+	crow::connections::systemBus->async_method_call(
+                                [asyncResp, thisUser, userCanSeeAllAccounts,
+                                 userCanSeeSelf, user, &memberArray](
+                                    const boost::system::error_code ec,
+                                    const std::map<
+                                        std::string,
+                                        dbus::utility::DbusVariantType>&
+                                        userInfo) {
+                                    if (ec)
+                                    {
+                                        BMCWEB_LOG_ERROR
+                                            << "GetUserInfo failed";
+                                        messages::internalError(asyncResp->res);
+                                        return;
+                                    }
+				   const std::vector<std::string>*
+                                        userGroupPtr = nullptr;
+                                   auto userInfoIter =
+                                        userInfo.find("UserGroups");
+                                    if (userInfoIter != userInfo.end())
+                                    {
+                                        userGroupPtr = std::get_if<
+                                            std::vector<std::string>>(
+                                            &userInfoIter->second);
+                                    }
+
+                                    if (userGroupPtr == nullptr)
+                                    {
+                                        BMCWEB_LOG_ERROR
+                                            << "User Group not found";
+                                        messages::internalError(asyncResp->res);
+                                        return;
+                                    }
+
+                                    // If the host interface user found, then
+                                    // skip that user and don't add in response.
+                                   auto found = std::find_if(
+                                       userGroupPtr->begin(),
+                                        userGroupPtr->end(),
+                                        [](const auto& group) {
+                                           return (group ==
+                                                    "redfish-hostiface")
+                                                       ? true
+                                                       : false;
+                                       });
+                                    if (found == userGroupPtr->end())
+                                    {
+                                        // As clarified by Redfish here:
+                                        // https://redfishforum.com/thread/281/manageraccountcollection-change-allows-account-enumeration
+                                        // Users without ConfigureUsers, only
+                                        // see their own account. Users with
+                                        // ConfigureUsers, see all accounts.
+                                        if (userCanSeeAllAccounts ||
+                                            (thisUser == user &&
+                                             userCanSeeSelf))
+                                        {
+                                            memberArray.push_back(
+                                                {{"@odata.id",
+                                                  "/redfish/v1/AccountService/Accounts/" +
+                                                      user}});
+                                        }
+                                    }
+                                    else
+                                    {
+                                       BMCWEB_LOG_DEBUG
+                                            << "Skip the HostInterface User";
+                                    }
+                                   asyncResp->res
+                                        .jsonValue["Members@odata.count"] =
+                                        memberArray.size();
+                                },
+                                "xyz.openbmc_project.User.Manager",
+                                "/xyz/openbmc_project/user",
+                                "xyz.openbmc_project.User.Manager",
+                                "GetUserInfo", user);
         }
         asyncResp->res.jsonValue["Members@odata.count"] = memberArray.size();
         },
diff --git a/redfish-core/lib/bios.hpp b/redfish-core/lib/bios.hpp
index dd6c19a..e4eac42 100644
--- a/redfish-core/lib/bios.hpp
+++ b/redfish-core/lib/bios.hpp
@@ -9,148 +9,1514 @@
 
 namespace redfish
 {
+namespace bios
+{
+/**
+ * BiosConfig Manager Dbus info
+ */
+constexpr char const* biosConfigObj =
+    "/xyz/openbmc_project/bios_config/manager";
+constexpr char const* biosConfigIface =
+    "xyz.openbmc_project.BIOSConfig.Manager";
 
-/*baseBIOSTable
-map{attributeName,struct{attributeType,readonlyStatus,displayname,
-              description,menuPath,current,default,
-              array{struct{optionstring,optionvalue}}}}
-*/
+using GetObjectType =
+    std::vector<std::pair<std::string, std::vector<std::string>>>;
 
-using BiosBaseTableType = boost::container::flat_map<
+/**
+ * BiosService DBus types
+ */
+using BaseBIOSTable = boost::container::flat_map<
     std::string,
-    std::tuple<
-        std::string, bool, std::string, std::string, std::string,
-        std::variant<int64_t, std::string>, std::variant<int64_t, std::string>,
-        std::vector<std::tuple<std::string, std::variant<int64_t, std::string>,
-                               std::string>>>>;
+    std::tuple<std::string, bool, std::string, std::string, std::string,
+               std::variant<int64_t, std::string, bool>,
+               std::variant<int64_t, std::string, bool>,
+               std::vector<std::tuple<std::string,
+                                      std::variant<int64_t, std::string>>>>>;
 
-using BiosBaseTableItemType = std::pair<
+using BaseBIOSTableItem = std::pair<
     std::string,
-    std::tuple<
-        std::string, bool, std::string, std::string, std::string,
-        std::variant<int64_t, std::string>, std::variant<int64_t, std::string>,
-        std::vector<std::tuple<std::string, std::variant<int64_t, std::string>,
-                               std::string>>>>;
-
-using OptionsItemType =
-    std::tuple<std::string, std::variant<int64_t, std::string>, std::string>;
+    std::tuple<std::string, bool, std::string, std::string, std::string,
+               std::variant<int64_t, std::string, bool>,
+               std::variant<int64_t, std::string, bool>,
+               std::vector<std::tuple<std::string,
+                                      std::variant<int64_t, std::string>>>>>;
+using PendingAttrType = boost::container::flat_map<
+    std::string,
+    std::tuple<std::string, std::variant<int64_t, std::string, bool>>>;
 
-using PendingAttributesType = boost::container::flat_map<
-    std::string, std::tuple<std::string, std::variant<int64_t, std::string>>>;
+using PendingAttrItemType = std::pair<
+    std::string,
+    std::tuple<std::string, std::variant<int64_t, std::string, bool>>>;
 
-using PendingAttributesItemType =
-    std::pair<std::string,
-              std::tuple<std::string, std::variant<int64_t, std::string>>>;
+using AttrBoundType =
+    std::tuple<std::string, std::variant<int64_t, std::string>>;
 
-enum BiosBaseTableIndex
+enum BaseBiosTableIndex
 {
-    biosBaseAttrType = 0,
-    biosBaseReadonlyStatus,
-    biosBaseDisplayName,
-    biosBaseDescription,
-    biosBaseMenuPath,
-    biosBaseCurrValue,
-    biosBaseDefaultValue,
-    biosBaseOptions
+    baseBiosAttrType = 0,
+    baseBiosReadonlyStatus,
+    baseBiosDisplayName,
+    baseBiosDescription,
+    baseBiosMenuPath,
+    baseBiosCurrValue,
+    baseBiosDefaultValue,
+    baseBiosBoundValues
 };
-enum OptionsItemIndex
+
+enum BaseBiosBoundIndex
 {
-    optItemType = 0,
-    optItemValue,
-    optItemText
+    baseBiosBoundType = 0,
+    baseBiosBoundValue
 };
 
-enum PendingAttributesIndex
-{
-    pendingAttrType = 0,
-    pendingAttrValue
+enum BiosPendingAttributesIndex
+ {
+    biosPendingAttrType = 0,
+    biosPendingAttrValue
 };
-static std::string mapAttrTypeToRedfish(const std::string_view typeDbus)
+
+
+/**
+ *@brief Translates Base BIOS Table attribute type from DBUS property value to
+ *Redfish string type.
+ *
+ *@param[in] attrType The DBUS BIOS attribute type value
+ *
+ *@return Returns as a string, the attribute type required for Redfish.
+ *If attribute type didn't match, then returns 'UNKNOWN' string.
+ */
+static std::string getBiosAttrType(const std::string& attrType)
 {
-    std::string ret;
-    if (typeDbus == "xyz.openbmc_project.BIOSConfig."
-                    "Manager.AttributeType.String")
+    std::string type;
+    if (attrType ==
+        "xyz.openbmc_project.BIOSConfig.Manager.AttributeType.Enumeration")
     {
-        ret = "String";
+	type = "Enumeration";
     }
-    else if (typeDbus == "xyz.openbmc_project.BIOSConfig."
-                         "Manager.AttributeType.Integer")
+    else if (attrType ==
+             "xyz.openbmc_project.BIOSConfig.Manager.AttributeType.String")
     {
-        ret = "Integer";
+	type = "String";
     }
-    else if (typeDbus == "xyz.openbmc_project.BIOSConfig."
-                         "Manager.AttributeType.Enumeration")
+    else if (attrType ==
+             "xyz.openbmc_project.BIOSConfig.Manager.AttributeType.Password")
     {
-        ret = "Enumeration";
+        type = "Password";
+    }
+    else if (attrType ==
+             "xyz.openbmc_project.BIOSConfig.Manager.AttributeType.Integer")
+    {
+        type = "Integer";
+    }
+    else if (attrType ==
+             "xyz.openbmc_project.BIOSConfig.Manager.AttributeType.Boolean")
+    {
+        type = "Boolean";
     }
     else
     {
-        ret = "UNKNOWN";
+        type = "UNKNOWN";
     }
+    return type;
+}
 
-    return ret;
+/**
+ *@brief Translates Base BIOS Table attribute type from Redfish string type to
+ *DBUS property value.
+ *
+ *@param[in] attrType The Redfish BIOS attribute string type value
+ *
+ *@return Returns as a string, the attribute type required for DBUS.
+ *If attribute type didn't match, then returns 'UNKNOWN' string.
+ */
+static std::string getDbusBiosAttrType(const std::string& attrType)
+{
+    std::string type;
+    if (attrType == "Enumeration")
+    {
+        type =
+            "xyz.openbmc_project.BIOSConfig.Manager.AttributeType.Enumeration";
+    }
+    else if (attrType == "String")
+    {
+        type = "xyz.openbmc_project.BIOSConfig.Manager.AttributeType.String";
+    }
+    else if (attrType == "Password")
+    {
+        type = "xyz.openbmc_project.BIOSConfig.Manager.AttributeType.Password";
+    }
+    else if (attrType == "Integer")
+    {
+        type = "xyz.openbmc_project.BIOSConfig.Manager.AttributeType.Integer";
+    }
+    else if (attrType == "Boolean")
+    {
+        type = "xyz.openbmc_project.BIOSConfig.Manager.AttributeType.Boolean";
+    }
+    else
+    {
+        type = "UNKNOWN";
+    }
+    return type;
 }
 
-static std::string mapBoundTypeToRedfish(const std::string_view typeDbus)
+/**
+ *@brief Translates Base BIOS Table attribute bound value type from DBUS
+ *property value to Redfish string type.
+ *
+ *@param[in] attrType The DBUS BIOS Bound value attribute type value
+ *
+ *@return Returns as a string, the attribute bound value type required for
+ *Redfish. If attribute type didn't match, then returns 'UNKNOWN' string.
+ */
+static std::string getBiosBoundValType(const std::string& boundValType)
 {
-    std::string ret;
-    if (typeDbus ==
-        "xyz.openbmc_project.BIOSConfig.Manager.BoundType.ScalarIncrement")
+    std::string type;
+    if (boundValType ==
+	"xyz.openbmc_project.BIOSConfig.Manager.BoundType.ScalarIncrement")
     {
-        ret = "ScalarIncrement";
+	type = "ScalarIncrement";
     }
-    else if (typeDbus ==
+    else if (boundValType ==
              "xyz.openbmc_project.BIOSConfig.Manager.BoundType.LowerBound")
     {
-        ret = "LowerBound";
+	type = "LowerBound";
     }
-    else if (typeDbus ==
+    else if (boundValType ==
              "xyz.openbmc_project.BIOSConfig.Manager.BoundType.UpperBound")
     {
-        ret = "UpperBound";
+	type = "UpperBound";
     }
-    else if (typeDbus ==
-             "xyz.openbmc_project.BIOSConfig.Manager.BoundType.MinStringLength")
+    else if (boundValType ==
+             "xyz.openbmc_project.BIOSConfig.Manager.BoundType.OneOf")
     {
-        ret = "MinStringLength";
+        type = "OneOf";
     }
-    else if (typeDbus ==
-             "xyz.openbmc_project.BIOSConfig.Manager.BoundType.MaxStringLength")
+    else
     {
-        ret = "MaxStringLength";
+	type = "UNKNOWN";
     }
-    else if (typeDbus ==
-             "xyz.openbmc_project.BIOSConfig.Manager.BoundType.OneOf")
+
+    return type;
+}
+
+/**
+ *@brief Translates Reset BIOS to Default Settings status type from DBUS
+ *property value to Redfish string type.
+ *
+ *@param[in] biosMode The DBUS BIOS Reset BIOS to Default Setting status value
+ *
+ *@return Returns as a string, the Reset BIOS Settings to default type required
+ *for Redfish. If attribute type didn't match, then returns 'UNKNOWN' string.
+ */
+static std::string getBiosDefaultSettingsMode(const std::string& biosMode)
+{
+    std::string mode;
+    if (biosMode == "xyz.openbmc_project.BIOSConfig.Manager.ResetFlag.NoAction")
+    {
+        mode = "NoAction";
+    }
+    else if (biosMode ==
+             "xyz.openbmc_project.BIOSConfig.Manager.ResetFlag.FactoryDefaults")
     {
-        ret = "OneOf";
+        mode = "FactoryDefaults";
+    }
+    else if (
+        biosMode ==
+        "xyz.openbmc_project.BIOSConfig.Manager.ResetFlag.FailSafeDefaults")
+    {
+        mode = "FailSafeDefaults";
     }
     else
     {
-        ret = "UNKNOWN";
+        mode = "UNKNOWN";
     }
+    
+    return mode;
+}
+
+/**
+ *@brief sets the Reset BIOS Settings to default property.
+ *
+ * @param[in]       ResetBiosToDefaultsPending    Reset BIOS Settings to Default
+ *status
+ * @param[in,out]   asyncResp   Async HTTP response.
+ *
+ * @return None.
+ */
+static void
+    setResetBiosSettings(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                         const bool& resetBiosToDefaultsPending)
+{
+    BMCWEB_LOG_DEBUG << "Set Reset Bios Settings to Defaults Pending Status";
+    crow::connections::systemBus->async_method_call(
+        [asyncResp, resetBiosToDefaultsPending](
+            const boost::system::error_code ec, const GetObjectType& objType) {
+            if (ec || objType.empty())
+            {
+                BMCWEB_LOG_ERROR << "GetObject for path " << biosConfigObj;
+                messages::internalError(asyncResp->res);
+                return;
+            }
 
-    return ret;
+            const std::string& biosService = objType.begin()->first;
+
+            std::string biosMode;
+            if (resetBiosToDefaultsPending)
+            {
+                biosMode =
+                    "xyz.openbmc_project.BIOSConfig.Manager.ResetFlag.FactoryDefaults";
+            }
+            else
+            {
+                biosMode =
+                    "xyz.openbmc_project.BIOSConfig.Manager.ResetFlag.NoAction";
+            }
+            crow::connections::systemBus->async_method_call(
+                [asyncResp](const boost::system::error_code ec) {
+                    if (ec)
+                    {
+                        BMCWEB_LOG_DEBUG
+                            << "DBUS response error for "
+                               "Set Reset BIOS setting to default status.";
+                        messages::internalError(asyncResp->res);
+                        return;
+                    }
+                    messages::success(asyncResp->res);
+                },
+                biosService, biosConfigObj, "org.freedesktop.DBus.Properties",
+                "Set", biosConfigIface, "ResetBIOSSettings",
+                std::variant<std::string>(biosMode));
+        },
+        "xyz.openbmc_project.ObjectMapper",
+        "/xyz/openbmc_project/object_mapper",
+        "xyz.openbmc_project.ObjectMapper", "GetObject", biosConfigObj,
+        std::array<const char*, 1>{biosConfigIface});
 }
 
 /**
- * BiosService class supports handle get method for bios.
+ *@brief Reads the Reset BIOS Settings to default property.
+ *
+ * @param[in,out]   asyncResp   Async HTTP response.
+ *
+ * @return None.
+ */
+static void
+    getResetBiosSettings(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
+{
+    BMCWEB_LOG_DEBUG << "Get Reset Bios Settings to Defaults Pending Status";
+ 
+    crow::connections::systemBus->async_method_call(
+        [asyncResp](const boost::system::error_code ec,
+
+                    const GetObjectType& objType) {
+            if (ec || objType.empty())
+            {
+                BMCWEB_LOG_ERROR << "GetObject for path " << biosConfigObj;
+                messages::internalError(asyncResp->res);
+                return;
+            }
+            const std::string& biosService = objType.begin()->first;
+            crow::connections::systemBus->async_method_call(
+                [asyncResp](
+                    const boost::system::error_code ec,
+                    const std::variant<std::string>& resetBiosSettingsMode) {
+                    if (ec)
+                    {
+                        BMCWEB_LOG_DEBUG
+                            << "DBUS response error for "
+                               "Get Reset BIOS setting to default status.";
+                        messages::internalError(asyncResp->res);
+                        return;
+                    }
+                    const std::string* value =
+                        std::get_if<std::string>(&resetBiosSettingsMode);
+                    if (value == nullptr)
+                    {
+                        BMCWEB_LOG_DEBUG
+                            << "Null value returned for Reset BIOS Settings status";
+                        messages::internalError(asyncResp->res);
+                        return;
+                    }
+
+                    std::string biosMode = getBiosDefaultSettingsMode(*value);
+
+                    if (biosMode == "NoAction")
+                    {
+                        asyncResp->res.jsonValue["ResetBiosToDefaultsPending"] =
+                            false;
+                    }
+                    else if ((biosMode == "FactoryDefaults") ||
+                             (biosMode == "FailSafeDefaults"))
+                    {
+                        asyncResp->res.jsonValue["ResetBiosToDefaultsPending"] =
+                            true;
+                    }
+                    else
+                    {
+                        BMCWEB_LOG_DEBUG
+                            << "Invalid Reset BIOS Settings Status";
+                        messages::internalError(asyncResp->res);
+                        return;
+                    }
+                },
+                biosService, biosConfigObj, "org.freedesktop.DBus.Properties",
+                "Get", biosConfigIface, "ResetBIOSSettings");
+        },
+        "xyz.openbmc_project.ObjectMapper",
+        "/xyz/openbmc_project/object_mapper",
+        "xyz.openbmc_project.ObjectMapper", "GetObject", biosConfigObj,
+        std::array<const char*, 1>{biosConfigIface});
+}
+
+/**
+ *@brief Reads the BIOS Base Table DBUS property and update the Bios Attributes
+ *response.
+ *
+ * @param[in,out]   asyncResp   Async HTTP response.
+ *
+ * @return None.
+ */
+static void
+    getBiosAttributes(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
+{
+    crow::connections::systemBus->async_method_call(
+        [asyncResp](const boost::system::error_code ec,
+                    const GetObjectType& objType) {
+            if (ec || objType.empty())
+            {
+               BMCWEB_LOG_ERROR << "GetObject for path " << biosConfigObj;
+               messages::internalError(asyncResp->res);
+                return;
+            }
+
+           const std::string& biosService = objType.begin()->first;
+            crow::connections::systemBus->async_method_call(
+                [asyncResp](
+                    const boost::system::error_code ec,
+                    const std::variant<BaseBIOSTable>& baseBiosTableResp) {
+                    if (ec)
+                    {
+                        BMCWEB_LOG_ERROR
+                            << "Get BaseBIOSTable DBus response error" << ec;
+                        messages::internalError(asyncResp->res);
+                        return;
+                    }
+
+                    const BaseBIOSTable* baseBiosTable =
+                        std::get_if<BaseBIOSTable>(&baseBiosTableResp);
+
+                    nlohmann::json& attributesJson =
+                        asyncResp->res.jsonValue["Attributes"];
+                    if (baseBiosTable == nullptr)
+                    {
+                        BMCWEB_LOG_ERROR << "Empty BaseBIOSTable";
+                        messages::internalError(asyncResp->res);
+                        return;
+                    }
+                    for (const BaseBIOSTableItem& attrIt : *baseBiosTable)
+                    {
+                        const std::string& attr = attrIt.first;
+
+                        // read the attribute type at 0th field and convert from
+                        // dbus to string format
+                        std::string attrType = getBiosAttrType(std::string(
+                            std::get<BaseBiosTableIndex::baseBiosAttrType>(
+                                attrIt.second)));
+                        if ((attrType == "String") ||
+                            (attrType == "Enumeration"))
+                        {
+                            // read the current value of attribute at 5th field
+                            const std::string* attrCurrValue =
+                                std::get_if<std::string>(
+                                    &std::get<
+                                        BaseBiosTableIndex::baseBiosCurrValue>(
+                                        attrIt.second));
+                            if (attrCurrValue != nullptr)
+                            {
+                                attributesJson.emplace(attr, *attrCurrValue);
+                            }
+                            else
+                            {
+                               attributesJson.emplace(attr, std::string(""));
+                            }
+                        }
+                        else if ((attrType == "Integer") ||
+                                (attrType == "Boolean"))
+                        {
+                            // read the current value of attribute at 5th field
+                            const int64_t* attrCurrValue = std::get_if<int64_t>(
+                                &std::get<
+                                    BaseBiosTableIndex::baseBiosCurrValue>(
+                                    attrIt.second));
+                            if (attrCurrValue != nullptr)
+                            {
+                                if (attrType == "Boolean")
+                                {
+                                   if (*attrCurrValue)
+                                    {
+                                       attributesJson.emplace(attr, true);
+                                    }
+                                    else
+                                    {
+                                        attributesJson.emplace(attr, false);
+                                    }
+                                }
+                                else
+                                {
+                                    attributesJson.emplace(attr,
+                                                           *attrCurrValue);
+                                }
+                            }
+                            else
+                            {
+                                if (attrType == "Boolean")
+                                {
+                                    attributesJson.emplace(attr, false);
+                                }
+                                else
+                                {
+                                    attributesJson.emplace(attr, 0);
+                                }
+                            }
+                        }
+                        else
+                        {
+                            BMCWEB_LOG_ERROR << "Attribute type not supported";
+                        }
+                   }
+                },
+                biosService, biosConfigObj, "org.freedesktop.DBus.Properties",
+                "Get", biosConfigIface, "BaseBIOSTable");
+        },
+        "xyz.openbmc_project.ObjectMapper",
+        "/xyz/openbmc_project/object_mapper",
+        "xyz.openbmc_project.ObjectMapper", "GetObject", biosConfigObj,
+        std::array<const char*, 1>{biosConfigIface});
+}
+
+/**
+ *@brief Validates the requested BIOS Base Table JSON with the required
+ *attribute format.
+ *
+ * @param[in]      attrJson    BIOS Attribute JSON
+ * @param[in,out]   asyncResp   Async HTTP response.
+ *
+ * @return Returns as a bool flag, true if attribute json is in valid format,
+ * or else returns false.
+ */
+static bool isValidAttrJson(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                            const nlohmann::json& attrJson)
+{
+    std::vector<std::string> keys{
+        "AttributeName", "CurrentValue", "DefaultValue",
+        "DisplayName",   "Description",  "MenuPath",
+        "ReadOnly",      "Type",         "Values"};
+    std::vector<std::string> boundKeys{"LowerBound", "UpperBound",
+                                       "ScalarIncrement"};
+
+    for (const auto& key : keys)
+    {
+        if (!attrJson.contains(key))
+	{
+            if (key == "Values")
+            {
+                // If Type is Integer, then check for the bound values
+                if (attrJson[keys.at(7)] == "Integer")
+                {
+                    for (const auto& boundKey : boundKeys)
+                    {
+                        if (!attrJson.contains(boundKey))
+                        {
+                           messages::propertyMissing(asyncResp->res, boundKey);
+                            BMCWEB_LOG_ERROR
+                                << "Required propery missing in req!";
+                            return false;
+                        }
+                    }
+                }
+                else
+                {
+                    messages::propertyMissing(asyncResp->res, key);
+                    BMCWEB_LOG_ERROR << "Required propery missing in req!";
+                    return false;
+                }
+            }
+        }
+    }
+
+    if (attrJson[keys.at(0)] == "")
+    {
+        messages::propertyValueIncorrect(asyncResp->res, keys.at(0), "empty");
+        BMCWEB_LOG_ERROR << "AttributeName is not valid in req!";
+        return false;
+    }
+    return true;
+}
+
+/**
+ *@brief Sets the BIOS Base Table DBUS property with requested BIOS default
+ *attributes.
+ *
+ * @param[in]      baseBiosTableJson BIOS Base Table default Attribute details
+ * @param[in,out]   asyncResp   Async HTTP response.
+ *
+ * @return Returns None.
+ */
+static void fillBiosTable(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                          const std::vector<nlohmann::json>& baseBiosTableJson)
+{
+    BaseBIOSTable baseBiosTable;
+    for (const nlohmann::json& attrJson : baseBiosTableJson)
+    {
+        // Check all the fields are present
+        if (!isValidAttrJson(asyncResp, attrJson))
+        {
+            BMCWEB_LOG_ERROR << "Req attributes are missing!";
+            return;
+        }
+        std::string attr;
+        std::string attrDispName;
+        std::string attrDescr;
+        std::string attrMenuPath;
+        std::string attrType;
+        bool attrReadOnly;
+        std::vector<std::tuple<std::string, std::variant<int64_t, std::string>>>
+            attrValues;
+
+        attr = attrJson["AttributeName"].get<std::string>();
+        attrDispName = attrJson["DisplayName"].get<std::string>();
+        attrDescr = attrJson["Description"].get<std::string>();
+        attrMenuPath = attrJson["MenuPath"].get<std::string>();
+        attrType = attrJson["Type"].get<std::string>();
+        attrReadOnly = attrJson["ReadOnly"].get<bool>();
+
+        if ((attrType == "String") || (attrType == "Enumeration"))
+        {
+            std::string currVal = attrJson["CurrentValue"].get<std::string>();
+            std::string defaultVal =
+                attrJson["DefaultValue"].get<std::string>();
+ 
+            // read and update the bound values
+            for (const auto& value :
+                attrJson["Values"].get<std::vector<std::string>>())
+            {
+                attrValues.emplace_back(
+                    "xyz.openbmc_project.BIOSConfig.Manager.BoundType.OneOf",
+                    value);
+            }
+            attrType = getDbusBiosAttrType(attrType);
+            baseBiosTable.insert(std::make_pair(
+                attr, std::make_tuple(attrType, attrReadOnly, attrDispName,
+                                      attrDescr, attrMenuPath, currVal,
+                                      defaultVal, attrValues)));
+        }
+        else if (attrType == "Integer")
+        {
+            int64_t currVal = attrJson["CurrentValue"].get<int64_t>();
+            int64_t defaultVal = attrJson["DefaultValue"].get<int64_t>();
+
+            // read and update the bound values
+            attrValues.emplace_back(
+                "xyz.openbmc_project.BIOSConfig.Manager.BoundType.LowerBound",
+               attrJson["LowerBound"].get<int64_t>());
+            attrValues.emplace_back(
+                "xyz.openbmc_project.BIOSConfig.Manager.BoundType.UpperBound",
+                attrJson["UpperBound"].get<int64_t>());
+           attrValues.emplace_back(
+                "xyz.openbmc_project.BIOSConfig.Manager.BoundType.ScalarIncrement",
+               attrJson["ScalarIncrement"].get<int64_t>());
+
+            attrType = getDbusBiosAttrType(attrType);
+            baseBiosTable.insert(std::make_pair(
+                attr, std::make_tuple(attrType, attrReadOnly, attrDispName,
+                                      attrDescr, attrMenuPath, currVal,
+                                      defaultVal, attrValues)));
+        }
+        else if (attrType == "Boolean")
+        {
+            // for Boolean type, BaseBIOSTable DBus method will expect the data
+            // in the int64_t type
+            int64_t currVal =
+                static_cast<int64_t>(attrJson["CurrentValue"].get<bool>());
+            int64_t defaultVal =
+                static_cast<int64_t>(attrJson["DefaultValue"].get<bool>());
+
+            // read and update the bound values
+            for (const auto& value :
+                 attrJson["Values"].get<std::vector<bool>>())
+            {
+                attrValues.emplace_back(
+                    "xyz.openbmc_project.BIOSConfig.Manager.BoundType.OneOf",
+                    (value == true ? 1 : 0));
+            }
+            attrType = getDbusBiosAttrType(attrType);
+            baseBiosTable.insert(std::make_pair(
+                attr, std::make_tuple(attrType, attrReadOnly, attrDispName,
+                                      attrDescr, attrMenuPath, currVal,
+                                      defaultVal, attrValues)));
+        }
+        else
+        {
+            messages::propertyValueIncorrect(asyncResp->res, "Type", "UNKNOWN");
+            BMCWEB_LOG_ERROR << "Attribute Type is not valid in req!";
+            return;
+        }
+    }
+
+    if (baseBiosTable.empty())
+    {
+        BMCWEB_LOG_ERROR << "Base Bios Table empty";
+        messages::invalidObject(asyncResp->res, boost::urls::format("Attributes"));
+    }
+
+    crow::connections::systemBus->async_method_call(
+        [asyncResp, baseBiosTable](const boost::system::error_code ec) {
+            if (ec)
+            {
+                BMCWEB_LOG_DEBUG << "Error occurred in setting BaseBIOSTable";
+                messages::internalError(asyncResp->res);
+                return;
+            }
+
+            messages::success(asyncResp->res);
+        },
+        "xyz.openbmc_project.BIOSConfigManager",
+        "/xyz/openbmc_project/bios_config/manager",
+        "org.freedesktop.DBus.Properties", "Set",
+        "xyz.openbmc_project.BIOSConfig.Manager", "BaseBIOSTable",
+        std::variant<BaseBIOSTable>(baseBiosTable));
+}
+
+/**
+ *@brief Reads the BIOS Pending Attributes, which are updated by oob the user
+ * and update the Bios Settings Attributes response.
+ *
+ * @param[in,out]   asyncResp   Async HTTP response.
+ *
+ * @return None.
+ */
+static void
+    getBiosSettingsAttr(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
+{
+    crow::connections::systemBus->async_method_call(
+        [asyncResp](const boost::system::error_code ec,
+                    const GetObjectType& objType) {
+            if (ec || objType.empty())
+	    {
+                BMCWEB_LOG_ERROR << "GetObject for path " << biosConfigObj;
+                messages::internalError(asyncResp->res);
+                return;
+            }
+
+            const std::string& biosService = objType.begin()->first;
+            crow::connections::systemBus->async_method_call(
+                [asyncResp](
+                    const boost::system::error_code ec,
+                    const std::variant<PendingAttrType>& pendingAttrsResp) {
+                    if (ec)
+                    {
+                        BMCWEB_LOG_ERROR
+                            << "Get PendingAttributes DBus response error"
+                            << ec;
+                        messages::internalError(asyncResp->res);
+                        return;
+                    }
+
+                    const PendingAttrType* pendingAttrs =
+                        std::get_if<PendingAttrType>(&pendingAttrsResp);
+
+                    nlohmann::json& attributesJson =
+                        asyncResp->res.jsonValue["Attributes"];
+                    if (pendingAttrs == nullptr)
+                    {
+                        BMCWEB_LOG_ERROR << "Empty Pending Attributes";
+                        messages::internalError(asyncResp->res);
+                        return;
+                    }
+
+                    for (const PendingAttrItemType& attrIt : *pendingAttrs)
+                    {
+                        const std::string& attr = attrIt.first;
+
+                        // read the attribute type at 0th field and convert from
+                        // dbus to string format
+                        std::string attrType = getBiosAttrType(std::string(
+                            std::get<BiosPendingAttributesIndex::
+                                         biosPendingAttrType>(attrIt.second)));
+                        if ((attrType == "String") ||
+                            (attrType == "Enumeration"))
+                       {
+                            // read the current value of attribute at 1st field
+                            const std::string* attrCurrValue =
+                                std::get_if<std::string>(
+                                   &std::get<BiosPendingAttributesIndex::
+                                                  biosPendingAttrValue>(
+                                        attrIt.second));
+                            if (attrCurrValue != nullptr)
+                            {
+                                attributesJson.emplace(attr, *attrCurrValue);
+                            }
+                            else
+                            {
+                                attributesJson.emplace(attr, std::string(""));
+                            }
+                        }
+                        else if ((attrType == "Integer") ||
+                                 (attrType == "Boolean"))
+                        {
+                            // read the current value of attribute at 1st field
+                            const int64_t* attrCurrValue = std::get_if<int64_t>(
+                                &std::get<BiosPendingAttributesIndex::
+                                              biosPendingAttrValue>(
+                                    attrIt.second));
+                            if (attrCurrValue != nullptr)
+                            {
+                                if (attrType == "Boolean")
+                                {
+                                    if (*attrCurrValue)
+                                    {
+                                        attributesJson.emplace(attr, true);
+                                    }
+                                    else
+                                    {
+                                        attributesJson.emplace(attr, false);
+                                    }
+                                }
+                                else
+                                {
+                                    attributesJson.emplace(attr,
+                                                           *attrCurrValue);
+                                }
+                            }
+                            else
+                            {
+                                if (attrType == "Boolean")
+                                {
+                                    attributesJson.emplace(attr, false);
+                                }
+                                else
+                                {
+                                    attributesJson.emplace(attr, 0);
+                                }
+                            }
+                        }
+                        else
+                        {
+                            BMCWEB_LOG_ERROR << "Attribute type not supported";
+                        }
+                    }
+                },
+                biosService, biosConfigObj, "org.freedesktop.DBus.Properties",
+                "Get", biosConfigIface, "PendingAttributes");
+        },
+        "xyz.openbmc_project.ObjectMapper",
+        "/xyz/openbmc_project/object_mapper",
+        "xyz.openbmc_project.ObjectMapper", "GetObject", biosConfigObj,
+        std::array<const char*, 1>{biosConfigIface});
+}
+
+/**
+ *@brief Updates the BIOS Pending Attributes DBUS property, which are requested
+ *by the oob user.
+ *
+ * @param[in,out]   asyncResp   Async HTTP response.
+ *
+ * @return None.
+ */
+static void
+    setBiosPendingAttr(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                       const nlohmann::json& pendingAttrJson)
+{
+    crow::connections::systemBus->async_method_call(
+        [asyncResp, pendingAttrJson](const boost::system::error_code ec,
+                                     const GetObjectType& objType) {
+            if (ec || objType.empty())
+	    {
+                BMCWEB_LOG_ERROR << "GetObject for path " << biosConfigObj;
+                messages::internalError(asyncResp->res);
+                return;
+           }
+            const std::string& biosService = objType.begin()->first;
+            crow::connections::systemBus->async_method_call(
+                [asyncResp, pendingAttrJson, biosService](
+                    const boost::system::error_code ec,
+                    const std::variant<BaseBIOSTable>& baseBiosTableResp) {
+                    if (ec)
+                    {
+                        BMCWEB_LOG_ERROR
+                            << "Get BaseBIOSTable DBus response error" << ec;
+                        messages::internalError(asyncResp->res);
+                       return;
+                    }
+
+                    const BaseBIOSTable* baseBiosTable =
+                        std::get_if<BaseBIOSTable>(&baseBiosTableResp);
+
+                    if (baseBiosTable == nullptr)
+                    {
+                        BMCWEB_LOG_ERROR << "Empty BaseBIOSTable";
+                       messages::internalError(asyncResp->res);
+                      return;
+                   }
+
+                   PendingAttrType pendingAttrs{};
+                   for (const auto& pendingAttrIt : pendingAttrJson.items())
+                    {
+
+                        // Check whether the requested attribute is available
+                        // inside BaseBIOSTable or not
+                        auto attrIt = baseBiosTable->find(pendingAttrIt.key());
+                       if (attrIt == baseBiosTable->end())
+                        {
+                            BMCWEB_LOG_ERROR << "Not Found Attribute "
+                                             << pendingAttrIt.key();
+                            messages::propertyValueNotInList(
+                               asyncResp->res, pendingAttrIt.key(),
+                                "Attributes");
+                            return;
+                        }
+
+                        // read the attribute type at 0th field and convert from
+                        // dbus to string format
+                        std::string attrItType =
+                            std::get<BaseBiosTableIndex::baseBiosAttrType>(
+                                attrIt->second);
+                        std::string attrType = getBiosAttrType(attrItType);
+                        if ((attrType == "String") ||
+                            (attrType == "Enumeration"))
+                        {
+
+                            std::string attrReqVal = pendingAttrIt.value();
+                            // read the bound values for the attribute
+                            const std::vector<AttrBoundType> boundValues =
+                                std::get<
+                                    BaseBiosTableIndex::baseBiosBoundValues>(
+                                   attrIt->second);
+                            auto found = std::find_if(
+                                boundValues.begin(), boundValues.end(),
+                               [attrReqVal](
+                                    const AttrBoundType& boundValueIt) {
+                                    // read the bound value type at 0th field
+                                    // and convert from dbus to string format
+                                    std::string boundValType =
+                                        getBiosBoundValType(std::string(
+                                            std::get<BaseBiosBoundIndex::
+                                                         baseBiosBoundType>(
+                                                boundValueIt)));
+
+                                    if (boundValType == "OneOf")
+                                    {
+                                        // read the bound value  at 1st field
+                                        // for each entry
+                                        const std::string* currBoundVal =
+                                            std::get_if<std::string>(
+                                                &std::get<
+                                                    BaseBiosBoundIndex::
+                                                        baseBiosBoundValue>(
+                                                    boundValueIt));
+                                        if (currBoundVal == nullptr)
+                                        {
+                                            BMCWEB_LOG_ERROR
+                                                << "Bound Value not found";
+                                            return false;
+                                        }
+
+                                        return (attrReqVal == *currBoundVal)
+                                                   ? true
+                                                   : false;
+                                    }
+                                    else
+                                    {
+                                        return false;
+                                    }
+                                });
+
+                            if (found == boundValues.end())
+                            {
+                               BMCWEB_LOG_ERROR
+                                    << "Requested Attribute Value invalid";
+                                messages::internalError(asyncResp->res);
+                                return;
+                            }
+                            pendingAttrs.insert(std::make_pair(
+                                pendingAttrIt.key(),
+                                std::make_tuple(attrItType, attrReqVal)));
+                        }
+                        else if (attrType == "Boolean")
+                        {
+
+                            int64_t attrReqVal = static_cast<int64_t>(
+                                pendingAttrIt.value().get<bool>());
+                            // read the bound values for the attribute
+                            const std::vector<AttrBoundType> boundValues =
+                                std::get<
+                                    BaseBiosTableIndex::baseBiosBoundValues>(
+                                    attrIt->second);
+
+                            auto found = std::find_if(
+                                boundValues.begin(), boundValues.end(),
+                                [attrReqVal](
+                                    const AttrBoundType& boundValueIt) {
+                                    // read the bound value type at 0th field
+                                    // and convert from dbus to string format
+                                   std::string boundValType =
+                                        getBiosBoundValType(std::string(
+                                            std::get<BaseBiosBoundIndex::
+                                                         baseBiosBoundType>(
+                                                boundValueIt)));
+                                  if (boundValType == "OneOf")
+                                    {
+                                       // read the bound value  at 1st field
+                                        // for each entry
+                                        const int64_t* currBoundVal =
+                                            std::get_if<int64_t>(
+                                                &std::get<
+                                                    BaseBiosBoundIndex::
+                                                        baseBiosBoundValue>(
+                                                   boundValueIt));
+
+                                        if (currBoundVal == nullptr)
+                                        {
+                                            BMCWEB_LOG_ERROR
+                                                << "Bound Value not found";
+                                            return false;
+                                        }
+                                        return (attrReqVal == *currBoundVal)
+                                                   ? true
+                                                   : false;
+                                    }
+                                    else
+                                    {
+                                        return false;
+                                    }
+                                });
+
+                            if (found == boundValues.end())
+                           {
+                                BMCWEB_LOG_ERROR
+                                    << "Requested Attribute Value invalid";
+                                messages::internalError(asyncResp->res);
+                                return;
+                            }
+                            pendingAttrs.insert(std::make_pair(
+                                pendingAttrIt.key(),
+                                std::make_tuple(attrItType, attrReqVal)));
+                        }
+                        else if (attrType == "Integer")
+                        {
+                            int64_t attrReqVal = pendingAttrIt.value();
+                            pendingAttrs.emplace(
+                                pendingAttrIt.key(),
+                                std::make_tuple(attrItType, attrReqVal));
+                        }
+                        else
+                       {
+                            BMCWEB_LOG_ERROR << "Unknown Attribute Type"
+                                             << attrType;
+                           messages::internalError(asyncResp->res);
+                           return;
+                        }
+                    }
+
+                    if (pendingAttrs.empty())
+                    {
+                        BMCWEB_LOG_ERROR << "PendingAttributes empty";
+                        messages::invalidObject(asyncResp->res, boost::urls::format("Attributes"));
+                    }
+
+                    crow::connections::systemBus->async_method_call(
+                       [asyncResp](const boost::system::error_code ec) {
+                            if (ec)
+                            {
+                                BMCWEB_LOG_ERROR
+                                    << "Set PendingAttributes failed " << ec;
+                                messages::internalError(asyncResp->res);
+                                return;
+                            }
+
+                            messages::success(asyncResp->res);
+                        },
+                       biosService, biosConfigObj,
+                        "org.freedesktop.DBus.Properties", "Set",
+                        biosConfigIface, "PendingAttributes",
+                        std::variant<PendingAttrType>(pendingAttrs));
+                },
+               biosService, biosConfigObj, "org.freedesktop.DBus.Properties",
+                "Get", biosConfigIface, "BaseBIOSTable");
+        },
+        "xyz.openbmc_project.ObjectMapper",
+        "/xyz/openbmc_project/object_mapper",
+        "xyz.openbmc_project.ObjectMapper", "GetObject", biosConfigObj,
+        std::array<const char*, 1>{biosConfigIface});
+}
+
+/**
+ *@brief Reads the BIOS Base Table DBUS property and update the Bios Attribute
+ *Registry response.
+ *
+ * @param[in,out]   asyncResp   Async HTTP response.
+ *
+ * @return None.
+ */
+static void getBiosAttributeRegistry(
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
+{
+    crow::connections::systemBus->async_method_call(
+        [asyncResp](const boost::system::error_code ec,
+                    const GetObjectType& objType) {
+            if (ec || objType.empty())
+            {
+                BMCWEB_LOG_ERROR << "GetObject for path " << biosConfigObj;
+                return;
+            }
+
+            const std::string& biosService = objType.begin()->first;
+            crow::connections::systemBus->async_method_call(
+                [asyncResp](
+                    const boost::system::error_code ec,
+                    const std::variant<BaseBIOSTable>& baseBiosTableResp) {
+                    if (ec)
+                    {
+                        BMCWEB_LOG_ERROR
+                            << "Get BaseBIOSTable DBus response error" << ec;
+                        messages::internalError(asyncResp->res);
+                        return;
+                    }
+
+                    const BaseBIOSTable* baseBiosTable =
+                        std::get_if<BaseBIOSTable>(&baseBiosTableResp);
+
+                    nlohmann::json& attributeArray =
+                        asyncResp->res
+                            .jsonValue["RegistryEntries"]["Attributes"];
+
+                    if (baseBiosTable == nullptr)
+                    {
+                        BMCWEB_LOG_ERROR << "Empty BaseBIOSTable";
+                        messages::internalError(asyncResp->res);
+                        return;
+                    }
+                    for (const BaseBIOSTableItem& attrIt : *baseBiosTable)
+                    {
+                        // read the attribute type at 0th field and convert from
+                        // dbus to string format
+                        std::string attrType = getBiosAttrType(std::string(
+                            std::get<BaseBiosTableIndex::baseBiosAttrType>(
+                                attrIt.second)));
+
+                        if (attrType == "UNKNOWN")
+                        {
+                            BMCWEB_LOG_ERROR << "Attribute type not supported";
+                            continue;
+                        }
+                        nlohmann::json attributeIt;
+                        attributeIt["AttributeName"] = attrIt.first;
+                        attributeIt["Type"] = attrType;
+                        attributeIt["ReadOnly"] = std::get<
+                            BaseBiosTableIndex::baseBiosReadonlyStatus>(
+                            attrIt.second);
+                        attributeIt["DisplayName"] =
+                            std::get<BaseBiosTableIndex::baseBiosDisplayName>(
+                                attrIt.second);
+                        const std::string& helpText =
+                            std::get<BaseBiosTableIndex::baseBiosDescription>(
+                                attrIt.second);
+                        if (!helpText.empty())
+                        {
+                            attributeIt["HelpText"] = helpText;
+                        }
+                        attributeIt["MenuPath"] =
+                            std::get<BaseBiosTableIndex::baseBiosMenuPath>(
+                                attrIt.second);
+
+                        if ((attrType == "String") ||
+                            (attrType == "Enumeration"))
+                        {
+                            // read the current value of attribute at 5th field
+                            const std::string* attrCurrValue =
+                                std::get_if<std::string>(
+                                    &std::get<
+                                        BaseBiosTableIndex::baseBiosCurrValue>(
+                                        attrIt.second));
+                            if (attrCurrValue != nullptr)
+                            {
+                                attributeIt["CurrentValue"] = *attrCurrValue;
+                            }
+                            else
+                            {
+                                attributeIt["CurrentValue"] = "";
+                            }
+
+                            // read the default value of attribute at 6th field
+                            const std::string* attrDefaultValue = std::get_if<
+                                std::string>(
+                                &std::get<
+                                    BaseBiosTableIndex::baseBiosDefaultValue>(
+                                    attrIt.second));
+                            if (attrDefaultValue != nullptr)
+                            {
+                                attributeIt["DefaultValue"] = *attrDefaultValue;
+                            }
+                            else
+                            {
+                                attributeIt["DefaultValue"] = "";
+                            }
+                        }
+                        else if ((attrType == "Integer") ||
+                                 (attrType == "Boolean"))
+                        {
+                            // read the current value of attribute at 5th field
+                            const int64_t* attrCurrValue = std::get_if<int64_t>(
+                                &std::get<
+                                    BaseBiosTableIndex::baseBiosCurrValue>(
+                                    attrIt.second));
+                            if (attrCurrValue != nullptr)
+                            {
+                               if (attrType == "Boolean")
+                                {
+                                    if (*attrCurrValue)
+                                    {
+                                        attributeIt["CurrentValue"] = true;
+                                    }
+                                    else
+                                    {
+                                        attributeIt["CurrentValue"] = false;
+                                    }
+                                }
+                                else
+                                {
+                                    attributeIt["CurrentValue"] =
+                                        *attrCurrValue;
+                                }
+                            }
+                            else
+                            {
+                                if (attrType == "Boolean")
+                                {
+                                    attributeIt["CurrentValue"] = false;
+                                }
+                                else
+                                {
+                                    attributeIt["CurrentValue"] = 0;
+                                }
+                            }
+
+                            // read the current value of attribute at 6th field
+                            const int64_t* attrDefaultValue = std::get_if<
+                                int64_t>(
+                                &std::get<
+                                    BaseBiosTableIndex::baseBiosDefaultValue>(
+                                    attrIt.second));
+                            if (attrDefaultValue != nullptr)
+                           {
+                                if (attrType == "Boolean")
+                                {
+                                    if (*attrDefaultValue)
+                                    {
+                                        attributeIt["DefaultValue"] = true;
+                                    }
+                                    else
+                                    {
+                                        attributeIt["DefaultValue"] = false;
+                                    }
+                                }
+                                else
+                                {
+                                    attributeIt["DefaultValue"] =
+                                        *attrDefaultValue;
+                                }
+                            }
+                            else
+                            {
+                                if (attrType == "Boolean")
+                                {
+                                    attributeIt["DefaultValue"] = false;
+                                }
+                                else
+                                {
+                                    attributeIt["DefaultValue"] = 0;
+                                }
+                            }
+                        }
+
+                        nlohmann::json boundValArray = nlohmann::json::array();
+
+                        // read the bound values for the attribute
+                        const std::vector<AttrBoundType> boundValues =
+                            std::get<BaseBiosTableIndex::baseBiosBoundValues>(
+                                attrIt.second);
+
+                        for (const AttrBoundType& boundValueIt : boundValues)
+                        {
+                            nlohmann::json boundValJson;
+
+                            // read the bound value type at 0th field
+                            // and convert from dbus to string format
+                            std::string boundValType =
+                                getBiosBoundValType(std::string(
+                                    std::get<
+                                        BaseBiosBoundIndex::baseBiosBoundType>(
+                                        boundValueIt)));
+
+                            if (boundValType == "UNKNOWN")
+                            {
+                                BMCWEB_LOG_ERROR
+                                    << "Attribute type not supported";
+                                continue;
+                            }
+
+                            if (boundValType == "OneOf")
+                            {
+                                if ((attrType == "String") ||
+                                    (attrType == "Enumeration"))
+                                {
+                                    // read the bound value  at 1st field
+                                    // for each entry
+                                    const std::string* currBoundVal =
+                                        std::get_if<std::string>(
+                                            &std::get<BaseBiosBoundIndex::
+                                                          baseBiosBoundValue>(
+                                                boundValueIt));
+                                    if (currBoundVal != nullptr)
+                                    {
+                                        boundValJson["ValueName"] =
+                                            *currBoundVal;
+                                    }
+                                    else
+                                   {
+                                        boundValJson["ValueName"] = "";
+                                    }
+                                }
+                                else if (attrType == "Boolean")
+                                {
+                                    // read the bound value  at 1st field
+                                    // for each entry
+                                    const int64_t* currBoundVal =
+                                        std::get_if<int64_t>(
+                                            &std::get<BaseBiosBoundIndex::
+                                                          baseBiosBoundValue>(
+                                                boundValueIt));
+                                    if (currBoundVal != nullptr)
+                                    {
+                                        if (*currBoundVal)
+                                        {
+                                            boundValJson["ValueName"] = true;
+                                        }
+                                        else
+                                        {
+                                            boundValJson["ValueName"] = false;
+                                        }
+                                    }
+                                    else
+                                   {
+                                        boundValJson["ValueName"] = false;
+                                    }
+                                }
+                                else
+                                {
+                                    continue;
+                                }
+                            }
+                            else if (boundValType == "LowerBound")
+                            {
+                                const int64_t* currBoundVal = std::get_if<
+                                    int64_t>(
+                                    &std::get<
+                                        BaseBiosBoundIndex::baseBiosBoundValue>(
+                                        boundValueIt));
+                                if (currBoundVal != nullptr)
+                                {
+                                    attributeIt["LowerBound"] = *currBoundVal;
+                                }
+                                else
+                                {
+                                    attributeIt["LowerBound"] = 0;
+                                }
+                            }
+                            else if (boundValType == "UpperBound")
+                           {
+                                const int64_t* currBoundVal = std::get_if<
+                                    int64_t>(
+                                   &std::get<
+                                        BaseBiosBoundIndex::baseBiosBoundValue>(
+                                        boundValueIt));
+                                if (currBoundVal != nullptr)
+                                {
+                                    attributeIt["UpperBound"] = *currBoundVal;
+                                }
+                                else
+                                {
+                                    attributeIt["UpperBound"] = 0;
+                                }
+                            }
+                            else if (boundValType == "ScalarIncrement")
+                           {
+                                const int64_t* currBoundVal = std::get_if<
+                                    int64_t>(
+                                   &std::get<
+                                        BaseBiosBoundIndex::baseBiosBoundValue>(
+                                        boundValueIt));
+                                if (currBoundVal != nullptr)
+                                {
+                                    attributeIt["ScalarIncrement"] =
+                                        *currBoundVal;
+                                }
+                                else
+                                {
+                                    attributeIt["ScalarIncrement"] = 0;
+                                }
+                            }
+                            else
+                            {
+                               // read the bound value  at 1st field
+                                // for each entry
+                                const int64_t* currBoundVal = std::get_if<
+                                    int64_t>(
+                                   &std::get<
+                                        BaseBiosBoundIndex::baseBiosBoundValue>(
+                                        boundValueIt));
+                                if (currBoundVal != nullptr)
+                                {
+                                    boundValJson["ValueName"] = *currBoundVal;
+                                }
+                                else
+                                {
+                                    boundValJson["ValueName"] = 0;
+                                }
+                            }
+                            boundValArray.push_back(boundValJson);
+                        }
+
+                        if (boundValArray.empty())
+                        {
+                            BMCWEB_LOG_ERROR << "Bound Values Array is empty";
+                            continue;
+                        }
+                        if (attrType != "Integer")
+                        {
+                            attributeIt["Value"] = boundValArray;
+                        }
+                        attributeArray.push_back(attributeIt);
+                    }
+                },
+                biosService, biosConfigObj, "org.freedesktop.DBus.Properties",
+                "Get", biosConfigIface, "BaseBIOSTable");
+
+        },
+        "xyz.openbmc_project.ObjectMapper",
+        "/xyz/openbmc_project/object_mapper",
+        "xyz.openbmc_project.ObjectMapper", "GetObject", biosConfigObj,
+        std::array<const char*, 1>{biosConfigIface});
+}
+} // namespace bios
+
+/**
+ * BiosService class supports handle put method for bios.
  */
 inline void
-    handleBiosServiceGet(crow::App& app, const crow::Request& req,
-                         const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
-                         const std::string& systemName)
+    handleBiosServicePut(const crow::Request& req,
+                         const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
 {
-    if (!redfish::setUpRedfishRoute(app, req, asyncResp))
+    crow::connections::systemBus->async_method_call(
+        [req,
+         asyncResp](const boost::system::error_code ec,
+                    const std::map<std::string, dbus::utility::DbusVariantType>&
+                        userInfo) {
+            if (ec)
+            {
+                BMCWEB_LOG_ERROR << "GetUserInfo failed";
+                messages::internalError(asyncResp->res);
+                return;
+            }
+
+            const std::vector<std::string>* userGroupPtr = nullptr;
+            auto userInfoIter = userInfo.find("UserGroups");
+            if (userInfoIter != userInfo.end())
+            {
+                userGroupPtr = std::get_if<std::vector<std::string>>(
+
+                    &userInfoIter->second);
+            }
+
+            if (userGroupPtr == nullptr)
+            {
+                BMCWEB_LOG_ERROR << "User Group not found";
+                messages::internalError(asyncResp->res);
+                return;
+            }
+
+            auto found = std::find_if(
+                userGroupPtr->begin(), userGroupPtr->end(),
+                [](const auto& group) {
+                    return (group == "redfish-hostiface") ? true : false;
+               });
+
+            // Only Host Iface (redfish-hostiface) group user should
+            // perform PUT operations
+            if (found == userGroupPtr->end())
+            {
+                BMCWEB_LOG_ERROR << "Not Sufficient Privilage";
+                messages::insufficientPrivilege(asyncResp->res);
+                return;
+            }
+            std::vector<nlohmann::json> baseBiosTableJson;
+            if (!redfish::json_util::readJsonAction(req, asyncResp->res, "Attributes",
+                                              baseBiosTableJson))
+            {
+               BMCWEB_LOG_ERROR << "No 'Attributes' found";
+                messages::unrecognizedRequestBody(asyncResp->res);
+                return;
+            }
+
+            if (baseBiosTableJson.empty())
+            {
+                messages::invalidObject(asyncResp->res, boost::urls::format("Attributes"));
+                BMCWEB_LOG_ERROR << "No input in req!";
+                return;
+          }
+
+            // Set the BaseBIOSTable
+           bios::fillBiosTable(asyncResp, baseBiosTableJson);
+        },
+        "xyz.openbmc_project.User.Manager", "/xyz/openbmc_project/user",
+        "xyz.openbmc_project.User.Manager", "GetUserInfo",
+        req.session->username);
+}
+
+/**
+ * BiosService class supports handle patch method for bios.
+ */
+inline void
+    handleBiosServicePatch(const crow::Request& req,
+                           const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
+{
+
+    std::optional<bool> resetBiosToDefaultsPending;
+    if (!json_util::readJsonPatch(req, asyncResp->res, "ResetBiosToDefaultsPending",
+                             resetBiosToDefaultsPending))
     {
+        BMCWEB_LOG_ERROR << "No 'ResetBiosToDefaultsPending' found";
+        messages::unrecognizedRequestBody(asyncResp->res);
         return;
     }
-    if (systemName != "system")
+
+    if (resetBiosToDefaultsPending)
     {
-        messages::resourceNotFound(asyncResp->res, "ComputerSystem",
-                                   systemName);
-        return;
+        // set the ResetBiosToDefaultsPending
+        bios::setResetBiosSettings(asyncResp, *resetBiosToDefaultsPending);
     }
-    asyncResp->res.jsonValue["@odata.id"] = "/redfish/v1/Systems/system/Bios";
+}
+
+/**
+ * BiosService class supports handle get method for bios.
+ */
+inline void
+    handleBiosServiceGet(const crow::Request&,
+                         const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
+{
+      asyncResp->res.jsonValue["@odata.id"] =
+        "/redfish/v1/Systems/system/Bios";
     asyncResp->res.jsonValue["@odata.type"] = "#Bios.v1_1_0.Bios";
     asyncResp->res.jsonValue["Name"] = "BIOS Configuration";
     asyncResp->res.jsonValue["Description"] = "BIOS Configuration Service";
@@ -158,104 +1524,90 @@ inline void
     asyncResp->res.jsonValue["Actions"]["#Bios.ResetBios"] = {
         {"target", "/redfish/v1/Systems/system/Bios/Actions/Bios.ResetBios"}};
 
-    asyncResp->res.jsonValue["Actions"]["#Bios.ChangePassword"] = {
-        {"target", "/redfish/v1/Systems/system/Bios/Actions/"
-                   "Bios.ChangePassword"}};
-
     // Get the ActiveSoftwareImage and SoftwareImages
     sw_util::populateSoftwareInformation(asyncResp, sw_util::biosPurpose, "",
                                          true);
 
-    asyncResp->res.jsonValue["@Redfish.Settings"] = {
-        {"@odata.type", "#Settings.v1_3_0.Settings"},
-        {"SettingsObject",
-         {{"@odata.id", "/redfish/v1/Systems/system/Bios/Settings"}}}};
-    asyncResp->res.jsonValue["AttributeRegistry"] = "BiosAttributeRegistry";
-    asyncResp->res.jsonValue["Attributes"] = nlohmann::json::object();
+    asyncResp->res.jsonValue["Attributes"] = {};
+    // Get the BIOS Attributes
+    bios::getBiosAttributes(asyncResp);
 
-    crow::connections::systemBus->async_method_call(
-        [asyncResp](const boost::system::error_code ec,
-                    const dbus::utility::MapperGetObject& getObjectType) {
-        if (ec)
-        {
-            BMCWEB_LOG_ERROR << "ObjectMapper::GetObject call failed: " << ec;
-            messages::internalError(asyncResp->res);
+    // Get the ResetBiosToDefaultsPending
+    bios::getResetBiosSettings(asyncResp);
 
-            return;
-        }
+}
 
-        if (getObjectType.empty())
-        {
-            BMCWEB_LOG_ERROR << "getObjectType is empty.";
-            messages::internalError(asyncResp->res);
+inline void requestRoutesBiosService(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Bios/")
+        .privileges(redfish::privileges::getBios)
+        .methods(boost::beast::http::verb::get)(handleBiosServiceGet);
+        BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Bios/")
+        .privileges(redfish::privileges::patchBios)
+        .methods(boost::beast::http::verb::patch)(handleBiosServicePatch);
 
-            return;
-        }
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Bios/")
+        .privileges(redfish::privileges::putBios)
+        .methods(boost::beast::http::verb::put)(handleBiosServicePut);
+}
+
+/**
+ * BiosSetting class supports handle patch method for Bios Settings.
+ */
+inline void
+    handleBiosSettingsPatch(const crow::Request& req,
+                            const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
+{
+
+    nlohmann::json pendingAttrJson;
+    if (!redfish::json_util::readJsonPatch(req, asyncResp->res, "Attributes",
+                                      pendingAttrJson))
+    {
+        BMCWEB_LOG_ERROR << "No 'Attributes' found";
+        messages::unrecognizedRequestBody(asyncResp->res);
+        return;
+    }
+
+    if (pendingAttrJson.empty())
+    {
+        messages::invalidObject(asyncResp->res, boost::urls::format("Attributes"));
+        BMCWEB_LOG_ERROR << "No input in req!";
+        return;
+    }
+
+    // Update the Pending Atttributes
+    bios::setBiosPendingAttr(asyncResp, pendingAttrJson);
+}
+
+/**
+ * BiosSetting class supports handle get method for Bios Settings.
+ */
+inline void
+    handleBiosSettingsGet(const crow::Request&,
+                          const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
+{
+    asyncResp->res.jsonValue["@odata.id"] =
+        "/redfish/v1/Systems/system/Bios/Settings";
+    asyncResp->res.jsonValue["@odata.type"] = "#Bios.v1_1_0.Bios";
+    asyncResp->res.jsonValue["Name"] = "BIOS Configuration";
+    asyncResp->res.jsonValue["Description"] = "BIOS Settings";
+    asyncResp->res.jsonValue["Id"] = "BIOS_Settings";
 
-        const std::string& service = getObjectType.begin()->first;
+    asyncResp->res.jsonValue["Attributes"] = {};
 
-        crow::connections::systemBus->async_method_call(
-            [asyncResp](const boost::system::error_code ec2,
-                        const std::variant<BiosBaseTableType>& retBiosTable) {
-            if (ec2)
-            {
-                BMCWEB_LOG_ERROR << "getBiosAttributes DBUS error: " << ec2;
-                messages::internalError(asyncResp->res);
-                return;
-            }
-            const BiosBaseTableType* baseBiosTable =
-                std::get_if<BiosBaseTableType>(&retBiosTable);
-            nlohmann::json& attributesJson =
-                asyncResp->res.jsonValue["Attributes"];
-            if (baseBiosTable == nullptr)
-            {
-                BMCWEB_LOG_ERROR << "baseBiosTable is empty";
-                messages::internalError(asyncResp->res);
-                return;
-            }
-            for (const BiosBaseTableItemType& item : *baseBiosTable)
-            {
-                const std::string& key = item.first;
-                const std::string& itemType =
-                    std::get<biosBaseAttrType>(item.second);
-                std::string attrType = mapAttrTypeToRedfish(itemType);
-                if (attrType == "String" || attrType == "Enumeration")
-                {
-                    const std::string* currValue = std::get_if<std::string>(
-                        &std::get<biosBaseCurrValue>(item.second));
-                    attributesJson.emplace(
-                        key, currValue != nullptr ? *currValue : "");
-                }
-                else if (attrType == "Integer")
-                {
-                    const int64_t* currValue = std::get_if<int64_t>(
-                        &std::get<biosBaseCurrValue>(item.second));
-                    attributesJson.emplace(
-                        key, currValue != nullptr ? *currValue : 0);
-                }
-                else
-                {
-                    BMCWEB_LOG_ERROR << "Unsupported attribute type.";
-                }
-            }
-            },
-            service, "/xyz/openbmc_project/bios_config/manager",
-            "org.freedesktop.DBus.Properties", "Get",
-            "xyz.openbmc_project.BIOSConfig.Manager", "BaseBIOSTable");
-        },
-        "xyz.openbmc_project.ObjectMapper",
-        "/xyz/openbmc_project/object_mapper",
-        "xyz.openbmc_project.ObjectMapper", "GetObject",
-        "/xyz/openbmc_project/bios_config/manager",
-        std::array<const char*, 0>());
+    // get the BIOS Attributes
+    bios::getBiosSettingsAttr(asyncResp);
 }
 
-inline void requestRoutesBiosService(App& app)
+inline void requestRoutesBiosSettings(App& app)
 {
-    BMCWEB_ROUTE(app, "/redfish/v1/Systems/<str>/Bios/")
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Bios/Settings")
         .privileges(redfish::privileges::getBios)
-        .methods(boost::beast::http::verb::get)(
-            std::bind_front(handleBiosServiceGet, std::ref(app)));
+        .methods(boost::beast::http::verb::get)(handleBiosSettingsGet);
+
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Bios/Settings")
+        .privileges(redfish::privileges::patchBios)
+        .methods(boost::beast::http::verb::patch)(handleBiosSettingsPatch);
 }
 
 /**
@@ -321,517 +1673,6 @@ inline void requestRoutesBiosChangePassword(App& app)
         });
 }
 
-/**
- * BiosSettings class supports handle GET/PATCH method for
- * BIOS configuration pending settings.
- */
-inline void requestRoutesBiosSettings(App& app)
-{
-    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Bios/Settings")
-        .privileges(redfish::privileges::getBios)
-        .methods(boost::beast::http::verb::get)(
-            [](const crow::Request&,
-               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp) {
-        asyncResp->res.jsonValue["@odata.id"] =
-            "/redfish/v1/Systems/system/Bios/Settings";
-        asyncResp->res.jsonValue["@odata.type"] = "#Bios.v1_1_0.Bios";
-        asyncResp->res.jsonValue["Name"] = "Bios Settings Version 1";
-        asyncResp->res.jsonValue["Id"] = "BiosSettingsV1";
-        asyncResp->res.jsonValue["AttributeRegistry"] = "BiosAttributeRegistry";
-        asyncResp->res.jsonValue["Attributes"] = nlohmann::json::array();
-
-        crow::connections::systemBus->async_method_call(
-            [asyncResp](const boost::system::error_code ec,
-                        const dbus::utility::MapperGetObject& getObjectType) {
-            if (ec)
-            {
-                BMCWEB_LOG_ERROR << "ObjectMapper::GetObject call failed: "
-                                 << ec;
-                messages::internalError(asyncResp->res);
-
-                return;
-            }
-
-            if (getObjectType.empty())
-            {
-                BMCWEB_LOG_ERROR << "getObjectType is empty.";
-                messages::internalError(asyncResp->res);
-
-                return;
-            }
-
-            std::string service = getObjectType.begin()->first;
-
-            crow::connections::systemBus->async_method_call(
-                [asyncResp](const boost::system::error_code ec2,
-                            const std::variant<PendingAttributesType>&
-                                retPendingAttributes) {
-                if (ec2)
-                {
-                    BMCWEB_LOG_ERROR << "getBiosSettings DBUS error: " << ec2;
-                    messages::resourceNotFound(
-                        asyncResp->res, "Systems/system/Bios", "Settings");
-                    return;
-                }
-
-                const PendingAttributesType* pendingAttributes =
-                    std::get_if<PendingAttributesType>(&retPendingAttributes);
-                nlohmann::json& attributesJson =
-                    asyncResp->res.jsonValue["Attributes"];
-                if (pendingAttributes == nullptr)
-                {
-                    BMCWEB_LOG_ERROR << "pendingAttributes is empty";
-                    messages::internalError(asyncResp->res);
-                    return;
-                }
-
-                for (const PendingAttributesItemType& pendingAttributesItem :
-                     *pendingAttributes)
-                {
-                    const std::string& biosAttrType =
-                        std::get<pendingAttrType>(pendingAttributesItem.second);
-
-                    std::string itemType = mapAttrTypeToRedfish(biosAttrType);
-
-                    if (itemType == "String" || itemType == "Enumeration")
-                    {
-                        const std::string* currValue = std::get_if<std::string>(
-                            &std::get<pendingAttrValue>(
-                                pendingAttributesItem.second));
-
-                        if (!currValue)
-                        {
-                            BMCWEB_LOG_ERROR << "No string data in pending "
-                                                "attributes item data";
-                            messages::internalError(asyncResp->res);
-                            return;
-                        }
-
-                        attributesJson.emplace(pendingAttributesItem.first,
-                                               *currValue);
-                    }
-                    else if (itemType == "Integer")
-                    {
-                        const int64_t* currValue =
-                            std::get_if<int64_t>(&std::get<pendingAttrValue>(
-                                pendingAttributesItem.second));
-
-                        if (!currValue)
-                        {
-                            BMCWEB_LOG_ERROR << "No int64_t data in pending "
-                                                "attributes item data";
-                            messages::internalError(asyncResp->res);
-                            return;
-                        }
-
-                        attributesJson.emplace(pendingAttributesItem.first,
-                                               *currValue);
-                    }
-                    else
-                    {
-                        BMCWEB_LOG_ERROR << "Unsupported attribute type.";
-                        messages::internalError(asyncResp->res);
-                        return;
-                    }
-                }
-                },
-                service, "/xyz/openbmc_project/bios_config/manager",
-                "org.freedesktop.DBus.Properties", "Get",
-                "xyz.openbmc_project.BIOSConfig.Manager", "PendingAttributes");
-            },
-            "xyz.openbmc_project.ObjectMapper",
-            "/xyz/openbmc_project/object_mapper",
-            "xyz.openbmc_project.ObjectMapper", "GetObject",
-            "/xyz/openbmc_project/bios_config/manager",
-            std::array<const char*, 0>());
-        });
-
-    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Bios/Settings")
-        .privileges(redfish::privileges::patchBios)
-        .methods(boost::beast::http::verb::patch)(
-            [](const crow::Request& req,
-               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp) {
-        nlohmann::json inpJson;
-
-        if (!redfish::json_util::readJsonPatch(req, asyncResp->res, "data",
-                                               inpJson))
-        {
-            BMCWEB_LOG_ERROR << "No 'data' in req!";
-            return;
-        }
-
-        if (inpJson.empty())
-        {
-            messages::invalidObject(asyncResp->res,
-                                    boost::urls::format("data"));
-            BMCWEB_LOG_ERROR << "No input in req!";
-            return;
-        }
-
-        crow::connections::systemBus->async_method_call(
-            [asyncResp,
-             inpJson](const boost::system::error_code ec,
-                      const dbus::utility::MapperGetObject& getObjectType) {
-            if (ec)
-            {
-                BMCWEB_LOG_ERROR << "ObjectMapper::GetObject call failed: "
-                                 << ec;
-                messages::internalError(asyncResp->res);
-
-                return;
-            }
-
-            if (getObjectType.empty())
-            {
-                BMCWEB_LOG_ERROR << "getObjectType is empty.";
-                messages::internalError(asyncResp->res);
-
-                return;
-            }
-
-            std::string service = getObjectType.begin()->first;
-
-            crow::connections::systemBus->async_method_call(
-                [asyncResp,
-                 inpJson](const boost::system::error_code ec2,
-                          const std::variant<BiosBaseTableType>& retBiosTable) {
-                if (ec2)
-                {
-                    BMCWEB_LOG_ERROR << "getBiosAttributes DBUS error: " << ec2;
-                    messages::internalError(asyncResp->res);
-                    return;
-                }
-
-                const BiosBaseTableType* baseBiosTable =
-                    std::get_if<BiosBaseTableType>(&retBiosTable);
-
-                if (baseBiosTable == nullptr)
-                {
-                    BMCWEB_LOG_ERROR << "baseBiosTable is empty.";
-                    messages::internalError(asyncResp->res);
-                    return;
-                }
-
-                PendingAttributesType pendingAttributes{};
-
-                for (const nlohmann::detail::iteration_proxy_value<
-                         nlohmann::detail::iter_impl<
-                             const nlohmann::basic_json<>>>& attributes :
-                     inpJson.items())
-                {
-                    BiosBaseTableType::const_iterator knobIter =
-                        baseBiosTable->find(attributes.key());
-                    if (knobIter == baseBiosTable->end())
-                    {
-                        BMCWEB_LOG_ERROR << "Cannot find " << attributes.key()
-                                         << " in baseBiosTable";
-                        messages::propertyValueNotInList(
-                            asyncResp->res, attributes.key(), "data");
-                        return;
-                    }
-
-                    const std::string& itemType =
-                        std::get<biosBaseAttrType>(knobIter->second);
-                    std::string attrType = mapAttrTypeToRedfish(itemType);
-
-                    if (attrType == "String" || attrType == "Enumeration")
-                    {
-                        std::string val = attributes.value();
-
-                        pendingAttributes.emplace(
-                            attributes.key(), std::make_tuple(itemType, val));
-                    }
-                    else if (attrType == "Integer")
-                    {
-                        pendingAttributes.emplace(
-                            attributes.key(),
-                            std::make_tuple(itemType, static_cast<int64_t>(
-                                                          attributes.value())));
-                    }
-                    else
-                    {
-                        BMCWEB_LOG_ERROR << "UNKNOWN attrType == " << itemType;
-                        messages::internalError(asyncResp->res);
-
-                        return;
-                    }
-                }
-
-                if (pendingAttributes.empty())
-                {
-                    BMCWEB_LOG_ERROR << "pendingAttributes is empty.";
-                    messages::invalidObject(asyncResp->res,
-                                            boost::urls::format("data"));
-                }
-
-                crow::connections::systemBus->async_method_call(
-                    [asyncResp](const boost::system::error_code ec3) {
-                    if (ec3)
-                    {
-                        BMCWEB_LOG_ERROR << "doPatch resp_handler got error "
-                                         << ec3 << "\n";
-                        messages::internalError(asyncResp->res);
-                        return;
-                    }
-
-                    messages::success(asyncResp->res);
-                    },
-                    "xyz.openbmc_project.BIOSConfigManager",
-                    "/xyz/openbmc_project/bios_config/manager",
-                    "org.freedesktop.DBus.Properties", "Set",
-                    "xyz.openbmc_project.BIOSConfig.Manager",
-                    "PendingAttributes",
-                    std::variant<PendingAttributesType>(pendingAttributes));
-                },
-                service, "/xyz/openbmc_project/bios_config/manager",
-                "org.freedesktop.DBus.Properties", "Get",
-                "xyz.openbmc_project.BIOSConfig.Manager", "BaseBIOSTable");
-            },
-            "xyz.openbmc_project.ObjectMapper",
-            "/xyz/openbmc_project/object_mapper",
-            "xyz.openbmc_project.ObjectMapper", "GetObject",
-            "/xyz/openbmc_project/bios_config/manager",
-            std::array<const char*, 0>());
-        });
-}
-/**
- * BiosAttributeRegistry class supports handle get method for BIOS attribute
- * registry.
- */
-inline void requestRoutesBiosAttributeRegistry(App& app)
-{
-    BMCWEB_ROUTE(
-        app,
-        "/redfish/v1/Registries/BiosAttributeRegistry/BiosAttributeRegistry/")
-        .privileges(redfish::privileges::getBios)
-        .methods(boost::beast::http::verb::get)(
-            [](const crow::Request&,
-               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp) {
-        asyncResp->res.jsonValue["@odata.id"] =
-            "/redfish/v1/Registries/BiosAttributeRegistry/"
-            "BiosAttributeRegistry";
-        asyncResp->res.jsonValue["@odata.type"] =
-            "#AttributeRegistry.v1_3_2.AttributeRegistry";
-        asyncResp->res.jsonValue["Name"] = "Bios Attribute Registry";
-        asyncResp->res.jsonValue["Id"] = "BiosAttributeRegistry";
-        asyncResp->res.jsonValue["RegistryVersion"] = "1.0.0";
-        asyncResp->res.jsonValue["Language"] = "en";
-        asyncResp->res.jsonValue["OwningEntity"] = "OpenBMC";
-        asyncResp->res.jsonValue["RegistryEntries"]["Attributes"] =
-            nlohmann::json::array();
-
-        crow::connections::systemBus->async_method_call(
-            [asyncResp](const boost::system::error_code ec,
-                        const dbus::utility::MapperGetObject& getObjectType) {
-            if (ec)
-            {
-                BMCWEB_LOG_ERROR << "ObjectMapper::GetObject call failed: "
-                                 << ec;
-                messages::internalError(asyncResp->res);
-
-                return;
-            }
-
-            if (getObjectType.empty())
-            {
-                BMCWEB_LOG_ERROR << "getObjectType is empty.";
-                messages::internalError(asyncResp->res);
-
-                return;
-            }
-
-            std::string service = getObjectType.begin()->first;
-
-            crow::connections::systemBus->async_method_call(
-                [asyncResp](
-                    const boost::system::error_code ec2,
-                    const std::variant<BiosBaseTableType>& retBiosTable) {
-                if (ec2)
-                {
-                    BMCWEB_LOG_ERROR << "getBiosAttributeRegistry DBUS error: "
-                                     << ec2;
-                    messages::resourceNotFound(asyncResp->res,
-                                               "Registries/Bios", "Bios");
-                    return;
-                }
-                const BiosBaseTableType* baseBiosTable =
-                    std::get_if<BiosBaseTableType>(&retBiosTable);
-                nlohmann::json& attributeArray =
-                    asyncResp->res.jsonValue["RegistryEntries"]["Attributes"];
-                if (baseBiosTable == nullptr)
-                {
-                    BMCWEB_LOG_ERROR << "baseBiosTable == nullptr ";
-                    messages::internalError(asyncResp->res);
-                    return;
-                }
-                for (const BiosBaseTableItemType& item : *baseBiosTable)
-                {
-                    const std::string& itemType =
-                        std::get<biosBaseAttrType>(item.second);
-                    std::string attrType = mapAttrTypeToRedfish(itemType);
-                    if (attrType == "UNKNOWN")
-                    {
-                        BMCWEB_LOG_ERROR << "UNKNOWN attrType == " << itemType;
-                        continue;
-                    }
-                    nlohmann::json attributeItem;
-                    attributeItem["AttributeName"] = item.first;
-                    attributeItem["Type"] = attrType;
-                    attributeItem["ReadOnly"] =
-                        std::get<biosBaseReadonlyStatus>(item.second);
-                    attributeItem["DisplayName"] =
-                        std::get<biosBaseDisplayName>(item.second);
-                    attributeItem["HelpText"] =
-                        std::get<biosBaseDescription>(item.second);
-                    attributeItem["MenuPath"] =
-                        std::get<biosBaseMenuPath>(item.second);
-
-                    if (attrType == "String" || attrType == "Enumeration")
-                    {
-                        const std::string* currValue = std::get_if<std::string>(
-                            &std::get<biosBaseCurrValue>(item.second));
-
-                        if (!currValue)
-                        {
-                            BMCWEB_LOG_ERROR << "Unable to get currValue, no "
-                                                "std::string data in BIOS "
-                                                "attributes item data";
-                            continue;
-                        }
-
-                        const std::string* defValue = std::get_if<std::string>(
-                            &std::get<biosBaseDefaultValue>(item.second));
-
-                        if (!defValue)
-                        {
-                            BMCWEB_LOG_ERROR << "Unable to get defValue, no "
-                                                "std::string data in BIOS "
-                                                "attributes item data";
-                            continue;
-                        }
-
-                        attributeItem["CurrentValue"] =
-                            currValue != nullptr ? *currValue : "";
-                        attributeItem["DefaultValue"] =
-                            defValue != nullptr ? *defValue : "";
-                    }
-                    else if (attrType == "Integer")
-                    {
-                        const int64_t* currValue = std::get_if<int64_t>(
-                            &std::get<biosBaseCurrValue>(item.second));
-
-                        if (!currValue)
-                        {
-                            BMCWEB_LOG_ERROR << "Unable to get currValue, no "
-                                                "int64_t data in BIOS "
-                                                "attributes item data";
-                            continue;
-                        }
-
-                        const int64_t* defValue = std::get_if<int64_t>(
-                            &std::get<biosBaseDefaultValue>(item.second));
-
-                        if (!defValue)
-                        {
-                            BMCWEB_LOG_ERROR << "Unable to get defValue, no "
-                                                "int64_t data in BIOS "
-                                                "attributes item data";
-                            continue;
-                        }
-
-                        attributeItem["CurrentValue"] =
-                            currValue != nullptr ? *currValue : 0;
-                        attributeItem["DefaultValue"] =
-                            defValue != nullptr ? *defValue : 0;
-                    }
-                    else
-                    {
-                        BMCWEB_LOG_ERROR << "UNKNOWN attrType == " << itemType;
-                        continue;
-                    }
-
-                    nlohmann::json optionsArray = nlohmann::json::array();
-                    const std::vector<OptionsItemType>& optionsVector =
-                        std::get<biosBaseOptions>(item.second);
-                    for (const OptionsItemType& optItem : optionsVector)
-                    {
-                        nlohmann::json optItemJson;
-                        const std::string& strOptItemType =
-                            std::get<optItemType>(optItem);
-                        std::string optItemTypeRedfish =
-                            mapBoundTypeToRedfish(strOptItemType);
-                        if (optItemTypeRedfish == "UNKNOWN")
-                        {
-                            BMCWEB_LOG_ERROR << "UNKNOWN optItemTypeRedfish == "
-                                             << strOptItemType;
-                            continue;
-                        }
-                        if (optItemTypeRedfish == "OneOf")
-                        {
-                            const std::string* currValue =
-                                std::get_if<std::string>(
-                                    &std::get<optItemValue>(optItem));
-
-                            if (!currValue)
-                            {
-                                BMCWEB_LOG_ERROR
-                                    << "Unable to get currValue, "
-                                       "no "
-                                       "std::string data in option "
-                                       "item value";
-                                continue;
-                            }
-
-                            optItemJson["ValueDisplayName"] =
-                                std::get<optItemText>(optItem);
-                            optItemJson["ValueName"] =
-                                currValue != nullptr ? *currValue : "";
-                        }
-                        else
-                        {
-                            const int64_t* currValue = std::get_if<int64_t>(
-                                &std::get<optItemValue>(optItem));
-
-                            if (!currValue)
-                            {
-                                BMCWEB_LOG_ERROR << "Unable to get currValue, "
-                                                    "no "
-                                                    "int64_t data in option "
-                                                    "item value";
-                                continue;
-                            }
-
-                            optItemJson["ValueDisplayName"] =
-                                currValue != nullptr ? *currValue : 0;
-                            optItemJson["ValueName"] =
-                                currValue != nullptr ? *currValue : 0;
-                        }
-
-                        optionsArray.push_back(optItemJson);
-
-                        if (optionsArray.empty())
-                        {
-                            BMCWEB_LOG_ERROR << "optionsArray is empty";
-                            continue;
-                        }
-                    }
-
-                    attributeItem["Value"] = optionsArray;
-                    attributeArray.push_back(attributeItem);
-                }
-                },
-                service, "/xyz/openbmc_project/bios_config/manager",
-                "org.freedesktop.DBus.Properties", "Get",
-                "xyz.openbmc_project.BIOSConfig.Manager", "BaseBIOSTable");
-            },
-            "xyz.openbmc_project.ObjectMapper",
-            "/xyz/openbmc_project/object_mapper",
-            "xyz.openbmc_project.ObjectMapper", "GetObject",
-            "/xyz/openbmc_project/bios_config/manager",
-            std::array<const char*, 0>());
-        });
-}
-
 /**
  * BiosReset class supports handle POST method for Reset bios.
  * The class retrieves and sends data directly to D-Bus.
@@ -883,4 +1724,36 @@ inline void requestRoutesBiosReset(App& app)
             std::bind_front(handleBiosResetPost, std::ref(app)));
 }
 
+/**
+ * BiosAttributeRegistry class supports handle get method for Bios Attribute
+ * Registry.
+ */
+inline void handleBiosAttrRegistryGet(
+    const crow::Request&, const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
+{
+    asyncResp->res.jsonValue["@odata.id"] =
+        "/redfish/v1/Registries/BiosAttributeRegistry/"
+        "BiosAttributeRegistry";
+    asyncResp->res.jsonValue["@odata.type"] =
+        "#AttributeRegistry.v1_3_2.AttributeRegistry";
+    asyncResp->res.jsonValue["Name"] = "Bios Attribute Registry";
+    asyncResp->res.jsonValue["Id"] = "BiosAttributeRegistry";
+    asyncResp->res.jsonValue["RegistryVersion"] = "1.0.0";
+    asyncResp->res.jsonValue["Language"] = "en";
+    asyncResp->res.jsonValue["OwningEntity"] = "OpenBMC";
+    asyncResp->res.jsonValue["RegistryEntries"]["Attributes"] =
+        nlohmann::json::array();
+
+    // Get the BIOS Attributes Registry
+    bios::getBiosAttributeRegistry(asyncResp);
+}
+
+inline void requestRoutesBiosAttrRegistryService(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Registries/"
+                      "BiosAttributeRegistry/BiosAttributeRegistry/")
+        .privileges(redfish::privileges::getBios)
+        .methods(boost::beast::http::verb::get)(handleBiosAttrRegistryGet);
+}
+
 } // namespace redfish
-- 
2.25.1

