From 89774dc78659d5ed480063f308ba85fcac709dc8 Mon Sep 17 00:00:00 2001
From: arunthomas <arunthomasb@ami.com>
Date: Tue, 12 Sep 2023 20:03:16 +0530
Subject: [PATCH 112/112] ByPass authentication for requests redirected
 internally

When If-Match header with etag value is passed for PATCH requests, new request with
GET method is internally framed and sent to calculate the current etag value and match with
provided etag. For this request by pass authentication since the same request is initially
authenticated and privileges are assigned. Also to the new request framed internally, same req.session
is assigned. So its duplicate effort in authenticating and assigning the privilages.
Also this causes the BMCWEB to crash when assigning the privilages.

Tested: Run Redfish Protocol validator and got passed.

Signed-off-by: arunthomas <arunthomasb@ami.com>
---
 http/app.hpp                   |  5 +++--
 http/routing.hpp               |  5 +++--
 redfish-core/include/query.hpp | 18 +++++++++---------
 3 files changed, 15 insertions(+), 13 deletions(-)

diff --git a/http/app.hpp b/http/app.hpp
index a3a6e162..f233b088 100644
--- a/http/app.hpp
+++ b/http/app.hpp
@@ -66,9 +66,10 @@ class App
     }
 
     void handle(Request& req,
-                const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
+                const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                bool requestRedirect = false)
     {
-        router.handle(req, asyncResp);
+        router.handle(req, asyncResp, requestRedirect);
     }
 
     DynamicRule& routeDynamic(std::string&& rule)
diff --git a/http/routing.hpp b/http/routing.hpp
index 5e20cf24..f0d5980b 100644
--- a/http/routing.hpp
+++ b/http/routing.hpp
@@ -1431,7 +1431,8 @@ class Router
     }
 
     void handle(Request& req,
-                const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
+                const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                bool requestRedirect = false)
     {
         std::optional<HttpVerb> verb = httpVerbFromBoost(req.method());
         if (!verb || static_cast<size_t>(*verb) >= perMethods.size())
@@ -1489,7 +1490,7 @@ class Router
                          << static_cast<uint32_t>(*verb) << " / "
                          << rule.getMethods();
 
-        if (req.session == nullptr)
+        if (req.session == nullptr || requestRedirect)
         {
             rule.handle(req, asyncResp, params);
             return;
diff --git a/redfish-core/include/query.hpp b/redfish-core/include/query.hpp
index 10a337b9..16ab8db2 100644
--- a/redfish-core/include/query.hpp
+++ b/redfish-core/include/query.hpp
@@ -48,7 +48,7 @@ inline void
     // Restart the request without if-match
     req.req.erase(boost::beast::http::field::if_match);
     BMCWEB_LOG_DEBUG << "Restarting request";
-    app.handle(req, asyncResp);
+    app.handle(req, asyncResp, true);
 }
 
 inline bool handleIfMatch(crow::App& app, const crow::Request& req,
@@ -104,7 +104,7 @@ inline bool handleIfMatch(crow::App& app, const crow::Request& req,
     getReqAsyncResp->res.setCompleteRequestHandler(std::bind_front(
         afterIfMatchRequest, std::ref(app), asyncResp, req, ifMatch));
 
-    app.handle(newReq, getReqAsyncResp);
+    app.handle(newReq, getReqAsyncResp, true);
     return false;
 }
 
@@ -133,13 +133,6 @@ inline bool handleIfMatch(crow::App& app, const crow::Request& req,
 
     asyncResp->res.addHeader("OData-Version", "4.0");
 
-    std::optional<query_param::Query> queryOpt =
-        query_param::parseParameters(req.url().params(), asyncResp->res);
-    if (queryOpt == std::nullopt)
-    {
-        return false;
-    }
-
     if (!handleIfMatch(app, req, asyncResp))
     {
         return false;
@@ -161,6 +154,13 @@ inline bool handleIfMatch(crow::App& app, const crow::Request& req,
         return needToCallHandlers;
     }
 
+    std::optional<query_param::Query> queryOpt =
+        query_param::parseParameters(req.url().params(), asyncResp->res);
+    if (queryOpt == std::nullopt)
+    {
+        return false;
+    }
+
     delegated = query_param::delegate(queryCapabilities, *queryOpt);
     std::function<void(crow::Response&)> handler =
         asyncResp->res.releaseCompleteRequestHandler();
-- 
2.39.2

