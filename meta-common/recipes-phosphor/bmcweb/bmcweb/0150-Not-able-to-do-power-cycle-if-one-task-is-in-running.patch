From 2291877aa5c8a729996971193aef967e2632e888 Mon Sep 17 00:00:00 2001
From: ramadevip <ramadevip@ami.com>
Date: Thu, 25 Jan 2024 14:59:12 +0530
Subject: [PATCH] recreated 0150 and 0182

Signed-off-by: ramadevip <ramadevip@ami.com>
---
 redfish-core/lib/chassis.hpp | 353 +++++++++++-------
 redfish-core/lib/systems.hpp | 690 +++++++++++++++++++----------------
 2 files changed, 602 insertions(+), 441 deletions(-)

diff --git a/redfish-core/lib/chassis.hpp b/redfish-core/lib/chassis.hpp
index c84fc641..0e2ecc2b 100644
--- a/redfish-core/lib/chassis.hpp
+++ b/redfish-core/lib/chassis.hpp
@@ -38,9 +38,9 @@
 #include <utils/sw_utils.hpp>
 
 #include <array>
-#include <ranges>
 #include <cstdlib>
 #include <iostream>
+#include <ranges>
 #include <sstream>
 #include <string>
 #include <string_view>
@@ -456,9 +456,8 @@ inline void handleDecoratorAssetProperties(
     asyncResp->res.jsonValue["Oem"]["AMI"]["@odata.id"] =
         boost::urls::format("/redfish/v1/Chassis/{}#/Oem/AMI", chassisId);
     // Network Adapters
-                asyncResp->res.jsonValue["NetworkAdapters"] = {
-                    {"@odata.id",
-                     "/redfish/v1/Chassis/" + chassisId + "/NetworkAdapters"}};
+    asyncResp->res.jsonValue["NetworkAdapters"] = {
+        {"@odata.id", "/redfish/v1/Chassis/" + chassisId + "/NetworkAdapters"}};
 
     // SensorCollection
     asyncResp->res.jsonValue["Sensors"]["@odata.id"] =
@@ -861,54 +860,79 @@ inline void
     setPowerTransitionTimer(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
                             const uint16_t chassisHostTransitionTimeOut)
 {
-    BMCWEB_LOG_ERROR("setPowerTransitionTimer");
-    const char* busName = "xyz.openbmc_project.ObjectMapper";
-    const char* path = "/xyz/openbmc_project/object_mapper";
-    const char* interface = "xyz.openbmc_project.ObjectMapper";
-    const char* method = "GetSubTreePaths";
-
-    const std::array<const char*, 1> interfaces = {
-        "xyz.openbmc_project.State.Chassis"};
-
-    // Use mapper to get subtree paths.
+    BMCWEB_LOG_ERROR("setHostTransitionTimer");
     crow::connections::systemBus->async_method_call(
-        [asyncResp, chassisHostTransitionTimeOut](
-            const boost::system::error_code ec,
-            const dbus::utility::MapperGetSubTreePathsResponse& chassisList) {
+        [asyncResp](const boost::system::error_code ec) {
         if (ec)
         {
-            BMCWEB_LOG_ERROR("[Set] Bad D-Bus request error:", ec);
             messages::internalError(asyncResp->res);
-            return;
         }
+    },
+        "xyz.openbmc_project.State.Host0", "/xyz/openbmc_project/state/os",
+        "org.freedesktop.DBus.Properties", "Set",
+        "xyz.openbmc_project.State.OperatingSystem.Status",
+        "ChassisHostTransitionTimeOut",
+        dbus::utility::DbusVariantType(chassisHostTransitionTimeOut));
+}
 
-        const char* processName = "xyz.openbmc_project.State.Chassis";
-        const char* interfaceName = "xyz.openbmc_project.State.Chassis";
-        const char* destProperty = "ChassisHostTransitionTimeOut";
-        std::string objectPath = "/xyz/openbmc_project/state/chassis_system0";
+inline void setTaskId(const uint16_t index)
+{
+    auto bus = sdbusplus::bus::new_default();
+    auto method = bus.new_method_call("xyz.openbmc_project.State.Host0",
+                                      "/xyz/openbmc_project/state/os",
+                                      "org.freedesktop.DBus.Properties", "Set");
 
-        /* Look for system reset chassis path */
-        if ((std::find(chassisList.begin(), chassisList.end(), objectPath)) ==
-            chassisList.end())
-        {
-            /* We prefer to reset the full chassis_system, but if it doesn't
-             * exist on some platforms, fall back to a host-only power reset
-             */
-            objectPath = "/xyz/openbmc_project/state/chassis0";
-        }
+    method.append("xyz.openbmc_project.Common.Task", "TaskId",
+                  dbus::utility::DbusVariantType(index));
 
-        crow::connections::systemBus->async_method_call(
-            [asyncResp](const boost::system::error_code ec2) {
-            if (ec2)
-            {
-                messages::internalError(asyncResp->res);
-            }
-        },
-            processName, objectPath, "org.freedesktop.DBus.Properties", "Set",
-            interfaceName, destProperty,
-            dbus::utility::DbusVariantType(chassisHostTransitionTimeOut));
-    },
-        busName, path, interface, method, "/", 0, interfaces);
+    try
+    {
+        auto reply = bus.call(method);
+    }
+    catch (const sdbusplus::exception::SdBusError& e)
+    {
+        BMCWEB_LOG_ERROR("D-Bus error:", e.what());
+    }
+}
+
+inline void setStatus(const std::string status)
+{
+    auto bus = sdbusplus::bus::new_default();
+    auto method = bus.new_method_call("xyz.openbmc_project.State.Host0",
+                                      "/xyz/openbmc_project/state/os",
+                                      "org.freedesktop.DBus.Properties", "Set");
+
+    method.append("xyz.openbmc_project.Common.Task", "Status",
+                  dbus::utility::DbusVariantType(status));
+
+    try
+    {
+        auto reply = bus.call(method);
+    }
+    catch (const sdbusplus::exception::SdBusError& e)
+    {
+        BMCWEB_LOG_ERROR("D-Bus error:", e.what());
+    }
+}
+
+inline void setTaskName(const std::string taskName)
+{
+    auto bus = sdbusplus::bus::new_default();
+    auto method = bus.new_method_call("xyz.openbmc_project.State.Host0",
+                                      "/xyz/openbmc_project/state/os",
+                                      "org.freedesktop.DBus.Properties", "Set");
+
+    method.append("xyz.openbmc_project.Common.Task", "TaskName",
+                  dbus::utility::DbusVariantType(taskName));
+
+    try
+    {
+        auto reply = bus.call(method);
+    }
+    catch (const sdbusplus::exception::SdBusError& e)
+    {
+        BMCWEB_LOG_ERROR("D-Bus error:", e.what());
+    }
 }
 
 inline void
@@ -955,7 +979,7 @@ inline void
                 messages::internalError(asyncResp->res);
                 return;
             }
-            },
+        },
             processName, objectPath, "org.freedesktop.DBus.Properties", "Set",
             interfaceName, destProperty,
             dbus::utility::DbusVariantType{propertyValue});
@@ -999,6 +1023,22 @@ const PropertyValue getHostState(const std::string& processName,
     return value;
 }
 
+const PropertyValue getchassisHostTransitionTimeOut(
+    const std::string& servicePath, const std::string& objectName,
+    const std::string& interface, const std::string& property_Name)
+{
+    PropertyValue value{};
+
+    auto b = sdbusplus::bus::new_default_system();
+    auto method = b.new_method_call(servicePath.c_str(), objectName.c_str(),
+                                    dbusPropertyInterface, "Get");
+
+    method.append(interface, property_Name);
+    auto reply = b.call(method);
+    reply.read(value);
+    return value;
+}
+
 /*
  * Function to create the reboot status task
  *
@@ -1007,13 +1047,13 @@ const PropertyValue getHostState(const std::string& processName,
  */
 void createImmediateResetTask(
     const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
-    task::Payload&& payload)
+    task::Payload&& payload, const std::string& resetType)
 {
     BMCWEB_LOG_ERROR("after do Task creartion");
 
     std::shared_ptr<task::TaskData> task = task::TaskData::createTask(
-        [](boost::system::error_code ec, sdbusplus::message_t& msg,
-           const std::shared_ptr<task::TaskData>& taskData) {
+        [resetType](boost::system::error_code ec, sdbusplus::message_t& msg,
+                    const std::shared_ptr<task::TaskData>& taskData) {
         if (ec)
         {
             taskData->messages.emplace_back(messages::internalError());
@@ -1026,6 +1066,12 @@ void createImmediateResetTask(
 
         std::string index = std::to_string(taskData->index);
 
+        int convertedIndex = std::stoi(index);
+
+        setTaskId(static_cast<uint16_t>(convertedIndex));
+
+        setTaskName(resetType);
+
         msg.read(iface, values);
 
         if (iface == "xyz.openbmc_project.State.OperatingSystem.Status")
@@ -1055,6 +1101,8 @@ void createImmediateResetTask(
             if (*osState ==
                 "xyz.openbmc_project.State.OperatingSystem.Status.OSStatus.Inactive")
             {
+                setStatus(
+                    "xyz.openbmc_project.Common.Task.OperationStatus.InProgress");
                 taskData->state = "Running";
                 taskData->messages.emplace_back(messages::taskStarted(index));
                 taskData->extendTimer(std::chrono::minutes(5));
@@ -1064,6 +1112,8 @@ void createImmediateResetTask(
             if (*osState ==
                 "xyz.openbmc_project.State.OperatingSystem.Status.OSStatus.Standby")
             {
+                setStatus(
+                    "xyz.openbmc_project.Common.Task.OperationStatus.Completed");
                 taskData->messages.emplace_back(
                     messages::taskCompletedOK(index));
                 taskData->state = "Completed";
@@ -1086,93 +1136,122 @@ void createImmediateResetTask(
  * @param[in] asyncResp - Shared pointer for completing asynchronous call
  * @param[in] payload - Double pointer to get the task Data
  */
-/*void createMaintenanceWindowTask(const std::shared_ptr<bmcweb::AsyncResp>&
-asyncResp, task::Payload&& payload)
+void createMaintenanceWindowTask(
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+    task::Payload&& payload, const std::string& resetType)
 {
-        BMCWEB_LOG_DEBUG << " after do Task creartion ";
+    BMCWEB_LOG_ERROR("after do Task creation");
 
-    std::shared_ptr<task::TaskData> task =
-                        task::TaskData::createTask(
-                            [](boost::system::error_code ec,
-                               sdbusplus::message_t& msg,
-                               const std::shared_ptr<task::TaskData>&
-                               taskData) {
+    std::shared_ptr<task::TaskData> task = task::TaskData::createTask(
+        [resetType](boost::system::error_code ec, sdbusplus::message_t& msg,
+                    const std::shared_ptr<task::TaskData>& taskData) {
+        if (ec)
+        {
+            taskData->messages.emplace_back(messages::internalError());
+            taskData->state = "Cancelled";
+            return task::completed;
+        }
 
-                        if (ec)
-                        {
-                            taskData->messages.emplace_back(messages::internalError());
-                            taskData->state = "Cancelled";
-                            return task::completed;
-                        }
+        std::string iface;
+        dbus::utility::DBusPropertiesMap values;
 
-                        std::string iface;
-                        dbus::utility::DBusPropertiesMap values;
+        std::string index = std::to_string(taskData->index);
 
-                        std::string index = std::to_string(taskData->index);
+        int convertedIndex = std::stoi(index);
 
-                        msg.read(iface, values);
+        setTaskId(static_cast<uint16_t>(convertedIndex));
 
-                        if (iface == "xyz.openbmc_project.State.Chassis")
-                        {
-                                const uint16_t* timeOutValue = nullptr;
+        setTaskName(resetType);
 
-                            for (const auto& property : values)
-                            {
+        msg.read(iface, values);
 
-                                if (property.first ==
-"ChassisHostTransitionTimeOut")
-                                {
+        const char* servicePath = "xyz.openbmc_project.State.Host0";
+        const char* interfacePath =
+            "xyz.openbmc_project.State.OperatingSystem.Status";
+        const char* property_Name = "ChassisHostTransitionTimeOut";
+        const char* objectName = "/xyz/openbmc_project/state/os";
 
-                                      timeOutValue =
-                                        std::get_if<uint16_t>(
-                                            &property.second);
+        auto timeOut_value = getchassisHostTransitionTimeOut(
+            servicePath, objectName, interfacePath, property_Name);
 
-                                    if (timeOutValue == nullptr)
-                                    {
-                                            taskData->messages.emplace_back(
-                                                            messages::internalError());
-                                            return task::completed;
-                                    }
-                                }
-                            }
+        auto reqchassisHostTransitionTimeOut =
+            std::get<uint16_t>(timeOut_value);
 
-                            if (timeOutValue == nullptr)
-                            {
-                                return !task::completed;
-                            }
+        if (iface == "xyz.openbmc_project.State.OperatingSystem.Status")
+        {
+            const uint16_t* timeOutValue = nullptr;
+            const std::string* osState = nullptr;
 
-                            if(*timeOutValue == 0)
-                            {
-                                             taskData->messages.emplace_back(
-                                             messages::taskCompletedOK(index));
-                                             taskData->state = "Completed";
-                                             return task::completed;
-                            }
-                            taskData->extendTimer(std::chrono::minutes(5));
-                        }
-                        return !task::completed;
-                            },
-            "type='signal',interface='org.freedesktop.DBus.Properties',"
-                            "member='PropertiesChanged',path='/xyz/openbmc_project/state/chassis0'");
-                    task->startTimer(std::chrono::minutes(5));
-                    task->populateResp(asyncResp->res);
-                    task->payload.emplace(std::move(payload));
-}*/
+            for (const auto& property : values)
+            {
+                if (property.first == "ChassisHostTransitionTimeOut")
+                {
+                    timeOutValue = std::get_if<uint16_t>(&property.second);
 
-const PropertyValue getchassisHostTransitionTimeOut(
-    const std::string& servicePath, const std::string& objectName,
-    const std::string& interface, const std::string& property_Name)
-{
-    PropertyValue value{};
+                    if (timeOutValue == nullptr)
+                    {
+                        taskData->messages.emplace_back(
+                            messages::internalError());
+                        return task::completed;
+                    }
+                }
 
-    auto b = sdbusplus::bus::new_default_system();
-    auto method = b.new_method_call(servicePath.c_str(), objectName.c_str(),
-                                    dbusPropertyInterface, "Get");
+                if (property.first == "OperatingSystemState")
+                {
+                    osState = std::get_if<std::string>(&property.second);
 
-    method.append(interface, property_Name);
-    auto reply = b.call(method);
-    reply.read(value);
-    return value;
+                    if (osState == nullptr)
+                    {
+                        taskData->messages.emplace_back(
+                            messages::internalError());
+                        return task::completed;
+                    }
+                }
+            }
+
+            if (timeOutValue != nullptr && *timeOutValue != 0)
+            {
+                setStatus(
+                    "xyz.openbmc_project.Common.Task.OperationStatus.New");
+                taskData->state = "Pending";
+                taskData->messages.emplace_back(messages::taskPaused(index));
+                taskData->extendTimer(std::chrono::minutes(10));
+                return !task::completed;
+            }
+            if (reqchassisHostTransitionTimeOut == 0 && osState != nullptr)
+            {
+                if (*osState ==
+                    "xyz.openbmc_project.State.OperatingSystem.Status.OSStatus.Inactive")
+                {
+                    setStatus(
+                        "xyz.openbmc_project.Common.Task.OperationStatus.InProgress");
+                    taskData->state = "Running";
+                    taskData->messages.emplace_back(
+                        messages::taskStarted(index));
+                    taskData->extendTimer(std::chrono::minutes(5));
+                    return !task::completed;
+                }
+
+                if (*osState ==
+                    "xyz.openbmc_project.State.OperatingSystem.Status.OSStatus.Standby")
+                {
+                    setStatus(
+                        "xyz.openbmc_project.Common.Task.OperationStatus.Completed");
+                    taskData->messages.emplace_back(
+                        messages::taskCompletedOK(index));
+                    taskData->state = "Completed";
+                    return task::completed;
+                }
+            }
+            taskData->extendTimer(std::chrono::minutes(5));
+        }
+        return !task::completed;
+    },
+        "type='signal',interface='org.freedesktop.DBus.Properties',"
+        "member='PropertiesChanged',path='/xyz/openbmc_project/state/os'");
+    task->startTimer(std::chrono::minutes(5));
+    task->populateResp(asyncResp->res);
+    task->payload.emplace(std::move(payload));
 }
 
 /**
@@ -1251,10 +1330,11 @@ inline void handleChassisResetActionInfoPost(
             const char* propName = "CurrentHostState";
             const char* objectPath = "/xyz/openbmc_project/state/host0";
 
-            const char* servicePath = "xyz.openbmc_project.State.Chassis";
-            const char* interfacePath = "xyz.openbmc_project.State.Chassis";
+            const char* servicePath = "xyz.openbmc_project.State.Host0";
+            const char* interfacePath =
+                "xyz.openbmc_project.State.OperatingSystem.Status";
             const char* property_Name = "ChassisHostTransitionTimeOut";
-            const char* objectName = "/xyz/openbmc_project/state/chassis0";
+            const char* objectName = "/xyz/openbmc_project/state/os";
 
             auto value = getHostState(processName, objectPath, interfaceName,
                                       propName);
@@ -1271,13 +1351,8 @@ inline void handleChassisResetActionInfoPost(
                 NoOperation(asyncResp);
                 return;
             }
-            if (reqchassisHostTransitionTimeOut != 0)
-            {
-                BMCWEB_LOG_ERROR("Already One Reboot Task is running");
-                messages::resourceInUse(asyncResp->res);
-                 return;
-            }
-             if (!json_util::readJsonAction(
+
+            if (!json_util::readJsonAction(
                     req, asyncResp->res, "ResetType", resetType,
                     "OperationApplyTime", operationApplyTime,
                     "MaintenanceWindowStartTime", maintenanceWindowStartTime))
@@ -1311,7 +1386,8 @@ inline void handleChassisResetActionInfoPost(
                 if (!(maintenanceWindowStartTime))
                 {
                     BMCWEB_LOG_ERROR("Not of maintenanceWindowStartTime");
-                    createImmediateResetTask(asyncResp, std::move(payload));
+                    createImmediateResetTask(asyncResp, std::move(payload),
+                                             resetType);
                     doChassisPowerCycle(asyncResp);
                     return;
                 }
@@ -1330,6 +1406,13 @@ inline void handleChassisResetActionInfoPost(
                 maintenanceWindowStartTime)
             {
                 BMCWEB_LOG_ERROR("AtMaintenanceWindowStart");
+
+                if (reqchassisHostTransitionTimeOut != 0)
+                {
+                    messages::resourceInUse(asyncResp->res);
+                    return;
+                }
+
                 if (maintenanceWindowStartTime <= redfishDateTimeOffset)
                 {
                     messages::propertyValueIncorrect(
@@ -1367,8 +1450,8 @@ inline void handleChassisResetActionInfoPost(
                                                redfishDateTimeOffset);
 
                 setPowerTransitionTimer(asyncResp, timeOut);
-                // createMaintenanceWindowTask(asyncResp, std::move(payload));
-                createImmediateResetTask(asyncResp, std::move(payload));
+                createMaintenanceWindowTask(asyncResp, std::move(payload),
+                                            resetType);
                 doChassisPowerCycle(asyncResp);
                 return;
             }
@@ -1378,8 +1461,8 @@ inline void handleChassisResetActionInfoPost(
                     "Missing Property AtMaintenanceWindowStartTime");
                 messages::actionParameterMissing(
                     asyncResp->res, "Reset", "AtMaintenanceWindowStartTime");
-                 return;
-             }
+                return;
+            }
         }
         messages::resourceNotFound(asyncResp->res, "#Chassis", chassisId);
     },
@@ -2182,6 +2265,6 @@ inline void requestRoutesChassisNetworkPorts(App& app)
                 "org.freedesktop.DBus.Properties", "GetAll", infPath);
         }
     });
- }
+}
 
 } // namespace redfish
diff --git a/redfish-core/lib/systems.hpp b/redfish-core/lib/systems.hpp
index aada83ef..a7af7163 100644
--- a/redfish-core/lib/systems.hpp
+++ b/redfish-core/lib/systems.hpp
@@ -68,8 +68,6 @@ const static std::array<std::pair<std::string_view, std::string_view>, 2>
 constexpr const char* dbus_Property_Interface =
     "org.freedesktop.DBus.Properties";
 
-static bool flag = true;
-
 /**
  * @brief Updates the Functional State of DIMMs
  *
@@ -3209,81 +3207,198 @@ inline void handleComputerSystemCollectionGet(
     });
 }
 
+const PropertyValue getHostTransitionTimeOut(const std::string& servicePath,
+                                             const std::string& objectPath,
+                                             const std::string& interface,
+                                             const std::string& propertyName)
+{
+    BMCWEB_LOG_ERROR("getHostTransitionTimeOut");
+    PropertyValue value{};
+
+    auto b = sdbusplus::bus::new_default_system();
+    auto method = b.new_method_call(servicePath.c_str(), objectPath.c_str(),
+                                    dbus_Property_Interface, "Get");
+
+    method.append(interface, propertyName);
+    auto reply = b.call(method);
+    reply.read(value);
+    return value;
+}
+
+const PropertyValue getPowerTransitionTimeOut(const std::string& servicePath,
+                                              const std::string& objectPath,
+                                              const std::string& interface,
+                                              const std::string& propertyName)
+{
+    BMCWEB_LOG_ERROR("getPowerTransitionTimeOut");
+    PropertyValue value{};
+
+    auto b = sdbusplus::bus::new_default_system();
+    auto method = b.new_method_call(servicePath.c_str(), objectPath.c_str(),
+                                    dbus_Property_Interface, "Get");
+
+    method.append(interface, propertyName);
+    auto reply = b.call(method);
+    reply.read(value);
+    return value;
+}
+
 /*
  * Function to create the reboot status task
  *
  * @param[in] asyncResp - Shared pointer for completing asynchronous call
  * @param[in] payload - Double pointer to get the task Data
  */
-/*void createResetMaintenanceWindowTask(const
-std::shared_ptr<bmcweb::AsyncResp>& asyncResp, task::Payload&& payload)
+
+void createResetMaintenanceWindowTask(
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+    task::Payload&& payload, const std::string& resetType)
 {
-        BMCWEB_LOG_DEBUG << "after do Task creartion ";
-
-    std::shared_ptr<task::TaskData> task =
-                        task::TaskData::createTask(
-                            [](boost::system::error_code ec,
-                               sdbusplus::message_t& msg,
-                               const std::shared_ptr<task::TaskData>&
-                               taskData) {
-
-                        if (ec)
-                        {
-                            taskData->messages.emplace_back(messages::internalError());
-                            taskData->state = "Cancelled";
-                            return task::completed;
-                        }
-
-                        std::string iface;
-                        dbus::utility::DBusPropertiesMap values;
-
-                        std::string index = std::to_string(taskData->index);
-
-                        msg.read(iface, values);
-
-                        const uint16_t* timeOutValue = nullptr;
-                        if (iface == "xyz.openbmc_project.State.Host")
-                        {
-                            for (const auto& property : values)
-                            {
-                                if (property.first == "HostTransitionTimeOut")
-                                {
-                                      timeOutValue =
-                                        std::get_if<uint16_t>(
-                                            &property.second);
-
-                                    if (timeOutValue == nullptr)
-                                    {
-                                            taskData->messages.emplace_back(
-                                                            messages::internalError());
-                                            return task::completed;
-                                    }
-                                }
-                            }
-
-                            if (timeOutValue == nullptr)
-                            {
-                                return !task::completed;
-                            }
-
-                            if(*timeOutValue == 0)
-                            {
-
-                                             taskData->messages.emplace_back(
-                                             messages::taskCompletedOK(index));
-                                             taskData->state = "Completed";
-                                             return task::completed;
-                            }
-                             taskData->extendTimer(std::chrono::minutes(5));
-                        }
-                        return !task::completed;
-                            },
-            "type='signal',interface='org.freedesktop.DBus.Properties',"
-                            "member='PropertiesChanged',path='/xyz/openbmc_project/state/host0'");
-                    task->startTimer(std::chrono::minutes(5));
-                    task->populateResp(asyncResp->res);
-                    task->payload.emplace(std::move(payload));
-}*/
+    BMCWEB_LOG_ERROR("after do Task creartion ");
+
+    std::shared_ptr<task::TaskData> task = task::TaskData::createTask(
+        [resetType](boost::system::error_code ec, sdbusplus::message_t& msg,
+                    const std::shared_ptr<task::TaskData>& taskData) {
+        if (ec)
+        {
+            taskData->messages.emplace_back(messages::internalError());
+            taskData->state = "Cancelled";
+            return task::completed;
+        }
+
+        std::string iface;
+        dbus::utility::DBusPropertiesMap values;
+
+        std::string index = std::to_string(taskData->index);
+
+        int convertedIndex = std::stoi(index);
+
+        setTaskId(static_cast<uint16_t>(convertedIndex));
+
+        setTaskName(resetType);
+
+        msg.read(iface, values);
+
+        const char* processName = "xyz.openbmc_project.State.Host0";
+        const char* objectPath = "/xyz/openbmc_project/state/os";
+        const char* interfaceName =
+            "xyz.openbmc_project.State.OperatingSystem.Status";
+        const char* prop_Name = "HostTransitionTimeOut";
+
+        auto host_Value = getHostTransitionTimeOut(processName, objectPath,
+                                                   interfaceName, prop_Name);
+        auto requestedHostTransition = std::get<uint16_t>(host_Value);
+
+        if (iface == "xyz.openbmc_project.State.OperatingSystem.Status")
+        {
+            const uint16_t* timeOutValue = nullptr;
+            const std::string* osState = nullptr;
+
+            for (const auto& property : values)
+            {
+                if (property.first == "HostTransitionTimeOut")
+                {
+                    timeOutValue = std::get_if<uint16_t>(&property.second);
+
+                    if (timeOutValue == nullptr)
+                    {
+                        taskData->messages.emplace_back(
+                            messages::internalError());
+                        return task::completed;
+                    }
+                }
+
+                if (property.first == "OperatingSystemState")
+                {
+                    osState = std::get_if<std::string>(&property.second);
+
+                    if (osState == nullptr)
+                    {
+                        taskData->messages.emplace_back(
+                            messages::internalError());
+                        return task::completed;
+                    }
+                }
+            }
+
+            if ((timeOutValue != nullptr && *timeOutValue != 0))
+            {
+                setStatus(
+                    "xyz.openbmc_project.Common.Task.OperationStatus.New");
+                taskData->state = "Pending";
+                taskData->messages.emplace_back(messages::taskPaused(index));
+                taskData->extendTimer(std::chrono::minutes(10));
+                return !task::completed;
+            }
+
+            if (osState != nullptr && requestedHostTransition == 0)
+            {
+                if ((resetType != "GracefulShutdown" &&
+                     resetType != "ForceOff") &&
+                    *osState ==
+                        "xyz.openbmc_project.State.OperatingSystem.Status.OSStatus.Inactive")
+                {
+                    setStatus(
+                        "xyz.openbmc_project.Common.Task.OperationStatus.InProgress");
+                    taskData->state = "Running";
+                    taskData->messages.emplace_back(
+                        messages::taskStarted(index));
+                    taskData->extendTimer(std::chrono::minutes(5));
+                    return !task::completed;
+                }
+                else if (
+                    (resetType != "GracefulShutdown" &&
+                     resetType != "ForceOff") &&
+                    *osState ==
+                        "xyz.openbmc_project.State.OperatingSystem.Status.OSStatus.Standby")
+                {
+                    setStatus(
+                        "xyz.openbmc_project.Common.Task.OperationStatus.Completed");
+                    taskData->messages.emplace_back(
+                        messages::taskCompletedOK(index));
+                    taskData->state = "Completed";
+                    return task::completed;
+                }
+
+                else if (
+                    (resetType == "ForceOff" ||
+                     resetType == "GracefulShutdown") &&
+                    *osState ==
+                        "xyz.openbmc_project.State.OperatingSystem.Status.OSStatus.Standby")
+                {
+                    setStatus(
+                        "xyz.openbmc_project.Common.Task.OperationStatus.InProgress");
+                    taskData->state = "Running";
+                    taskData->messages.emplace_back(
+                        messages::taskStarted(index));
+                    taskData->extendTimer(std::chrono::minutes(5));
+                    return !task::completed;
+                }
+
+                else if (
+                    (resetType == "ForceOff" ||
+                     resetType == "GracefulShutdown") &&
+                    *osState ==
+                        "xyz.openbmc_project.State.OperatingSystem.Status.OSStatus.Inactive")
+                {
+                    setStatus(
+                        "xyz.openbmc_project.Common.Task.OperationStatus.Completed");
+                    taskData->messages.emplace_back(
+                        messages::taskCompletedOK(index));
+                    taskData->state = "Completed";
+                    return task::completed;
+                }
+            }
+            taskData->extendTimer(std::chrono::minutes(5));
+        }
+        return !task::completed;
+    },
+        "type='signal',interface='org.freedesktop.DBus.Properties',"
+        "member='PropertiesChanged',path='/xyz/openbmc_project/state/os'");
+    task->startTimer(std::chrono::minutes(5));
+    task->populateResp(asyncResp->res);
+    task->payload.emplace(std::move(payload));
+}
 
 /*
  * Function to create the reboot status task
@@ -3291,75 +3406,121 @@ std::shared_ptr<bmcweb::AsyncResp>& asyncResp, task::Payload&& payload)
  * @param[in] asyncResp - Shared pointer for completing asynchronous call
  * @param[in] payload - Double pointer to get the task Data
  */
-/*void createSystemMaintenanceWindowTask(const
-std::shared_ptr<bmcweb::AsyncResp>& asyncResp, task::Payload&& payload)
+
+void createSystemMaintenanceWindowTask(
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+    task::Payload&& payload, const std::string& resetType)
 {
-        BMCWEB_LOG_DEBUG << "after do Task creartion ";
-
-    std::shared_ptr<task::TaskData> task =
-                        task::TaskData::createTask(
-                            [](boost::system::error_code ec,
-                               sdbusplus::message_t& msg,
-                               const std::shared_ptr<task::TaskData>&
-                               taskData) {
-
-                        if (ec)
-                        {
-                            taskData->messages.emplace_back(messages::internalError());
-                            taskData->state = "Cancelled";
-                            return task::completed;
-                        }
-
-                        std::string iface;
-                        dbus::utility::DBusPropertiesMap values;
-
-                        std::string index = std::to_string(taskData->index);
-
-                        msg.read(iface, values);
-
-                        const uint16_t* timeOutValue = nullptr;
-                        if (iface == "xyz.openbmc_project.State.Chassis")
-                        {
-                            for (const auto& property : values)
-                            {
-                                if (property.first == "PowerTransitionTimeOut")
-                                {
-                                      timeOutValue =
-                                        std::get_if<uint16_t>(
-                                            &property.second);
-
-                                    if (timeOutValue == nullptr)
-                                    {
-                                            taskData->messages.emplace_back(
-                                                            messages::internalError());
-                                            return task::completed;
-                                    }
-                                }
-                            }
-
-                            if (timeOutValue == nullptr)
-                            {
-                                return !task::completed;
-                            }
-
-                            if(*timeOutValue == 0)
-                            {
-
-                                             BMCWEB_LOG_DEBUG << "  Sucesss
-case" ; taskData->messages.emplace_back( messages::taskCompletedOK(index));
-                                             taskData->state = "Completed";
-                                             return task::completed;
-                            }
-                             taskData->extendTimer(std::chrono::minutes(5));
-                        }
-                        return !task::completed;
-                            },
-            "type='signal',interface='org.freedesktop.DBus.Properties',"
-                            "member='PropertiesChanged',path='/xyz/openbmc_project/state/chassis0'");
-                    task->startTimer(std::chrono::minutes(5));
-                    task->populateResp(asyncResp->res);
-                    task->payload.emplace(std::move(payload));
-}*/
+    BMCWEB_LOG_ERROR("after do Task creartion ");
+
+    std::shared_ptr<task::TaskData> task = task::TaskData::createTask(
+        [resetType](boost::system::error_code ec, sdbusplus::message_t& msg,
+                    const std::shared_ptr<task::TaskData>& taskData) {
+        if (ec)
+        {
+            taskData->messages.emplace_back(messages::internalError());
+            taskData->state = "Cancelled";
+            return task::completed;
+        }
+
+        std::string iface;
+        dbus::utility::DBusPropertiesMap values;
+
+        std::string index = std::to_string(taskData->index);
+
+        int convertedIndex = std::stoi(index);
+
+        setTaskId(static_cast<uint16_t>(convertedIndex));
+
+        setTaskName(resetType);
+
+        msg.read(iface, values);
+
+        const char* processName = "xyz.openbmc_project.State.Host0";
+        const char* objectPath = "/xyz/openbmc_project/state/os";
+        const char* interfaceName =
+            "xyz.openbmc_project.State.OperatingSystem.Status";
+        const char* propName = "PowerTransitionTimeOut";
+
+        auto chassis_Value = getPowerTransitionTimeOut(processName, objectPath,
+                                                       interfaceName, propName);
+        auto requestedPowerTransition = std::get<uint16_t>(chassis_Value);
+
+        if (iface == "xyz.openbmc_project.State.OperatingSystem.Status")
+        {
+            const uint16_t* timeOutValue = nullptr;
+            const std::string* osState = nullptr;
+
+            for (const auto& property : values)
+            {
+                if (property.first == "PowerTransitionTimeOut")
+                {
+                    timeOutValue = std::get_if<uint16_t>(&property.second);
+
+                    if (timeOutValue == nullptr)
+                    {
+                        taskData->messages.emplace_back(
+                            messages::internalError());
+                        return task::completed;
+                    }
+                }
+
+                if (property.first == "OperatingSystemState")
+                {
+                    osState = std::get_if<std::string>(&property.second);
+
+                    if (osState == nullptr)
+                    {
+                        taskData->messages.emplace_back(
+                            messages::internalError());
+                        return task::completed;
+                    }
+                }
+            }
+
+            if (timeOutValue != nullptr && *timeOutValue != 0)
+            {
+                setStatus(
+                    "xyz.openbmc_project.Common.Task.OperationStatus.New");
+                taskData->state = "Pending";
+                taskData->messages.emplace_back(messages::taskPaused(index));
+                taskData->extendTimer(std::chrono::minutes(10));
+                return !task::completed;
+            }
+
+            if (requestedPowerTransition == 0 && osState != nullptr &&
+                *osState ==
+                    "xyz.openbmc_project.State.OperatingSystem.Status.OSStatus.Standby")
+            {
+                setStatus(
+                    "xyz.openbmc_project.Common.Task.OperationStatus.InProgress");
+                taskData->state = "Running";
+                taskData->messages.emplace_back(messages::taskStarted(index));
+                taskData->extendTimer(std::chrono::minutes(5));
+                return !task::completed;
+            }
+
+            if (requestedPowerTransition == 0 && osState != nullptr &&
+                *osState ==
+                    "xyz.openbmc_project.State.OperatingSystem.Status.OSStatus.Inactive")
+            {
+                setStatus(
+                    "xyz.openbmc_project.Common.Task.OperationStatus.Completed");
+                taskData->messages.emplace_back(
+                    messages::taskCompletedOK(index));
+                taskData->state = "Completed";
+                return task::completed;
+            }
+            taskData->extendTimer(std::chrono::minutes(5));
+        }
+        return !task::completed;
+    },
+        "type='signal',interface='org.freedesktop.DBus.Properties',"
+        "member='PropertiesChanged',path='/xyz/openbmc_project/state/os'");
+    task->startTimer(std::chrono::minutes(5));
+    task->populateResp(asyncResp->res);
+    task->payload.emplace(std::move(payload));
+}
 
 /*
  * Function to create the reboot status task
@@ -3389,6 +3550,12 @@ void SystemsImmediateResetTask(
 
         std::string index = std::to_string(taskData->index);
 
+        int convertedIndex = std::stoi(index);
+
+        setTaskId(static_cast<uint16_t>(convertedIndex));
+
+        setTaskName(resetType);
+
         msg.read(iface, values);
 
         if (iface == "xyz.openbmc_project.State.OperatingSystem.Status")
@@ -3419,6 +3586,8 @@ void SystemsImmediateResetTask(
                 *osState ==
                     "xyz.openbmc_project.State.OperatingSystem.Status.OSStatus.Inactive")
             {
+                setStatus(
+                    "xyz.openbmc_project.Common.Task.OperationStatus.InProgress");
                 taskData->state = "Running";
                 taskData->messages.emplace_back(messages::taskStarted(index));
                 taskData->extendTimer(std::chrono::minutes(5));
@@ -3429,6 +3598,8 @@ void SystemsImmediateResetTask(
                 *osState ==
                     "xyz.openbmc_project.State.OperatingSystem.Status.OSStatus.Standby")
             {
+                setStatus(
+                    "xyz.openbmc_project.Common.Task.OperationStatus.InProgress");
                 taskData->state = "Running";
                 taskData->messages.emplace_back(messages::taskStarted(index));
                 taskData->extendTimer(std::chrono::minutes(5));
@@ -3439,6 +3610,8 @@ void SystemsImmediateResetTask(
                 *osState ==
                     "xyz.openbmc_project.State.OperatingSystem.Status.OSStatus.Standby")
             {
+                setStatus(
+                    "xyz.openbmc_project.Common.Task.OperationStatus.Completed");
                 taskData->messages.emplace_back(
                     messages::taskCompletedOK(index));
                 taskData->state = "Completed";
@@ -3450,6 +3623,8 @@ void SystemsImmediateResetTask(
                 *osState ==
                     "xyz.openbmc_project.State.OperatingSystem.Status.OSStatus.Inactive")
             {
+                setStatus(
+                    "xyz.openbmc_project.Common.Task.OperationStatus.Completed");
                 taskData->messages.emplace_back(
                     messages::taskCompletedOK(index));
                 taskData->state = "Completed";
@@ -3466,42 +3641,6 @@ void SystemsImmediateResetTask(
     task->payload.emplace(std::move(payload));
 }
 
-const PropertyValue getHostTransitionTimeOut(const std::string& servicePath,
-                                             const std::string& objectPath,
-                                             const std::string& interface,
-                                             const std::string& propertyName)
-{
-    BMCWEB_LOG_ERROR("getHostTransitionTimeOut");
-    PropertyValue value{};
-
-    auto b = sdbusplus::bus::new_default_system();
-    auto method = b.new_method_call(servicePath.c_str(), objectPath.c_str(),
-                                    dbus_Property_Interface, "Get");
-
-    method.append(interface, propertyName);
-    auto reply = b.call(method);
-    reply.read(value);
-    return value;
-}
-
-const PropertyValue getPowerTransitionTimeOut(const std::string& servicePath,
-                                              const std::string& objectPath,
-                                              const std::string& interface,
-                                              const std::string& propertyName)
-{
-    BMCWEB_LOG_ERROR("getPowerTransitionTimeOut");
-    PropertyValue value{};
-
-    auto b = sdbusplus::bus::new_default_system();
-    auto method = b.new_method_call(servicePath.c_str(), objectPath.c_str(),
-                                    dbus_Property_Interface, "Get");
-
-    method.append(interface, propertyName);
-    auto reply = b.call(method);
-    reply.read(value);
-    return value;
-}
-
 /**
  * Func give the timeout value in seconds
  *
@@ -3617,100 +3756,44 @@ inline void
 {
     BMCWEB_LOG_ERROR("systemResetAction");
 
-    const char* processName = "xyz.openbmc_project.State.Host";
-    const char* interfaceName = "xyz.openbmc_project.State.Host";
-    const char* propName = "CurrentHostState";
-    const char* objectPath = "/xyz/openbmc_project/state/host0";
-
-    auto value = getHostState(processName, objectPath, interfaceName, propName);
-    auto reqHostState = std::get<std::string>(value);
-
     std::string command;
     bool hostCommand = true;
+
     if ((resetType == "On") || (resetType == "ForceOn"))
     {
-        if (reqHostState == "xyz.openbmc_project.State.Host.HostState.Running")
-        {
-            BMCWEB_LOG_ERROR("Host is in Standby state");
-            NoOperation(asyncResp);
-            flag = false;
-        }
-        else
-        {
-            command = "xyz.openbmc_project.State.Host.Transition.On";
-            hostCommand = true;
-        }
+        command = "xyz.openbmc_project.State.Host.Transition.On";
+        hostCommand = true;
     }
+
     else if (resetType == "ForceOff")
     {
-        if (reqHostState != "xyz.openbmc_project.State.Host.HostState.Running")
-        {
-            BMCWEB_LOG_ERROR("Host is in Inactive state");
-            NoOperation(asyncResp);
-            flag = false;
-        }
-        else
-        {
-            command = "xyz.openbmc_project.State.Chassis.Transition.Off";
-            hostCommand = false;
-        }
+        command = "xyz.openbmc_project.State.Chassis.Transition.Off";
+        hostCommand = false;
     }
+
     else if (resetType == "ForceRestart")
     {
-        if (reqHostState != "xyz.openbmc_project.State.Host.HostState.Running")
-        {
-            NoOperation(asyncResp);
-            flag = false;
-        }
-        else
-        {
-            command =
-                "xyz.openbmc_project.State.Host.Transition.ForceWarmReboot";
-            hostCommand = true;
-        }
+        command = "xyz.openbmc_project.State.Host.Transition.ForceWarmReboot";
+        hostCommand = true;
     }
+
     else if (resetType == "GracefulShutdown")
     {
-        if (reqHostState != "xyz.openbmc_project.State.Host.HostState.Running")
-        {
-            BMCWEB_LOG_ERROR("Host is in Inactive state");
-            NoOperation(asyncResp);
-            flag = false;
-        }
-        else
-        {
-            command = "xyz.openbmc_project.State.Host.Transition.Off";
-            hostCommand = true;
-        }
+        command = "xyz.openbmc_project.State.Host.Transition.Off";
+        hostCommand = true;
     }
+
     else if (resetType == "GracefulRestart")
     {
-        if (reqHostState != "xyz.openbmc_project.State.Host.HostState.Running")
-        {
-            NoOperation(asyncResp);
-            flag = false;
-        }
-        else
-        {
-            command =
-                "xyz.openbmc_project.State.Host.Transition.GracefulWarmReboot";
-            hostCommand = true;
-        }
+        command =
+            "xyz.openbmc_project.State.Host.Transition.GracefulWarmReboot";
+        hostCommand = true;
     }
+
     else if (resetType == "PowerCycle")
     {
         command = "xyz.openbmc_project.State.Host.Transition.Reboot";
         hostCommand = true;
-        if (reqHostState != "xyz.openbmc_project.State.Host.HostState.Running")
-        {
-            NoOperation(asyncResp);
-            flag = false;
-        }
-        else
-        {
-            command = "xyz.openbmc_project.State.Host.Transition.Reboot";
-            hostCommand = true;
-        }
     }
     else
     {
@@ -3778,14 +3861,16 @@ inline void handleComputerSystemResetActionPost(
         return;
     }
 
-    const char* processName = "xyz.openbmc_project.State.Chassis";
-    const char* objectPath = "/xyz/openbmc_project/state/chassis0";
-    const char* interfaceName = "xyz.openbmc_project.State.Chassis";
-    const char* propName = "PowerTransitionTimeOut";
+    const char* process_Name = "xyz.openbmc_project.State.Host";
+    const char* interface_Name = "xyz.openbmc_project.State.Host";
+    const char* propertyName = "CurrentHostState";
+    const char* object_Path = "/xyz/openbmc_project/state/host0";
 
-    const char* processPath = "xyz.openbmc_project.State.Host0";
-    const char* objectName = "/xyz/openbmc_project/state/host0";
-    const char* interfacePath = "xyz.openbmc_project.State.Host";
+    const char* processName = "xyz.openbmc_project.State.Host0";
+    const char* objectPath = "/xyz/openbmc_project/state/os";
+    const char* interfaceName =
+        "xyz.openbmc_project.State.OperatingSystem.Status";
+    const char* propName = "PowerTransitionTimeOut";
     const char* prop_Name = "HostTransitionTimeOut";
 
     std::string resetType;
@@ -3799,14 +3884,19 @@ inline void handleComputerSystemResetActionPost(
     std::string redfishDateTimeOffset =
         crow::utility::getDateTimeOffsetNow().first;
 
-    auto host_Value = getHostTransitionTimeOut(processPath, objectName,
-                                               interfacePath, prop_Name);
+    auto host_Value = getHostTransitionTimeOut(processName, objectPath,
+                                               interfaceName, prop_Name);
+
     auto requestedHostTransition = std::get<uint16_t>(host_Value);
 
     auto chassis_Value = getPowerTransitionTimeOut(processName, objectPath,
                                                    interfaceName, propName);
     auto requestedPowerTransition = std::get<uint16_t>(chassis_Value);
 
+    auto value = getHostState(process_Name, object_Path, interface_Name,
+                              propertyName);
+    auto reqHostState = std::get<std::string>(value);
+
     if (!json_util::readJsonAction(req, asyncResp->res, "ResetType", resetType,
                                    "OperationApplyTime", operationApplyTime,
                                    "MaintenanceWindowStartTime",
@@ -3818,46 +3908,43 @@ inline void handleComputerSystemResetActionPost(
     // To provide as a stringstream object
     startTime = *maintenanceWindowStartTime;
 
-    if ((resetType == "ForceOff" && requestedPowerTransition != 0) ||
-        (resetType != "ForceOff" && requestedHostTransition != 0))
-    {
-        BMCWEB_LOG_ERROR("Already One Reboot Task is running");
-        messages::resourceInUse(asyncResp->res);
-        return;
-    }
-    if (!(resetType.empty()) && !operationApplyTime &&
-        !maintenanceWindowStartTime)
+    if ((resetType == "On") || (resetType == "ForceOn"))
     {
-        systemResetAction(asyncResp, resetType);
-        if (flag == true)
+        if (reqHostState == "xyz.openbmc_project.State.Host.HostState.Running")
         {
-            messages::success(asyncResp->res);
+            BMCWEB_LOG_ERROR(" Host is in Standby state");
+            NoOperation(asyncResp);
             return;
         }
-        else
+    }
+
+    else if (resetType == "ForceOff" || resetType == "ForceRestart" ||
+             resetType == "GracefulShutdown" ||
+             resetType == "GracefulRestart" || resetType == "PowerCycle")
+    {
+        if (reqHostState != "xyz.openbmc_project.State.Host.HostState.Running")
         {
-            flag = true;
+            NoOperation(asyncResp);
             return;
         }
     }
 
+    if (!(resetType.empty()) && !operationApplyTime &&
+        !maintenanceWindowStartTime)
+    {
+        systemResetAction(asyncResp, resetType);
+        messages::success(asyncResp->res);
+        return;
+    }
+
     if (operationApplyTime == "Immediate")
     {
         BMCWEB_LOG_ERROR("Immediate Reset");
         if (!(maintenanceWindowStartTime))
         {
+            SystemsImmediateResetTask(asyncResp, std::move(payload), resetType);
             systemResetAction(asyncResp, resetType);
-            if (flag == true)
-            {
-                SystemsImmediateResetTask(asyncResp, std::move(payload),
-                                          resetType);
-                return;
-            }
-            else
-            {
-                flag = true;
-                return;
-            }
+            return;
         }
 
         else
@@ -3911,40 +3998,32 @@ inline void handleComputerSystemResetActionPost(
 
             if (resetType == "ForceOff")
             {
-                setSystemsPowerTransitionTimer(asyncResp, timeOut);
-                systemResetAction(asyncResp, resetType);
-                if (flag == true)
+                if (requestedPowerTransition != 0)
                 {
-                    //     createSystemMaintenanceWindowTask(asyncResp,
-                    //     std::move(payload));
-                    SystemsImmediateResetTask(asyncResp, std::move(payload),
-                                              resetType);
-                    return;
-                }
-                else
-                {
-                    flag = true;
+                    messages::resourceInUse(asyncResp->res);
                     return;
                 }
+
+                setSystemsPowerTransitionTimer(asyncResp, timeOut);
+                createSystemMaintenanceWindowTask(asyncResp, std::move(payload),
+                                                  resetType);
+                systemResetAction(asyncResp, resetType);
+                return;
             }
 
             if (resetType != "ForceOff")
             {
-                setHostTransitionTimer(asyncResp, timeOut);
-                systemResetAction(asyncResp, resetType);
-                if (flag == true)
-                {
-                    // createResetMaintenanceWindowTask(asyncResp,
-                    // std::move(payload));
-                    SystemsImmediateResetTask(asyncResp, std::move(payload),
-                                              resetType);
-                    return;
-                }
-                else
+                if (requestedHostTransition != 0)
                 {
-                    flag = true;
+                    messages::resourceInUse(asyncResp->res);
                     return;
                 }
+
+                setHostTransitionTimer(asyncResp, timeOut);
+                createResetMaintenanceWindowTask(asyncResp, std::move(payload),
+                                                 resetType);
+                systemResetAction(asyncResp, resetType);
+                return;
             }
         }
         else
@@ -3957,7 +4036,6 @@ inline void handleComputerSystemResetActionPost(
     }
 }
 
-
 inline void handleComputerSystemHead(
     App& app, const crow::Request& req,
     const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
-- 
2.34.1

