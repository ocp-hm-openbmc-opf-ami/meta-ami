From e831a7dc8f25f759468ff312bec9ecafb0636b3f Mon Sep 17 00:00:00 2001
From: Nibin Chacko <nibinc@ami.com>
Date: Mon, 17 Jul 2023 14:03:51 +0530
Subject: [PATCH 5/5] added ipv6staticDefaultGateways property

---
 redfish-core/lib/ethernet.hpp | 127 +++++++++++++++++++++++++++++++++-
 1 file changed, 125 insertions(+), 2 deletions(-)

diff --git a/redfish-core/lib/ethernet.hpp b/redfish-core/lib/ethernet.hpp
index ff3522c9..263b69d3 100644
--- a/redfish-core/lib/ethernet.hpp
+++ b/redfish-core/lib/ethernet.hpp
@@ -59,6 +59,24 @@ struct IPv4AddressData
     bool isActive{};
 };
 
+struct IPv6StaticDefaultGatewaysData
+{
+   IPv6StaticDefaultGatewaysData(const std::string& id,
+                                 const std::string address,
+                                 const uint8_t prefixLength) :
+       id(id),
+       address(address), prefixLength(prefixLength)
+   {}
+   std::string id;
+   std::string address;
+   uint8_t prefixLength;
+
+   bool operator<(const IPv6StaticDefaultGatewaysData& obj) const
+   {
+      return id < obj.id;
+   }  
+};
+
 /**
  * Structure for keeping IPv6 data required by Redfish
  */
@@ -1429,6 +1447,101 @@ inline void handleStaticNameServersPatch(
         dbus::utility::DbusVariantType{updatedStaticNameServers});
 }
 
+inline void updateIPv6DefaultGateway(
+    const std::string& ifaceId, const std::string& gateway,
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
+{
+    crow::connections::systemBus->async_method_call(
+        [asyncResp](const boost::system::error_code ec) {
+            if (ec)
+            {
+                messages::internalError(asyncResp->res);
+                return;
+            }
+            asyncResp->res.result(boost::beast::http::status::no_content);
+        },
+        "xyz.openbmc_project.Network",
+        "/xyz/openbmc_project/network/" + ifaceId,
+        "org.freedesktop.DBus.Properties", "Set",
+        "xyz.openbmc_project.Network.EthernetInterface", "DefaultGateway6",
+        dbus::utility::DbusVariantType(gateway));
+}
+
+inline void handleIPv6StaticDefaultGatewaysPatch(
+    const std::string& ifaceId, const nlohmann::json& input,
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
+{
+    if (!input.is_array() || input.empty())
+    {
+        messages::propertyValueTypeError(
+            asyncResp->res,
+            input.dump(2, ' ', true, nlohmann::json::error_handler_t::replace),
+            "IPv6StaticDefaultGateways");
+        return;
+    }
+
+    size_t entryIdx = 1;
+    boost::container::flat_set<IPv6StaticDefaultGatewaysData> ipv6GatewaysData;
+    for (const nlohmann::json& thisJson : input)
+    {
+        std::string pathString =
+            "IPv6StaticDefaultGateways/" + std::to_string(entryIdx);
+
+        if (!thisJson.is_null() && !thisJson.empty())
+        {
+            std::optional<std::string> address;
+            std::optional<uint8_t> prefixLength;
+            nlohmann::json thisJsonCopy = thisJson;
+
+            if (!json_util::readJson(thisJsonCopy, asyncResp->res, "Address",
+                                     address, "PrefixLength", prefixLength))
+            {
+                messages::propertyValueFormatError(
+                    asyncResp->res,
+                    thisJson.dump(2, ' ', true,
+                                  nlohmann::json::error_handler_t::replace),
+                    pathString);
+                return;
+            }
+
+            const std::string* addr;
+            uint8_t prefix;
+            if (address)
+            {
+                addr = &(*address);
+            }
+            else
+            {
+                messages::propertyMissing(asyncResp->res,
+                                          pathString + "/Address");
+                return;
+            }
+            if (prefixLength)
+            {
+                prefix = *prefixLength;
+            }
+            else
+            {
+                messages::propertyMissing(asyncResp->res,
+                                          pathString + "/PrefixLength");
+                return;
+            }
+            if (entryIdx == 1)
+            {
+                updateIPv6DefaultGateway(ifaceId, *addr, asyncResp);
+            }
+            ipv6GatewaysData.emplace(std::to_string(entryIdx), *addr, prefix);
+            entryIdx++;
+        }
+        else
+        {
+            updateIPv6DefaultGateway(ifaceId, "", asyncResp);
+        }
+    }
+}
+
+
+
 inline void handleIPv6StaticAddressesPatch(
     const std::string& ifaceId, const nlohmann::json::array_t& input,
     const std::vector<IPv6AddressData>& ipv6Data,
@@ -1800,6 +1913,7 @@ inline void requestEthernetInterfacesRoutes(App& app)
         std::optional<std::string> fqdn;
         std::optional<std::string> macAddress;
         std::optional<std::string> ipv6DefaultGateway;
+        std::optional<nlohmann::json> ipv6StaticDefaultGateways;
         std::optional<nlohmann::json::array_t> ipv4StaticAddresses;
         std::optional<nlohmann::json::array_t> ipv6StaticAddresses;
         std::optional<std::vector<std::string>> staticNameServers;
@@ -1814,7 +1928,8 @@ inline void requestEthernetInterfacesRoutes(App& app)
                 req, asyncResp->res, "HostName", hostname, "FQDN", fqdn,
                 "IPv4StaticAddresses", ipv4StaticAddresses, "MACAddress",
                 macAddress, "StaticNameServers", staticNameServers,
-                "IPv6DefaultGateway", ipv6DefaultGateway, "IPv6StaticAddresses",
+                "IPv6DefaultGateway", ipv6DefaultGateway,"IPv6StaticDefaultGateways",
+                ipv6StaticDefaultGateways, "IPv6StaticAddresses",
                 ipv6StaticAddresses, "DHCPv4", dhcpv4, "DHCPv6", dhcpv6,
                 "MTUSize", mtuSize, "InterfaceEnabled", interfaceEnabled))
         {
@@ -1853,6 +1968,8 @@ inline void requestEthernetInterfacesRoutes(App& app)
              fqdn = std::move(fqdn), macAddress = std::move(macAddress),
              ipv4StaticAddresses = std::move(ipv4StaticAddresses),
              ipv6DefaultGateway = std::move(ipv6DefaultGateway),
+             ipv6StaticDefaultGateways =
+                         std::move(ipv6StaticDefaultGateways),
              ipv6StaticAddresses = std::move(ipv6StaticAddresses),
              staticNameServers = std::move(staticNameServers),
              dhcpv4 = std::move(dhcpv4), dhcpv6 = std::move(dhcpv6), mtuSize,
@@ -1925,7 +2042,7 @@ inline void requestEthernetInterfacesRoutes(App& app)
             }
 
             if (ipv4StaticAddresses)
-            {
+        {
 		if(!v4dhcpParms.dhcpv4Enabled)
 		{
 		   messages::propertyMissing(asyncResp->res, "DHCPv4.DHCPEnabled");
@@ -1956,6 +2073,12 @@ inline void requestEthernetInterfacesRoutes(App& app)
                 messages::propertyNotWritable(asyncResp->res,
                                               "IPv6DefaultGateway");
             }
+            if (ipv6StaticDefaultGateways)
+            {
+                nlohmann::json ipv6Gateways = *ipv6StaticDefaultGateways;
+                handleIPv6StaticDefaultGatewaysPatch(ifaceId, ipv6Gateways,
+                                                     asyncResp);
+            }
 
             if (ipv6StaticAddresses)
             {
-- 
2.25.1

