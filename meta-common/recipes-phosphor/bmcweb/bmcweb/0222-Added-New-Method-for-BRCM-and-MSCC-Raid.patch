From af866ae34423ebabffed1b78ab9f7b8643db913b Mon Sep 17 00:00:00 2001
From: Pranoy Goru <gorumanip@ami.com>
Date: Thu, 28 Mar 2024 20:33:53 +0530
Subject: [PATCH 235/235] Added New Method for BRCM and MSCC Raid

Description:
----------
BRCM RAID|
---------

-------------------------------------------------------
busctl tree xyz.openbmc_project.raid.manager
`- /xyz
  `- /xyz/openbmc_project
    `- /xyz/openbmc_project/Raid
      `- /xyz/openbmc_project/Raid/0
        |- /xyz/openbmc_project/Raid/0/ld
        | `- /xyz/openbmc_project/Raid/0/ld/0
        `- /xyz/openbmc_project/Raid/0/pd
          |- /xyz/openbmc_project/Raid/0/pd/0
          |- /xyz/openbmc_project/Raid/0/pd/1
          |- /xyz/openbmc_project/Raid/0/pd/2
          `- /xyz/openbmc_project/Raid/0/pd/3

--------------------------------------------------------
busctl introspect xyz.openbmc_project.raid.manager /xyz/openbmc_project/Raid
NAME                                TYPE      SIGNATURE         RESULT/VALUE  FLAGS
org.freedesktop.DBus.Introspectable interface -                 -             -
.Introspect                         method    -                 s             -
org.freedesktop.DBus.ObjectManager  interface -                 -             -
.GetManagedObjects                  method    -                 a{oa{sa{sv}}} -
.InterfacesAdded                    signal    oa{sa{sv}}        -             -
.InterfacesRemoved                  signal    oas               -             -
org.freedesktop.DBus.Peer           interface -                 -             -
.GetMachineId                       method    -                 s             -
.Ping                               method    -                 -             -
org.freedesktop.DBus.Properties     interface -                 -             -
.Get                                method    ss                v             -
.GetAll                             method    s                 a{sv}         -
.Set                                method    ssv               -             -
.PropertiesChanged                  signal    sa{sv}as          -             -
xyz.openbmc_project.raid.Base       interface -                 -             -
.AddGlobalHotSpare                  method    uq                t             -
.CreateLogicalDrive                 method    ussttyyyyyyyyayaq t             -
.DeleteLogicalDrive                 method    uq                t             -
.PreparePhysicalDriveForRemoval     method    uq                t             -
.RemoveHotSpare                     method    uq                t             -
.SetControllerPersonality           method    us                t             -
.SetControllerProperties            method    uyyyyybb          t             -
.SetCopybackConfiguration           method    ubbb              t             -
.SetLogicalDriveProperties          method    uqsyyyyyb         t             -
.SetPhysicalDriveState              method    uqs               t             -
.StartCopyback                      method    uqq               t             -
.StartLocateLogicalDrive            method    uqy               t             -
.StartLocatePhysicalDrive           method    uqy               t             -
.StopCopyback                       method    uq                t             -
.StopLocateLogicalDrive             method    uq                t             -
.StopLocatePhysicalDrive            method    uq                t             -
.UndoPreparePhysicalDriveForRemoval method    uq                t             -
.Count                              property  u                 1             emits-change
.MethodCompletedSignal              signal    tss               -             -

-------------------------------------------------------------------------------------------
busctl introspect xyz.openbmc_project.raid.manager /xyz/openbmc_project/Raid/0
NAME                                TYPE      SIGNATURE RESULT/VALUE                             FLAGS
org.freedesktop.DBus.Introspectable interface -         -                                        -
.Introspect                         method    -         s                                        -
org.freedesktop.DBus.Peer           interface -         -                                        -
.GetMachineId                       method    -         s                                        -
.Ping                               method    -         -                                        -
org.freedesktop.DBus.Properties     interface -         -                                        -
.Get                                method    ss        v                                        -
.GetAll                             method    s         a{sv}                                    -
.Set                                method    ssv       -                                        -
.PropertiesChanged                  signal    sa{sv}as  -                                        -
xyz.openbmc_project.raid.Controller interface -         -                                        -
.BgiRate                            property  y         4                                        emits-change
.ConsistencyCheckRate               property  y         5                                        emits-change
.CurrentPersonality                 property  s         "Raid"                                   emits-change
.EnableCopyback                     property  b         true                                     emits-change
.EnableHddSmartCopyback             property  b         false                                    emits-change
.EnableJbod                         property  b         false                                    emits-change
.EnableSsdPatrolRead                property  b         true                                     emits-change
.EnableSsdSmartCopyback             property  b         false                                    emits-change
.FirmwareVersion                    property  s         "5.270.02-3937"                          emits-change
.Health                             property  s         "OK"                                     emits-change
.Id                                 property  u         341                                      emits-change
.Model                              property  s         "MegaRAID 9560-16i 8GB"                  emits-change
.PatrolReadRate                     property  y         1                                        emits-change
.RebuildRate                        property  y         2                                        emits-change
.ReconstructionRate                 property  y         3                                        emits-change
.RequestedPersonality               property  s         "Undefined"                              emits-change
.SerialNumber                       property  s         "SKC3138120"                             emits-change
.SupportedPersonality               property  as        5 "Raid" "Hba" "Sds" "Jbod" "RaidAndJ... emits-change
.SupportedRaidLevel                 property  as        8 "RAID0" "RAID1" "RAID5" "RAID6" "RA... emits-change
.SupportedStripSize                 property  at        5 65536 131072 262144 524288 1048576     emits-change

----------------------------------------------------------------------------------------------------------------

busctl introspect xyz.openbmc_project.raid.manager /xyz/openbmc_project/Raid/0/ld
NAME                                TYPE      SIGNATURE RESULT/VALUE FLAGS
org.freedesktop.DBus.Introspectable interface -         -            -
.Introspect                         method    -         s            -
org.freedesktop.DBus.Peer           interface -         -            -
.GetMachineId                       method    -         s            -
.Ping                               method    -         -            -
org.freedesktop.DBus.Properties     interface -         -            -
.Get                                method    ss        v            -
.GetAll                             method    s         a{sv}        -
.Set                                method    ssv       -            -
.PropertiesChanged                  signal    sa{sv}as  -            -
xyz.openbmc_project.raid.LD         interface -         -            -
.Count                              property  u         1            emits-change

----------------------------------------------------------------------------------------------------------------

busctl introspect xyz.openbmc_project.raid.manager /xyz/openbmc_project/Raid/0/ld/0
NAME                                  TYPE      SIGNATURE RESULT/VALUE   FLAGS
org.freedesktop.DBus.Introspectable   interface -         -              -
.Introspect                           method    -         s              -
org.freedesktop.DBus.Peer             interface -         -              -
.GetMachineId                         method    -         s              -
.Ping                                 method    -         -              -
org.freedesktop.DBus.Properties       interface -         -              -
.Get                                  method    ss        v              -
.GetAll                               method    s         a{sv}          -
.Set                                  method    ssv       -              -
.PropertiesChanged                    signal    sa{sv}as  -              -
xyz.openbmc_project.raid.LogicalDrive interface -         -              -
.CapacityBytes                        property  t         499558383616   emits-change
.EnableBgi                            property  b         false          emits-change
.Health                               property  s         "OK"           emits-change
.Id                                   property  q         239            emits-change
.Name                                 property  s         "test2"        emits-change
.PdList                               property  aq        2 6 48         emits-change
.RaidLevel                            property  s         "RAID1"        emits-change
.ReadCachePolicyType                  property  s         "ReadAhead"    emits-change
.StripSizeBytes                       property  t         262144         emits-change
.WriteCachePolicyType                 property  s         "WriteThrough" emits-change

---------------------------------------------------------------------------------------------------------------

busctl introspect xyz.openbmc_project.raid.manager /xyz/openbmc_project/Raid/0/pd
NAME                                TYPE      SIGNATURE RESULT/VALUE FLAGS
org.freedesktop.DBus.Introspectable interface -         -            -
.Introspect                         method    -         s            -
org.freedesktop.DBus.Peer           interface -         -            -
.GetMachineId                       method    -         s            -
.Ping                               method    -         -            -
org.freedesktop.DBus.Properties     interface -         -            -
.Get                                method    ss        v            -
.GetAll                             method    s         a{sv}        -
.Set                                method    ssv       -            -
.PropertiesChanged                  signal    sa{sv}as  -            -
xyz.openbmc_project.raid.PD         interface -         -            -
.Count                              property  u         4            emits-change

---------------------------------------------------------------------------------------------------------------

 busctl introspect xyz.openbmc_project.raid.manager /xyz/openbmc_project/Raid/0/pd/0
NAME                                   TYPE      SIGNATURE RESULT/VALUE      FLAGS
org.freedesktop.DBus.Introspectable    interface -         -                 -
.Introspect                            method    -         s                 -
org.freedesktop.DBus.Peer              interface -         -                 -
.GetMachineId                          method    -         s                 -
.Ping                                  method    -         -                 -
org.freedesktop.DBus.Properties        interface -         -                 -
.Get                                   method    ss        v                 -
.GetAll                                method    s         a{sv}             -
.Set                                   method    ssv       -                 -
.PropertiesChanged                     signal    sa{sv}as  -                 -
xyz.openbmc_project.raid.PhysicalDrive interface -         -                 -
.BlockSizeBytes                        property  t         4096              emits-change
.CopybackProgress                      property  y         0                 emits-change
.FailurePredicted                      property  u         0                 emits-change
.Health                                property  s         "OK"              emits-change
.Id                                    property  q         6                 emits-change
.InterfaceType                         property  s         "SATA"            emits-change
.LinkSpeed                             property  s         "3_0Gbps"         emits-change
.Manufacturer                          property  s         "ATA"             emits-change
.ProductId                             property  s         "WDCWD5000BPKT-0" emits-change
.Revision                              property  s         "SATA1A01"        emits-change
.SerialNumber                          property  s         "WD-WX21C6262949" emits-change
.Slot                                  property  s         "5"               emits-change
.State                                 property  s         "Online"          emits-change

--------------------------------------------------------------------------------------------------------------

Test Cases

1) Get RAID Device count
https://{{BMCIP}}/redfish/v1/Systems/system/Storage/
Body

{
    "@odata.id": "/redfish/v1/Systems/system/Storage",
    "@odata.type": "#StorageCollection.StorageCollection",
    "Members": [
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_0"
        }
    ],
    "Members@odata.count": 1,
    "Name": "Storage Collection"
}

2) Get Raid Instance
https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Raid_0

{
    "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_0",
    "@odata.type": "#Storage.v1_10_1.Storage",
    "Actions": {
        "Oem": {
            "#StorageCollection.AddGlobalHotSpare": {
                "target": "/redfish/v1/Systems/system/Storage/Raid_0/Actions/StoragePDrive.AddGlobalHotSpare"
            },
            "#StorageCollection.CopybackConfigurationAction": {
                "target": "/redfish/v1/Systems/system/Storage/Raid_0/Actions/StorageDrive.CopybackConfigurationAction"
            },
            "#StorageCollection.CreateDrive": {
                "target": "/redfish/v1/Systems/system/Storage/Raid_0/Actions/StorageLDrive.Create"
            },
            "#StorageCollection.DeleteDrive": {
                "target": "/redfish/v1/Systems/system/Storage/Raid_0/Actions/StorageLDrive.Delete"
            },
            "#StorageCollection.DeleteGlobalHotSpare": {
                "target": "/redfish/v1/Systems/system/Storage/Raid_0/Actions/StoragePDrive.DeleteGlobalHotSpare"
            },
            "#StorageCollection.PrepareRemovalAction": {
                "target": "/redfish/v1/Systems/system/Storage/Raid_0/Actions/StoragePDrive.PrepareRemovalAction"
            },
            "#StorageCollection.SetControllerPersonalityAction": {
                "target": "/redfish/v1/Systems/system/Storage/Raid_0/Actions/StorageDrive.SetControllerPersonalityAction"
            },
            "#StorageCollection.SetControllerPropertiesAction": {
                "target": "/redfish/v1/Systems/system/Storage/Raid_0/Actions/StorageDrive.SetControllerPropertiesAction"
            },
            "#StorageCollection.SetLogicalDrivePropertiesAction": {
                "target": "/redfish/v1/Systems/system/Storage/Raid_0/Actions/StorageLDrive.SetLogicalDrivePropertiesAction"
            },
            "#StorageCollection.SetPhysicalDriveStateAction": {
                "target": "/redfish/v1/Systems/system/Storage/Raid_0/Actions/StoragePDrive.SetPhysicalDriveStateAction"
            },
            "#StorageCollection.StartCopybackAction": {
                "target": "/redfish/v1/Systems/system/Storage/Raid_0/Actions/StorageDrive.StartCopybackAction"
            },
            "#StorageCollection.StartLocateLogicalDriveAction": {
                "target": "/redfish/v1/Systems/system/Storage/Raid_0/Actions/StorageLDrive.StartLocateLogicalDriveAction"
            },
            "#StorageCollection.StartLocatePhysicalDriveAction": {
                "target": "/redfish/v1/Systems/system/Storage/Raid_0/Actions/StoragePDrive.StartLocatePhysicalDriveAction"
            },
            "#StorageCollection.StopCopybackAction": {
                "target": "/redfish/v1/Systems/system/Storage/Raid_0/Actions/StorageDrive.StopCopybackAction"
            },
            "#StorageCollection.StopLocateLogicalDriveAction": {
                "target": "/redfish/v1/Systems/system/Storage/Raid_0/Actions/StorageLDrive.StopLocateLogicalDriveAction"
            },
            "#StorageCollection.StopLocatePhysicalDriveAction": {
                "target": "/redfish/v1/Systems/system/Storage/Raid_0/Actions/StoragePDrive.StopLocatePhysicalDriveAction"
            },
            "#StorageCollection.UndoPrepareRemovalAction": {
                "target": "/redfish/v1/Systems/system/Storage/Raid_0/Actions/StoragePDrive.UndoPrepareRemovalAction"
            }
        }
    },
    "Description": "Integrated Raid Controller",
    "Drives": [
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_0/Drives/0"
        },
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_0/Drives/1"
        },
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_0/Drives/2"
        },
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_0/Drives/3"
        }
    ],
    "Drives@odata.count": 4,
    "Id": "Raid_0",
    "Name": "Local Storage Controller",
    "Oem": {
        "OpenBmc": {
            "@odata.type": "#OemStorage.v1_0_0.OemStorage",
            "BgiRate": 4,
            "CurrentPersonality": "Raid",
            "EnableCopyback": true,
            "EnableHddSmartCopyback": false,
            "EnableJbod": false,
            "EnableSsdPatrolRead": true,
            "EnableSsdSmartCopyback": false,
            "PatrolReadRate": 1,
            "RequestedPersonality": "Undefined",
            "SupportedPersonality": [
                "Raid",
                "Hba",
                "Sds",
                "Jbod",
                "RaidAndJbod"
            ],
            "SupportedStripSize": [
                65536,
                131072,
                262144,
                524288,
                1048576
            ]
        }
    },
    "Rates": [
        {
            "ConsistencyCheckRatePercent": 5,
            "RebuildRatePercent": 2,
            "TransformationRatePercent": 3
        }
    ],
    "Status": {
        "Health": "OK",
        "State": "Enabled"
    },
    "StorageControllers": [
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_0#/StorageControllers/0",
            "FirmwareVersion": "5.270.02-3937",
            "MemberId": "0",
            "Model": "MegaRAID 9560-16i 8GB",
            "Name": "Local Storage Controller",
            "SerialNumber": "SKC3138120",
            "SupportedRAIDTypes": [
                "RAID0",
                "RAID1",
                "RAID5",
                "RAID6",
                "RAID00",
                "RAID10",
                "RAID50",
                "RAID60"
            ]
        }
    ],
    "Volumes": {
        "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_0/Volumes"
    }
}

3) Get logical Drives
https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Raid_0/Volumes

{
    "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_0/Volumes",
    "@odata.type": "#VolumeCollection.VolumeCollection",
    "Description": "The Collection of Volumes",
    "Members": [
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_0/Volumes/0"
        }
    ],
    "Members@odata.count": 1,
    "Name": "Volume Collection"
}

4) Get logical Drive instance
https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Raid_0/Volumes/0

{
    "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_0/Volumes/0",
    "@odata.type": "#Volume.v1_6_2.Volume",
    "CapacityBytes": 999116767232,
    "Id": "0",
    "Links": {
        "Drives": [
            {
                "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_0/Drives/0"
            },
            {
                "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_0/Drives/1"
            },
            {
                "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_0/Drives/2"
            },
            {
                "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_0/Drives/3"
            }
        ],
        "Drives@odata.count": 4
    },
    "Name": "test2",
    "Oem": {
        "OpenBmc": {
            "@odata.type": "#OemVolume.v1_0_0.Volume",
            "EnableBgi": false,
            "LDeviceId": 239,
            "PdList": [
                6,
                48
            ]
        }
    },
    "RAIDType": "RAID0",
    "ReadCachePolicy": "ReadAhead",
    "Status": {
        "Health": "OK",
        "State": "Enabled"
    },
    "StripSizeBytes": 262144,
    "WriteCachePolicy": "WriteThrough"
}

5) Get Physical Drive Instance
https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Raid_0/Drives/0

{
    "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_0/Drives/0",
    "@odata.type": "#Drive.v1_13_0.Drive",
    "BlockSizeBytes": 4096,
    "FailurePredicted": false,
    "Id": "0",
    "Links": {
        "Storage": {
            "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_0"
        },
        "Volumes": [
            {
                "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_0/Volumes/0"
            }
        ],
        "Volumes@odata.count": 1
    },
    "Manufacturer": "ATA",
    "Name": "PhysicalDrive_0",
    "NegotiatedSpeedGbs": 30,
    "Oem": {
        "OpenBmc": {
            "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_0/Drives/0#/Oem/OpenBmc",
            "@odata.type": "#OemDrive.v1_0_0.Drive",
            "CopybackProgress": 0,
            "PDeviceId": 6,
            "PDrivestate": "Online",
            "ProductId": "WDCWD5000BPKT-0",
            "Slot": "5"
        }
    },
    "Protocol": "SATA",
    "Revision": "SATA1A01",
    "SerialNumber": "WD-WX21C6262949",
    "Status": {
        "Health": "OK"
    }
}

6) Delete Logical Drive
https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Raid_0/Actions/StorageLDrive.Delete
Body

{
    "LDriveId": "0"
}

Reponse : 202

{
    "@odata.id": "/redfish/v1/TaskService/Tasks/1",
    "@odata.type": "#Task.v1_4_3.Task",
    "Id": "1",
    "TaskState": "New"
}

https://{{BMCIP}}/redfish/v1/TaskService/Tasks/1
Reponse : 202

{
    "@odata.id": "/redfish/v1/TaskService/Tasks/1",
    "@odata.type": "#Task.v1_4_3.Task",
    "EndTime": "2024-03-13T11:43:16+00:00",
    "HidePayload": false,
    "Id": "1",
    "Messages": [
        {
            "@odata.type": "#Message.v1_1_1.Message",
            "Message": "The task with Id '1' has started.",
            "MessageArgs": [
                "1"
            ],
            "MessageId": "TaskEvent.1.0.3.TaskStarted",
            "MessageSeverity": "OK",
            "Resolution": "None."
        },
        {
            "@odata.type": "#Message.v1_1_1.Message",
            "Message": "The task with Id '1' has completed.",
            "MessageArgs": [
                "1"
            ],
            "MessageId": "TaskEvent.1.0.3.TaskCompletedOK",
            "MessageSeverity": "OK",
            "Resolution": "None."
        }
    ],
    "Name": "Task 1",
    "Payload": {
        "HttpHeaders": [
            "User-Agent: PostmanRuntime/7.37.0",
            "Accept: */*",
            "Host: 172.31.96.135",
            "Accept-Encoding: gzip, deflate, br",
            "Connection: keep-alive",
            "Content-Length: 25"
        ],
        "HttpOperation": "POST",
        "JsonBody": "{\n  \"LDriveId\": \"0\"\n}",
        "TargetUri": "/redfish/v1/Systems/system/Storage/Raid_0/Actions/StorageLDrive.Delete"
    },
    "PercentComplete": 100,
    "StartTime": "2024-03-13T11:43:15+00:00",
    "TaskMonitor": "/redfish/v1/TaskService/Tasks/1/Monitor",
    "TaskState": "SUCCESS"
}

7) Creating Logical Drive
https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Raid_0/Actions/StorageLDrive.Create
Body

{
    "LDName": "test2",
    "RaidLevel": "RAID1",
    "Size": 0,
    "StripeSize": 262144,
    "InitState": 0,
    "DiskCachePolicy": 1,
    "Readpolicy": 1,
    "Writepolicy": 1,
    "Iopolicy": 0,
    "Accesspolicy": 0,
    "SpanDepth": 1,
    "NumDrives": 2,
    "SpanID": [
        0,
        0
    ],
    "DeviceID": [
        6,
        48
    ]
}

Reponse: 202

{
    "@odata.id": "/redfish/v1/TaskService/Tasks/2",
    "@odata.type": "#Task.v1_4_3.Task",
    "Id": "2",
    "TaskState": "New"
}

https://{{BMCIP}}/redfish/v1/TaskService/Tasks/2
response : 200

{
    "@odata.id": "/redfish/v1/TaskService/Tasks/2",
    "@odata.type": "#Task.v1_4_3.Task",
    "EndTime": "2024-03-13T11:50:28+00:00",
    "HidePayload": false,
    "Id": "2",
    "Messages": [
        {
            "@odata.type": "#Message.v1_1_1.Message",
            "Message": "The task with Id '2' has started.",
            "MessageArgs": [
                "2"
            ],
            "MessageId": "TaskEvent.1.0.3.TaskStarted",
            "MessageSeverity": "OK",
            "Resolution": "None."
        },
        {
            "@odata.type": "#Message.v1_1_1.Message",
            "Message": "The task with Id '2' has completed.",
            "MessageArgs": [
                "2"
            ],
            "MessageId": "TaskEvent.1.0.3.TaskCompletedOK",
            "MessageSeverity": "OK",
            "Resolution": "None."
        }
    ],
    "Name": "Task 2",
    "Payload": {
        "HttpHeaders": [
            "User-Agent: PostmanRuntime/7.37.0",
            "Accept: */*",
            "Host: 172.31.96.135",
            "Accept-Encoding: gzip, deflate, br",
            "Connection: keep-alive",
            "Content-Length: 375"
        ],
        "HttpOperation": "POST",
        "JsonBody": "{\n  \"Accesspolicy\": 0,\n  \"DeviceID\": [\n    6,\n    48\n  ],\n  \"DiskCachePolicy\": 1,\n  \"InitState\": 0,\n  \"Iopolicy\": 0,\n  \"LDName\": \"test2\",\n  \"NumDrives\": 2,\n  \"RaidLevel\": \"RAID1\",\n  \"Readpolicy\": 1,\n  \"Size\": 0,\n  \"SpanDepth\": 1,\n  \"SpanID\": [\n    0,\n    0\n  ],\n  \"StripeSize\": 262144,\n  \"Writepolicy\": 1\n}",
        "TargetUri": "/redfish/v1/Systems/system/Storage/Raid_0/Actions/StorageLDrive.Create"
    },
    "PercentComplete": 100,
    "StartTime": "2024-03-13T11:50:22+00:00",
    "TaskMonitor": "/redfish/v1/TaskService/Tasks/2/Monitor",
    "TaskState": "SUCCESS"
}

8) AddGlobalHotSpare
https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Raid_0/Actions/StoragePDrive.AddGlobalHotSpare
Body

{
    "PDriveId": 66
}

Response

{
    "@odata.id": "/redfish/v1/TaskService/Tasks/4",
    "@odata.type": "#Task.v1_4_3.Task",
    "Id": "4",
    "TaskState": "New"
}

https://{{BMCIP}}/redfish/v1/TaskService/Tasks/4
Response

{
    "@odata.id": "/redfish/v1/TaskService/Tasks/4",
    "@odata.type": "#Task.v1_4_3.Task",
    "EndTime": "2024-03-13T12:04:39+00:00",
    "HidePayload": false,
    "Id": "4",
    "Messages": [
        {
            "@odata.type": "#Message.v1_1_1.Message",
            "Message": "The task with Id '4' has started.",
            "MessageArgs": [
                "4"
            ],
            "MessageId": "TaskEvent.1.0.3.TaskStarted",
            "MessageSeverity": "OK",
            "Resolution": "None."
        },
        {
            "@odata.type": "#Message.v1_1_1.Message",
            "Message": "The task with Id '4' has completed.",
            "MessageArgs": [
                "4"
            ],
            "MessageId": "TaskEvent.1.0.3.TaskCompletedOK",
            "MessageSeverity": "OK",
            "Resolution": "None."
        }
    ],
    "Name": "Task 4",
    "Payload": {
        "HttpHeaders": [
            "User-Agent: PostmanRuntime/7.37.0",
            "Accept: */*",
            "Host: 172.31.96.135",
            "Accept-Encoding: gzip, deflate, br",
            "Connection: keep-alive",
            "Content-Length: 24"
        ],
        "HttpOperation": "POST",
        "JsonBody": "{\n  \"PDriveId\": 66\n}",
        "TargetUri": "/redfish/v1/Systems/system/Storage/Raid_0/Actions/StoragePDrive.AddGlobalHotSpare"
    },
    "PercentComplete": 100,
    "StartTime": "2024-03-13T12:04:38+00:00",
    "TaskMonitor": "/redfish/v1/TaskService/Tasks/4/Monitor",
    "TaskState": "SUCCESS"
}

Before

After Giving Command

9) DeleteGlobalHotSpare
https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Raid_0/Actions/StoragePDrive.DeleteGlobalHotSpare

{
    "PDriveId": 66
}

Reponse is success

10) PrepareRemovalAction
https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Raid_0/Actions/StoragePDrive.PrepareRemovalAction

{
    "PDriveId": 66
}

Response Success Case

Before

After Running Command

11) UndoPrepareRemovalAction
https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Raid_0/Actions/StoragePDrive.UndoPrepareRemovalAction

Body
{
    "PDriveId": 66
}

Response Success

12) CopybackConfigurationAction
https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Raid_0/Actions/StorageDrive.CopybackConfigurationAction
Body

{
    "EnableCopyBack": true,
    "EnableHDDCopyBack": false,
    "EnableSSDCopyBack": false
}

Response success

13) StartCopybackAction
https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Raid_0/Actions/StorageDrive.StartCopybackAction
Body

{
    "SourcePDriveId": 6,
    "DestinationPDriveId": 66
}

Reponse Success

14) StopCopybackAction
https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Raid_0/Actions/StorageDrive.StopCopybackAction

Body
{
    "PDriveId": 66
}

Response sucsess

14)StartLocatePhysicalDriveAction
https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Raid_0/Actions/StoragePDrive.StartLocatePhysicalDriveAction
Body

{
    "PDriveId": 48,
    "Time" : 0
}

Response Success

15) StopLocatePhysicalDriveAction
https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Raid_0/Actions/StoragePDrive.StopLocatePhysicalDriveAction
body

{
    "PDriveId": 48
}

Success Case

16) StartLocateLogicalDriveAction
https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Raid_0/Actions/StorageLDrive.StartLocateLogicalDriveAction
Body

{
    "LDriveId": 239,
    "Time" : 0
}

Response success

17) StopLocateLogicalDriveAction
https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Raid_0/Actions/StorageLDrive.StopLocateLogicalDriveAction
Body

{
    "LDriveId": 239
}

Response Success :

17)SetControllerPersonalityAction
https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Raid_0/Actions/StorageDrive.SetControllerPersonalityAction
body

{
    "Personality": "Raid"
}

Failure case

18) SetPhysicalDriveStateAction
https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Raid_0/Actions/StoragePDrive.SetPhysicalDriveStateAction
Body
{
"PDriveId": 66,
"State" : "UnconfiguredGood"
}
Response Success case

19)SetControllerPropertiesAction
https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Raid_0/Actions/StorageDrive.SetControllerPropertiesAction
Body

{
    "RebuildRate": 2,
    "PatrolReadRate": 1,
    "BGIRate": 4,
    "ConsistencyCheckRate": 5,
    "ReconstructionRate": 3,
    "EnableJBODMode": false,
    "EnableSSDPatrolread": true
}

Response success case:

20)SetLogicalDrivePropertiesAction
https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Raid_0/Actions/StorageLDrive.SetLogicalDrivePropertiesAction
Body

{
    "LDriveId": 341,
    "DriveName": "Renamed",
    "DiskCachePolicy": 1,
    "ReadPolicy": 1,
    "WritePolicy": 1,
    "IOPolicy": 0,
    "AccessPolicy": 0,
    "EnableBGI": 0
}

Response Sucsess case

-------------------------------------------------------------------------------------------------
----------
MSCC RAID|
----------
-------------------------------------------------------------------------

Signed-off-by: Pranoy Goru <gorumanip@ami.com>
---
 redfish-core/include/redfish.hpp          |   32 +
 redfish-core/include/utils/collection.hpp |    2 +-
 redfish-core/lib/raid.hpp                 |    5 +
 redfish-core/lib/storage_mscc.hpp         |  973 +++++++++-
 redfish-core/lib/storage_raid.hpp         | 2125 +++++++++++++++++----
 5 files changed, 2725 insertions(+), 412 deletions(-)

diff --git a/redfish-core/include/redfish.hpp b/redfish-core/include/redfish.hpp
index d9a897b8..ade2bad3 100644
--- a/redfish-core/include/redfish.hpp
+++ b/redfish-core/include/redfish.hpp
@@ -62,6 +62,7 @@
 #include "sensors.hpp"
 #include "service_root.hpp"
 #include "storage.hpp"
+#include "storage_mscc.hpp"
 #include "storage_raid.hpp"
 #include "systems.hpp"
 #include "task.hpp"
@@ -149,13 +150,44 @@ class RedfishService
         requestRoutesNvmeControllersInstance(app);
         requestRoutesNvmePorts(app);
         requestRoutesNvmePortsInstance(app);
+
         requestRoutesRaidLogical(app);
         requestRoutesRaidLogicalDrive(app);
         requestRoutesPhysicalDrive(app);
         requestRoutesCreateLogicalDriveAction(app);
         requestRoutesDeleteLogicalDriveAction(app);
+        requestRoutesAddHotSparePhysicalDriveAction(app);
+        requestRoutesDeleteHotSparePhysicalDriveAction(app);
+        requestRoutesPreparePhysicalDriveForRemovalAction(app);
+        requestRoutesUndoPreparePhysicalDriveForRemovalAction(app);
+        requestRoutesSetCopybackConfigurationAction(app);
+        requestRoutesStartCopybackAction(app);
+        requestRoutesStopCopybackAction(app);
+        requestRoutesStartLocatePhysicalDriveAction(app);
+        requestRoutesStopLocatePhysicalDriveAction(app);
+        requestRoutesStartLocateLogicalDriveAction(app);
+        requestRoutesStopLocateLogicalDriveAction(app);
+        requestRoutesSetPhysicalDriveStateAction(app);
+        requestRoutesSetControllerPersonalityAction(app);
+        requestRoutesSetLogicalDrivePropertiesAction(app);
+        requestRoutesSetControllerPropertiesAction(app);
+
         requestRoutesMSCCCreateLogicalDriveAction(app);
         requestRoutesMSCCDeleteLogicalDriveAction(app);
+        requestRoutesMSCCCreateLogicalDriveOnArrayDriveAction(app);
+        requestRoutesMSCCCreateLuCacheDriveAction(app);
+        requestRoutesMSCCDeleteArrayDriveAction(app);
+        requestRoutesMSCCSetControllerPropertiesAction(app);
+        requestRoutesMSCCAddPhysicalDriveToArrayDriveAction(app);
+        requestRoutesMSCCRemovePhysicalDriveFromArrayDriveAction(app);
+        requestRoutesMSCCAddSpareDriveToArrayDriveAction(app);
+        requestRoutesMSCCRemoveSpareDriveFromArrayDriveAction(app);
+        requestRoutesMSCCStartLocatePhysicalDriveAction(app);
+        requestRoutesMSCCStartLocateArrayDriveAction(app);
+        requestRoutesMSCCStartLocateLogicalDriveAction(app);
+        requestRoutesMSCCStopLocatePhysicalDriveAction(app);
+        requestRoutesMSCCStopLocateArrayDriveAction(app);
+        requestRoutesMSCCStopLocateLogicalDriveAction(app);
 
         requestRoutesCable(app);
         requestRoutesCableCollection(app);
diff --git a/redfish-core/include/utils/collection.hpp b/redfish-core/include/utils/collection.hpp
index 38b9c64e..85442216 100644
--- a/redfish-core/include/utils/collection.hpp
+++ b/redfish-core/include/utils/collection.hpp
@@ -6,7 +6,7 @@
 #include "http/utility.hpp"
 #include "human_sort.hpp"
 #include "raid.hpp"
-#include "storage_mscc.hpp"
+// #include "storage_mscc.hpp"
 #include "storage_nvme.hpp"
 
 #include <boost/url/url.hpp>
diff --git a/redfish-core/lib/raid.hpp b/redfish-core/lib/raid.hpp
index bb1bbfe8..d3aa1b3e 100644
--- a/redfish-core/lib/raid.hpp
+++ b/redfish-core/lib/raid.hpp
@@ -8,6 +8,8 @@
 #include <app.hpp>
 #include <registries/privilege_registry.hpp>
 
+#include <unordered_set>
+
 namespace redfish
 {
 
@@ -34,4 +36,7 @@ void getHBADevices(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
 void getStorageInstance(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
                         const std::string& name);
 
+void getMSCCDevices(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
+                    nlohmann::json& count,
+                    nlohmann::json& storageControllerArray);
 } // namespace redfish
diff --git a/redfish-core/lib/storage_mscc.hpp b/redfish-core/lib/storage_mscc.hpp
index 071f5c3d..7696acab 100644
--- a/redfish-core/lib/storage_mscc.hpp
+++ b/redfish-core/lib/storage_mscc.hpp
@@ -15,12 +15,20 @@
 */
 #include "raid.hpp"
 
+#include <task.hpp>
+
 namespace redfish
 {
 
-inline void getMSCCDevices(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
-                           nlohmann::json& count,
-                           nlohmann::json& storageControllerArray)
+uint64_t createVAr = 0, deleteVAr = 0, createVarArr = 0, createLuVar = 0,
+         deleteArrayVar = 0, setCtProVar = 0, addPdToArrDriveVar = 0,
+         rmPdFromArrDriveVar = 0, addSdToArrDriveVar = 0,
+         rmSdFromArrDriveVar = 0, startLPdVar = 0, startLADVar = 0,
+         startLLdVar = 0, stopLPdVar = 0, stopLADVar = 0, stopLLdVar = 0;
+
+void getMSCCDevices(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
+                    nlohmann::json& count,
+                    nlohmann::json& storageControllerArray)
 {
     crow::connections::systemBus->async_method_call(
         [asyncResp, &count,
@@ -84,10 +92,146 @@ inline void
     }
 }
 
+void clearVariable(const std::string& propertyName)
+{
+    if (propertyName == "create")
+    {
+        createVAr = 0;
+    }
+    if (propertyName == "delete")
+    {
+        deleteVAr = 0;
+    }
+    if (propertyName == "createArr")
+    {
+        createVarArr = 0;
+    }
+    if (propertyName == "createLu")
+    {
+        createLuVar = 0;
+    }
+    if (propertyName == "deleteArray")
+    {
+        deleteArrayVar = 0;
+    }
+    if (propertyName == "setCtPro")
+    {
+        setCtProVar = 0;
+    }
+    if (propertyName == "addPdToArrDrive")
+    {
+        addPdToArrDriveVar = 0;
+    }
+    if (propertyName == "rmPdFromArrDrive")
+    {
+        rmPdFromArrDriveVar = 0;
+    }
+    if (propertyName == "addSdToArrDrive")
+    {
+        addSdToArrDriveVar = 0;
+    }
+    if (propertyName == "rmSdFromArrDrive")
+    {
+        rmSdFromArrDriveVar = 0;
+    }
+    if (propertyName == "startLPd")
+    {
+        startLPdVar = 0;
+    }
+    if (propertyName == "startLAD")
+    {
+        startLADVar = 0;
+    }
+    if (propertyName == "startLLd")
+    {
+        startLLdVar = 0;
+    }
+    if (propertyName == "stopLPd")
+    {
+        stopLPdVar = 0;
+    }
+    if (propertyName == "stopLAD")
+    {
+        stopLADVar = 0;
+    }
+    if (propertyName == "stopLLd")
+    {
+        stopLLdVar = 0;
+    }
+}
+
+void raidStatusTask(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                    task::Payload&& payload, const std::string& propertyName,
+                    const std::string& ldPath)
+{
+    std::shared_ptr<task::TaskData> task = task::TaskData::createTask(
+        [propertyName](const boost::system::error_code eC,
+                       sdbusplus::message_t& msg,
+                       const std::shared_ptr<task::TaskData>& taskData) {
+        if (eC)
+        {
+            taskData->messages.emplace_back(messages::internalError());
+            taskData->state = "Cancelled";
+            return task::completed;
+        }
+
+        std::uint64_t messageId;
+        std::string errorCode;
+        std::string whatEC;
+
+        std::unordered_set<uint64_t> values_to_check = {
+            createVAr,           deleteVAr,           createVarArr,
+            createLuVar,         deleteArrayVar,      setCtProVar,
+            addPdToArrDriveVar,  rmPdFromArrDriveVar, addSdToArrDriveVar,
+            rmSdFromArrDriveVar, startLPdVar,         startLADVar,
+            startLLdVar,         stopLPdVar,          stopLADVar,
+            stopLLdVar};
+
+        std::string index = std::to_string(taskData->index);
+        msg.read(messageId, errorCode, whatEC);
+
+        if (values_to_check.find(messageId) != values_to_check.end())
+        {
+            std::size_t lastPos = errorCode.rfind('.');
+            std::string ec = errorCode.substr(lastPos + 1);
+
+            if (ec == "Success")
+            {
+                BMCWEB_LOG_DEBUG("Command SUCCESS case");
+                taskData->state = "SUCCESS";
+                taskData->messages.emplace_back(
+                    messages::taskCompletedOK(index));
+                taskData->percentComplete = 100;
+                clearVariable(propertyName);
+                return task::completed;
+            }
+            if ((ec == "Timeout") || (ec == "InternalFailure") ||
+                (ec == "InvalidArgument") || (ec == "NotAllowed") ||
+                (ec == "Unavailable") || (ec == "UnsupportedRequest") ||
+                (ec == "DeviceOrResourceBusy"))
+            {
+                BMCWEB_LOG_DEBUG("Error case: ", ec);
+                taskData->state = ec;
+                taskData->messages.emplace_back(messages::taskAborted(index));
+                taskData->percentComplete = 100;
+                clearVariable(propertyName);
+                return task::completed;
+            }
+        }
+        return !task::completed;
+    },
+        "type='signal',interface='com.ami.storage.mscc.ctrl.Configuration',"
+        "member='MethodCompletedSignal',path='" +
+            ldPath + "'");
+    task->startTimer(std::chrono::minutes(2));
+    task->populateResp(asyncResp->res);
+    task->payload.emplace(std::move(payload));
+}
+
 inline void requestRoutesMSCCCreateLogicalDriveAction(App& app)
 {
     BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/"
-                      "<str>/Actions/StorageMSCCLDrive.Create")
+                      "<str>/Actions/StorageMSCCLDrive.CreateLogicalDrive")
         .privileges(redfish::privileges::postChassis)
         .methods(boost::beast::http::verb::post)(
             [](const crow::Request& req,
@@ -95,18 +239,17 @@ inline void requestRoutesMSCCCreateLogicalDriveAction(App& app)
                const std::string& id) {
         std::string ldName;
         std::string raidLevel;
-        std::uint16_t arrayNumber;
-        std::vector<uint16_t> pdList;
-        std::uint64_t stripSize;
         std::uint64_t size;
-        std::uint8_t parityGroupCount;
+        std::uint64_t stripSize;
         std::string accelerator;
+        std::uint8_t parityGroupCount;
+        std::vector<uint16_t> pdList;
 
-        if (!json_util::readJsonAction(
-                req, asyncResp->res, "LDName", ldName, "RaidLevel", raidLevel,
-                "Accelerator", accelerator, "StripSize", stripSize, "Size",
-                size, "ParityGroupCount", parityGroupCount, "PdList", pdList,
-                "ArrayNumber", arrayNumber))
+        if (!json_util::readJsonAction(req, asyncResp->res, "LDName", ldName,
+                                       "RaidLevel", raidLevel, "Size", size,
+                                       "StripSize", stripSize, "Accelerator",
+                                       accelerator, "ParityGroupCount",
+                                       parityGroupCount, "PdList", pdList))
         {
             BMCWEB_LOG_DEBUG("Paramaters are not provided");
             return;
@@ -114,28 +257,40 @@ inline void requestRoutesMSCCCreateLogicalDriveAction(App& app)
 
         const std::string& ldPath = "/com/ami/storage/mscc/ctrl/" +
                                     id.substr((id.find("_")) + 1);
-
-        crow::connections::systemBus->async_method_call(
-            [asyncResp](const boost::system::error_code& ec,
-                        sdbusplus::message_t& m) {
-            if (ec)
-            {
-                errorMessageHandler(m.get_error(), asyncResp);
-                return;
-            }
-            messages::success(asyncResp->res);
-        },
-            "com.ami.storage", ldPath,
-            "com.ami.storage.mscc.ctrl.Configuration", "CreateLogicalDrive",
-            ldName, raidLevel, arrayNumber, pdList, stripSize, size,
-            parityGroupCount, accelerator);
+        if (createVAr == 0)
+        {
+            task::Payload payload(req);
+            raidStatusTask(asyncResp, std::move(payload), "create", ldPath);
+            crow::connections::systemBus->async_method_call(
+                [asyncResp](const boost::system::error_code& ec, uint64_t val) {
+                if (ec)
+                {
+                    BMCWEB_LOG_ERROR(
+                        "Bad Invalid Arguments D-Bus request error:  ", ec);
+                    messages::internalError(asyncResp->res);
+                    return;
+                }
+                createVAr = val;
+            },
+                "com.ami.storage", ldPath,
+                "com.ami.storage.mscc.ctrl.Configuration", "CreateLogicalDrive",
+                ldName, raidLevel, size, stripSize, accelerator,
+                parityGroupCount, pdList);
+        }
+        else
+        {
+            messages::actionNotSupported(
+                asyncResp->res,
+                "StorageMSCCLDrive.Create already running or busy");
+            return;
+        }
     });
 }
 
 inline void requestRoutesMSCCDeleteLogicalDriveAction(App& app)
 {
     BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/"
-                      "<str>/Actions/StorageMSCCLDrive.Delete")
+                      "<str>/Actions/StorageMSCCLDrive.DeleteLogicalDrive")
         .privileges(redfish::privileges::postChassis)
         .methods(boost::beast::http::verb::post)(
             [](const crow::Request& req,
@@ -150,19 +305,753 @@ inline void requestRoutesMSCCDeleteLogicalDriveAction(App& app)
         }
         const std::string& ldPath = "/com/ami/storage/mscc/ctrl/" +
                                     id.substr((id.find("_")) + 1);
-        crow::connections::systemBus->async_method_call(
-            [asyncResp](const boost::system::error_code& ec,
-                        sdbusplus::message_t& m) {
-            if (ec)
-            {
-                errorMessageHandler(m.get_error(), asyncResp);
-                return;
-            }
-            messages::success(asyncResp->res);
-        },
-            "com.ami.storage", ldPath,
-            "com.ami.storage.mscc.ctrl.Configuration", "DeleteLogicalDrive",
-            ldID);
+        if (deleteVAr == 0)
+        {
+            task::Payload payload(req);
+            raidStatusTask(asyncResp, std::move(payload), "delete", ldPath);
+            crow::connections::systemBus->async_method_call(
+                [asyncResp](const boost::system::error_code& ec, uint64_t val) {
+                if (ec)
+                {
+                    BMCWEB_LOG_ERROR(
+                        "Bad Invalid Arguments D-Bus request error:  ", ec);
+                    messages::internalError(asyncResp->res);
+                    return;
+                }
+                deleteVAr = val;
+            },
+                "com.ami.storage", ldPath,
+                "com.ami.storage.mscc.ctrl.Configuration", "DeleteLogicalDrive",
+                ldID);
+        }
+        else
+        {
+            messages::actionNotSupported(
+                asyncResp->res,
+                "StorageMSCCLDrive.Delete already running or busy");
+            return;
+        }
+    });
+}
+
+inline void requestRoutesMSCCCreateLogicalDriveOnArrayDriveAction(App& app)
+{
+    BMCWEB_ROUTE(
+        app, "/redfish/v1/Systems/system/Storage/"
+             "<str>/Actions/StorageMSCCLDrive.CreateLogicalDriveOnArrayDrive")
+        .privileges(redfish::privileges::postChassis)
+        .methods(boost::beast::http::verb::post)(
+            [](const crow::Request& req,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& id) {
+        std::string ldName;
+        std::string raidLevel;
+        std::uint64_t size;
+        std::uint64_t stripSize;
+        std::string accelerator;
+        std::uint8_t parityGroupCount;
+        std::uint16_t arrayDriveId;
+
+        if (!json_util::readJsonAction(
+                req, asyncResp->res, "LDName", ldName, "RaidLevel", raidLevel,
+                "Size", size, "StripSize", stripSize, "Accelerator",
+                accelerator, "ParityGroupCount", parityGroupCount,
+                "ArrayDriveId", arrayDriveId))
+        {
+            BMCWEB_LOG_DEBUG("Paramaters are not provided");
+            return;
+        }
+
+        const std::string& ldPath = "/com/ami/storage/mscc/ctrl/" +
+                                    id.substr((id.find("_")) + 1);
+        if (createVarArr == 0)
+        {
+            task::Payload payload(req);
+            raidStatusTask(asyncResp, std::move(payload), "createArr", ldPath);
+            crow::connections::systemBus->async_method_call(
+                [asyncResp](const boost::system::error_code& ec, uint64_t val) {
+                if (ec)
+                {
+                    BMCWEB_LOG_ERROR(
+                        "Bad Invalid Arguments D-Bus request error:  ", ec);
+                    messages::internalError(asyncResp->res);
+                    return;
+                }
+                createVarArr = val;
+            },
+                "com.ami.storage", ldPath,
+                "com.ami.storage.mscc.ctrl.Configuration",
+                "CreateLogicalDriveOnArrayDrive", ldName, raidLevel, size,
+                stripSize, accelerator, parityGroupCount, arrayDriveId);
+        }
+        else
+        {
+            messages::actionNotSupported(
+                asyncResp->res,
+                "StorageMSCCLDrive.CreateLogicalDriveOnArrayDrive already running or busy");
+            return;
+        }
+    });
+}
+
+inline void requestRoutesMSCCCreateLuCacheDriveAction(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/"
+                      "<str>/Actions/StorageMSCCLDrive.CreateLuCacheDrive")
+        .privileges(redfish::privileges::postChassis)
+        .methods(boost::beast::http::verb::post)(
+            [](const crow::Request& req,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& id) {
+        std::string raidLevel;
+        std::uint64_t size;
+        std::string cacheLineSize;
+        std::string writePolicy;
+        std::uint8_t parityGroupCount;
+        std::vector<uint16_t> pdList;
+        std::uint16_t ldBinding;
+
+        if (!json_util::readJsonAction(
+                req, asyncResp->res, "RaidLevel", raidLevel, "Size", size,
+                "CacheLineSize", cacheLineSize, "WritePolicy", writePolicy,
+                "ParityGroupCount", parityGroupCount, "PdList", pdList,
+                "LdBinding", ldBinding))
+        {
+            BMCWEB_LOG_DEBUG("Paramaters are not provided");
+            return;
+        }
+
+        const std::string& ldPath = "/com/ami/storage/mscc/ctrl/" +
+                                    id.substr((id.find("_")) + 1);
+        if (createLuVar == 0)
+        {
+            task::Payload payload(req);
+            raidStatusTask(asyncResp, std::move(payload), "createLu", ldPath);
+            crow::connections::systemBus->async_method_call(
+                [asyncResp](const boost::system::error_code& ec, uint64_t val) {
+                if (ec)
+                {
+                    BMCWEB_LOG_ERROR(
+                        "Bad Invalid Arguments D-Bus request error:  ", ec);
+                    messages::internalError(asyncResp->res);
+                    return;
+                }
+                createLuVar = val;
+            },
+                "com.ami.storage", ldPath,
+                "com.ami.storage.mscc.ctrl.Configuration", "CreateLuCacheDrive",
+                raidLevel, size, cacheLineSize, writePolicy, parityGroupCount,
+                pdList, ldBinding);
+        }
+        else
+        {
+            messages::actionNotSupported(
+                asyncResp->res,
+                "StorageMSCCLDrive.CreateLuCacheDrive already running or busy");
+            return;
+        }
+    });
+}
+
+inline void requestRoutesMSCCDeleteArrayDriveAction(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/"
+                      "<str>/Actions/StorageMSCCLDrive.DeleteArrayDrive")
+        .privileges(redfish::privileges::postChassis)
+        .methods(boost::beast::http::verb::post)(
+            [](const crow::Request& req,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& id) {
+        std::uint16_t arId;
+        if (!json_util::readJsonAction(req, asyncResp->res, "ArrayDriveId",
+                                       arId))
+        {
+            BMCWEB_LOG_DEBUG("Paramaters are not provided");
+            return;
+        }
+        const std::string& ldPath = "/com/ami/storage/mscc/ctrl/" +
+                                    id.substr((id.find("_")) + 1);
+        if (deleteArrayVar == 0)
+        {
+            task::Payload payload(req);
+            raidStatusTask(asyncResp, std::move(payload), "deleteArray",
+                           ldPath);
+            crow::connections::systemBus->async_method_call(
+                [asyncResp](const boost::system::error_code& ec, uint64_t val) {
+                if (ec)
+                {
+                    BMCWEB_LOG_ERROR(
+                        "Bad Invalid Arguments D-Bus request error:  ", ec);
+                    messages::internalError(asyncResp->res);
+                    return;
+                }
+                deleteArrayVar = val;
+            },
+                "com.ami.storage", ldPath,
+                "com.ami.storage.mscc.ctrl.Configuration", "DeleteArrayDrive",
+                arId);
+        }
+        else
+        {
+            messages::actionNotSupported(
+                asyncResp->res,
+                "StorageMSCCLDrive.DeleteArrayDrive already running or busy");
+            return;
+        }
+    });
+}
+
+inline void requestRoutesMSCCSetControllerPropertiesAction(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/"
+                      "<str>/Actions/StorageMSCCLDrive.SetControllerProperties")
+        .privileges(redfish::privileges::postChassis)
+        .methods(boost::beast::http::verb::post)(
+            [](const crow::Request& req,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& id) {
+        std::string rebuildPriority;
+        std::string inconsistencyRepairPolicy;
+        std::string spareActivationMode;
+        std::uint8_t readCacheRatio;
+        if (!json_util::readJsonAction(
+                req, asyncResp->res, "RebuildPriority", rebuildPriority,
+                "InconsistencyRepairPolicy", inconsistencyRepairPolicy,
+                "SpareActivationMode", spareActivationMode, "ReadCacheRatio",
+                readCacheRatio))
+        {
+            BMCWEB_LOG_DEBUG("Paramaters are not provided");
+            return;
+        }
+        const std::string& ldPath = "/com/ami/storage/mscc/ctrl/" +
+                                    id.substr((id.find("_")) + 1);
+        if (setCtProVar == 0)
+        {
+            task::Payload payload(req);
+            raidStatusTask(asyncResp, std::move(payload), "setCtPro", ldPath);
+            crow::connections::systemBus->async_method_call(
+                [asyncResp](const boost::system::error_code& ec, uint64_t val) {
+                if (ec)
+                {
+                    BMCWEB_LOG_ERROR(
+                        "Bad Invalid Arguments D-Bus request error:  ", ec);
+                    messages::internalError(asyncResp->res);
+                    return;
+                }
+                setCtProVar = val;
+            },
+                "com.ami.storage", ldPath,
+                "com.ami.storage.mscc.ctrl.Configuration",
+                "SetControllerProperties", rebuildPriority,
+                inconsistencyRepairPolicy, spareActivationMode, readCacheRatio);
+        }
+        else
+        {
+            messages::actionNotSupported(
+                asyncResp->res,
+                "StorageMSCCLDrive.SetControllerProperties already running or busy");
+            return;
+        }
+    });
+}
+
+inline void requestRoutesMSCCAddPhysicalDriveToArrayDriveAction(App& app)
+{
+    BMCWEB_ROUTE(app,
+                 "/redfish/v1/Systems/system/Storage/"
+                 "<str>/Actions/StorageMSCCLDrive.AddPhysicalDriveToArrayDrive")
+        .privileges(redfish::privileges::postChassis)
+        .methods(boost::beast::http::verb::post)(
+            [](const crow::Request& req,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& id) {
+        std::uint16_t adId;
+        std::string expandMode;
+        std::vector<uint16_t> pdList;
+
+        if (!json_util::readJsonAction(req, asyncResp->res, "AdId", adId,
+                                       "ExpandMode", expandMode, "PdList",
+                                       pdList))
+        {
+            BMCWEB_LOG_DEBUG("Paramaters are not provided");
+            return;
+        }
+        const std::string& ldPath = "/com/ami/storage/mscc/ctrl/" +
+                                    id.substr((id.find("_")) + 1);
+        if (addPdToArrDriveVar == 0)
+        {
+            task::Payload payload(req);
+            raidStatusTask(asyncResp, std::move(payload), "addPdToArrDrive",
+                           ldPath);
+            crow::connections::systemBus->async_method_call(
+                [asyncResp](const boost::system::error_code& ec, uint64_t val) {
+                if (ec)
+                {
+                    BMCWEB_LOG_ERROR(
+                        "Bad Invalid Arguments D-Bus request error:  ", ec);
+                    messages::internalError(asyncResp->res);
+                    return;
+                }
+                addPdToArrDriveVar = val;
+            },
+                "com.ami.storage", ldPath,
+                "com.ami.storage.mscc.ctrl.Configuration",
+                "AddPhysicalDriveToArrayDrive", adId, expandMode, pdList);
+        }
+        else
+        {
+            messages::actionNotSupported(
+                asyncResp->res,
+                "StorageMSCCLDrive.AddPhysicalDriveToArrayDrive already running or busy");
+            return;
+        }
+    });
+}
+
+inline void requestRoutesMSCCRemovePhysicalDriveFromArrayDriveAction(App& app)
+{
+    BMCWEB_ROUTE(
+        app,
+        "/redfish/v1/Systems/system/Storage/"
+        "<str>/Actions/StorageMSCCLDrive.RemovePhysicalDriveFromArrayDrive")
+        .privileges(redfish::privileges::postChassis)
+        .methods(boost::beast::http::verb::post)(
+            [](const crow::Request& req,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& id) {
+        std::uint16_t adId;
+        std::string shrinkMode;
+        std::vector<uint16_t> pdList;
+
+        if (!json_util::readJsonAction(req, asyncResp->res, "AdId", adId,
+                                       "ShrinkMode", shrinkMode, "PdList",
+                                       pdList))
+        {
+            BMCWEB_LOG_DEBUG("Paramaters are not provided");
+            return;
+        }
+        const std::string& ldPath = "/com/ami/storage/mscc/ctrl/" +
+                                    id.substr((id.find("_")) + 1);
+        if (rmPdFromArrDriveVar == 0)
+        {
+            task::Payload payload(req);
+            raidStatusTask(asyncResp, std::move(payload), "rmPdFromArrDrive",
+                           ldPath);
+            crow::connections::systemBus->async_method_call(
+                [asyncResp](const boost::system::error_code& ec, uint64_t val) {
+                if (ec)
+                {
+                    BMCWEB_LOG_ERROR(
+                        "Bad Invalid Arguments D-Bus request error:  ", ec);
+                    messages::internalError(asyncResp->res);
+                    return;
+                }
+                rmPdFromArrDriveVar = val;
+            },
+                "com.ami.storage", ldPath,
+                "com.ami.storage.mscc.ctrl.Configuration",
+                "RemovePhysicalDriveFromArrayDrive", adId, shrinkMode, pdList);
+        }
+        else
+        {
+            messages::actionNotSupported(
+                asyncResp->res,
+                "StorageMSCCLDrive.RemovePhysicalDriveFromArrayDrive already running or busy");
+            return;
+        }
+    });
+}
+
+inline void requestRoutesMSCCAddSpareDriveToArrayDriveAction(App& app)
+{
+    BMCWEB_ROUTE(app,
+                 "/redfish/v1/Systems/system/Storage/"
+                 "<str>/Actions/StorageMSCCLDrive.AddSpareDriveToArrayDrive")
+        .privileges(redfish::privileges::postChassis)
+        .methods(boost::beast::http::verb::post)(
+            [](const crow::Request& req,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& id) {
+        std::uint16_t adId;
+        std::string spareType;
+        std::vector<uint16_t> pdList;
+
+        if (!json_util::readJsonAction(req, asyncResp->res, "AdId", adId,
+                                       "SpareType", spareType, "PdList",
+                                       pdList))
+        {
+            BMCWEB_LOG_DEBUG("Paramaters are not provided");
+            return;
+        }
+        const std::string& ldPath = "/com/ami/storage/mscc/ctrl/" +
+                                    id.substr((id.find("_")) + 1);
+        if (addSdToArrDriveVar == 0)
+        {
+            task::Payload payload(req);
+            raidStatusTask(asyncResp, std::move(payload), "addSdToArrDrive",
+                           ldPath);
+            crow::connections::systemBus->async_method_call(
+                [asyncResp](const boost::system::error_code& ec, uint64_t val) {
+                if (ec)
+                {
+                    BMCWEB_LOG_ERROR(
+                        "Bad Invalid Arguments D-Bus request error:  ", ec);
+                    messages::internalError(asyncResp->res);
+                    return;
+                }
+                addSdToArrDriveVar = val;
+            },
+                "com.ami.storage", ldPath,
+                "com.ami.storage.mscc.ctrl.Configuration",
+                "AddSpareDriveToArrayDrive", adId, spareType, pdList);
+        }
+        else
+        {
+            messages::actionNotSupported(
+                asyncResp->res,
+                "StorageMSCCLDrive.AddSpareDriveToArrayDrive already running or busy");
+            return;
+        }
+    });
+}
+
+inline void requestRoutesMSCCRemoveSpareDriveFromArrayDriveAction(App& app)
+{
+    BMCWEB_ROUTE(
+        app, "/redfish/v1/Systems/system/Storage/"
+             "<str>/Actions/StorageMSCCLDrive.RemoveSpareDriveFromArrayDrive")
+        .privileges(redfish::privileges::postChassis)
+        .methods(boost::beast::http::verb::post)(
+            [](const crow::Request& req,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& id) {
+        std::uint16_t adId;
+        std::vector<uint16_t> pdList;
+
+        if (!json_util::readJsonAction(req, asyncResp->res, "AdId", adId,
+                                       "PdList", pdList))
+        {
+            BMCWEB_LOG_DEBUG("Paramaters are not provided");
+            return;
+        }
+        const std::string& ldPath = "/com/ami/storage/mscc/ctrl/" +
+                                    id.substr((id.find("_")) + 1);
+        if (rmSdFromArrDriveVar == 0)
+        {
+            task::Payload payload(req);
+            raidStatusTask(asyncResp, std::move(payload), "rmSdFromArrDrive",
+                           ldPath);
+            crow::connections::systemBus->async_method_call(
+                [asyncResp](const boost::system::error_code& ec, uint64_t val) {
+                if (ec)
+                {
+                    BMCWEB_LOG_ERROR(
+                        "Bad Invalid Arguments D-Bus request error:  ", ec);
+                    messages::internalError(asyncResp->res);
+                    return;
+                }
+                rmSdFromArrDriveVar = val;
+            },
+                "com.ami.storage", ldPath,
+                "com.ami.storage.mscc.ctrl.Configuration",
+                "RemoveSpareDriveFromArrayDrive", adId, pdList);
+        }
+        else
+        {
+            messages::actionNotSupported(
+                asyncResp->res,
+                "StorageMSCCLDrive.RemoveSpareDriveFromArrayDrive already running or busy");
+            return;
+        }
+    });
+}
+
+inline void requestRoutesMSCCStartLocatePhysicalDriveAction(App& app)
+{
+    BMCWEB_ROUTE(app,
+                 "/redfish/v1/Systems/system/Storage/"
+                 "<str>/Actions/StorageMSCCLDrive.StartLocatePhysicalDrive")
+        .privileges(redfish::privileges::postChassis)
+        .methods(boost::beast::http::verb::post)(
+            [](const crow::Request& req,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& id) {
+        std::uint16_t pdId;
+        std::uint16_t seconds;
+
+        if (!json_util::readJsonAction(req, asyncResp->res, "PdId", pdId,
+                                       "Seconds", seconds))
+        {
+            BMCWEB_LOG_DEBUG("Paramaters are not provided");
+            return;
+        }
+        const std::string& ldPath = "/com/ami/storage/mscc/ctrl/" +
+                                    id.substr((id.find("_")) + 1);
+        if (startLPdVar == 0)
+        {
+            task::Payload payload(req);
+            raidStatusTask(asyncResp, std::move(payload), "startLPd", ldPath);
+            crow::connections::systemBus->async_method_call(
+                [asyncResp](const boost::system::error_code& ec, uint64_t val) {
+                if (ec)
+                {
+                    BMCWEB_LOG_ERROR(
+                        "Bad Invalid Arguments D-Bus request error:  ", ec);
+                    messages::internalError(asyncResp->res);
+                    return;
+                }
+                startLPdVar = val;
+            },
+                "com.ami.storage", ldPath,
+                "com.ami.storage.mscc.ctrl.Configuration",
+                "StartLocatePhysicalDrive", pdId, seconds);
+        }
+        else
+        {
+            messages::actionNotSupported(
+                asyncResp->res,
+                "StorageMSCCLDrive.StartLocatePhysicalDrive already running or busy");
+            return;
+        }
+    });
+}
+
+inline void requestRoutesMSCCStartLocateArrayDriveAction(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/"
+                      "<str>/Actions/StorageMSCCLDrive.StartLocateArrayDrive")
+        .privileges(redfish::privileges::postChassis)
+        .methods(boost::beast::http::verb::post)(
+            [](const crow::Request& req,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& id) {
+        std::uint16_t adId;
+        std::uint16_t seconds;
+
+        if (!json_util::readJsonAction(req, asyncResp->res, "AdId", adId,
+                                       "Seconds", seconds))
+        {
+            BMCWEB_LOG_DEBUG("Paramaters are not provided");
+            return;
+        }
+        const std::string& ldPath = "/com/ami/storage/mscc/ctrl/" +
+                                    id.substr((id.find("_")) + 1);
+        if (startLADVar == 0)
+        {
+            task::Payload payload(req);
+            raidStatusTask(asyncResp, std::move(payload), "startLAD", ldPath);
+            crow::connections::systemBus->async_method_call(
+                [asyncResp](const boost::system::error_code& ec, uint64_t val) {
+                if (ec)
+                {
+                    BMCWEB_LOG_ERROR(
+                        "Bad Invalid Arguments D-Bus request error:  ", ec);
+                    messages::internalError(asyncResp->res);
+                    return;
+                }
+                startLADVar = val;
+            },
+                "com.ami.storage", ldPath,
+                "com.ami.storage.mscc.ctrl.Configuration",
+                "StartLocateArrayDrive", adId, seconds);
+        }
+        else
+        {
+            messages::actionNotSupported(
+                asyncResp->res,
+                "StorageMSCCLDrive.StartLocateArrayDrive already running or busy");
+            return;
+        }
+    });
+}
+
+inline void requestRoutesMSCCStartLocateLogicalDriveAction(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/"
+                      "<str>/Actions/StorageMSCCLDrive.StartLocateLogicalDrive")
+        .privileges(redfish::privileges::postChassis)
+        .methods(boost::beast::http::verb::post)(
+            [](const crow::Request& req,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& id) {
+        std::uint16_t ldId;
+        std::uint16_t seconds;
+
+        if (!json_util::readJsonAction(req, asyncResp->res, "LdId", ldId,
+                                       "Seconds", seconds))
+        {
+            BMCWEB_LOG_DEBUG("Paramaters are not provided");
+            return;
+        }
+        const std::string& ldPath = "/com/ami/storage/mscc/ctrl/" +
+                                    id.substr((id.find("_")) + 1);
+        task::Payload payload(req);
+        raidStatusTask(asyncResp, std::move(payload), "startLLd", ldPath);
+        if (startLLdVar == 0)
+        {
+            crow::connections::systemBus->async_method_call(
+                [asyncResp](const boost::system::error_code& ec, uint64_t val) {
+                if (ec)
+                {
+                    BMCWEB_LOG_ERROR(
+                        "Bad Invalid Arguments D-Bus request error:  ", ec);
+                    messages::internalError(asyncResp->res);
+                    return;
+                }
+                startLLdVar = val;
+            },
+                "com.ami.storage", ldPath,
+                "com.ami.storage.mscc.ctrl.Configuration",
+                "StartLocateLogicalDrive", ldId, seconds);
+        }
+        else
+        {
+            messages::actionNotSupported(
+                asyncResp->res,
+                "StorageMSCCLDrive.StartLocateLogicalDrive already running or busy");
+            return;
+        }
+    });
+}
+
+inline void requestRoutesMSCCStopLocatePhysicalDriveAction(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/"
+                      "<str>/Actions/StorageMSCCLDrive.StopLocatePhysicalDrive")
+        .privileges(redfish::privileges::postChassis)
+        .methods(boost::beast::http::verb::post)(
+            [](const crow::Request& req,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& id) {
+        std::uint16_t pdId;
+
+        if (!json_util::readJsonAction(req, asyncResp->res, "PdId", pdId))
+        {
+            BMCWEB_LOG_DEBUG("Paramaters are not provided");
+            return;
+        }
+        const std::string& ldPath = "/com/ami/storage/mscc/ctrl/" +
+                                    id.substr((id.find("_")) + 1);
+        if (stopLPdVar == 0)
+        {
+            task::Payload payload(req);
+            raidStatusTask(asyncResp, std::move(payload), "stopLPd", ldPath);
+            crow::connections::systemBus->async_method_call(
+                [asyncResp](const boost::system::error_code& ec, uint64_t val) {
+                if (ec)
+                {
+                    BMCWEB_LOG_ERROR(
+                        "Bad Invalid Arguments D-Bus request error:  ", ec);
+                    messages::internalError(asyncResp->res);
+                    return;
+                }
+                stopLPdVar = val;
+            },
+                "com.ami.storage", ldPath,
+                "com.ami.storage.mscc.ctrl.Configuration",
+                "StopLocatePhysicalDrive", pdId);
+        }
+        else
+        {
+            messages::actionNotSupported(
+                asyncResp->res,
+                "StorageMSCCLDrive.StopLocatePhysicalDrive already running or busy");
+            return;
+        }
+    });
+}
+
+inline void requestRoutesMSCCStopLocateArrayDriveAction(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/"
+                      "<str>/Actions/StorageMSCCLDrive.StopLocateArrayDrive")
+        .privileges(redfish::privileges::postChassis)
+        .methods(boost::beast::http::verb::post)(
+            [](const crow::Request& req,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& id) {
+        std::uint16_t adId;
+
+        if (!json_util::readJsonAction(req, asyncResp->res, "AdId", adId))
+        {
+            BMCWEB_LOG_DEBUG("Paramaters are not provided");
+            return;
+        }
+        const std::string& ldPath = "/com/ami/storage/mscc/ctrl/" +
+                                    id.substr((id.find("_")) + 1);
+        if (stopLADVar == 0)
+        {
+            task::Payload payload(req);
+            raidStatusTask(asyncResp, std::move(payload), "stopLAD", ldPath);
+            crow::connections::systemBus->async_method_call(
+                [asyncResp](const boost::system::error_code& ec, uint64_t val) {
+                if (ec)
+                {
+                    BMCWEB_LOG_ERROR(
+                        "Bad Invalid Arguments D-Bus request error:  ", ec);
+                    messages::internalError(asyncResp->res);
+                    return;
+                }
+                stopLADVar = val;
+            },
+                "com.ami.storage", ldPath,
+                "com.ami.storage.mscc.ctrl.Configuration",
+                "StopLocateArrayDrive", adId);
+        }
+        else
+        {
+            messages::actionNotSupported(
+                asyncResp->res,
+                "StorageMSCCLDrive.StopLocateArrayDrive already running or busy");
+            return;
+        }
+    });
+}
+
+inline void requestRoutesMSCCStopLocateLogicalDriveAction(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/"
+                      "<str>/Actions/StorageMSCCLDrive.StopLocateLogicalDrive")
+        .privileges(redfish::privileges::postChassis)
+        .methods(boost::beast::http::verb::post)(
+            [](const crow::Request& req,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& id) {
+        std::uint16_t ldId;
+
+        if (!json_util::readJsonAction(req, asyncResp->res, "LdId", ldId))
+        {
+            BMCWEB_LOG_DEBUG("Paramaters are not provided");
+            return;
+        }
+        const std::string& ldPath = "/com/ami/storage/mscc/ctrl/" +
+                                    id.substr((id.find("_")) + 1);
+        if (stopLLdVar == 0)
+        {
+            task::Payload payload(req);
+            raidStatusTask(asyncResp, std::move(payload), "stopLLd", ldPath);
+            crow::connections::systemBus->async_method_call(
+                [asyncResp](const boost::system::error_code& ec, uint64_t val) {
+                if (ec)
+                {
+                    BMCWEB_LOG_ERROR(
+                        "Bad Invalid Arguments D-Bus request error:  ", ec);
+                    messages::internalError(asyncResp->res);
+                    return;
+                }
+                stopLLdVar = val;
+            },
+                "com.ami.storage", ldPath,
+                "com.ami.storage.mscc.ctrl.Configuration",
+                "StopLocateLogicalDrive", ldId);
+        }
+        else
+        {
+            messages::actionNotSupported(
+                asyncResp->res,
+                "StorageMSCCLDrive.StopLocateLogicalDrive already running or busy");
+            return;
+        }
     });
 }
 
diff --git a/redfish-core/lib/storage_raid.hpp b/redfish-core/lib/storage_raid.hpp
index 4449d686..59cf9038 100644
--- a/redfish-core/lib/storage_raid.hpp
+++ b/redfish-core/lib/storage_raid.hpp
@@ -20,6 +20,13 @@
 namespace redfish
 {
 
+uint64_t createVar = 0, deleteVar = 0, addHotSpareVar = 0,
+         deleteHotSpareVar = 0, prepareRemovalVar = 0,
+         undoPrepareRemovalVar = 0, setCBConfVar = 0, startCBVar = 0,
+         stopCBVar = 0, startLPDVar = 0, stopLPDVar = 0, startLLDVar = 0,
+         stopLLDVar = 0, setPDSVar = 0, personalityVar = 0, setLDproVar = 0,
+         setCTproVar = 0;
+
 void getLogicalDrives(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
                       const std::string& raidName, nlohmann::json& storageArray,
                       nlohmann::json& count, int flag,
@@ -68,6 +75,78 @@ void getLogicalDrives(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
         interfaces);
 }
 
+void cleanVar(const std::string& propertyName)
+{
+    if (propertyName == "create")
+    {
+        createVar = 0;
+    }
+    if (propertyName == "delete")
+    {
+        deleteVar = 0;
+    }
+    if (propertyName == "addHotSpare")
+    {
+        addHotSpareVar = 0;
+    }
+    if (propertyName == "deleteHotSpare")
+    {
+        deleteHotSpareVar = 0;
+    }
+    if (propertyName == "prepareRemoval")
+    {
+        prepareRemovalVar = 0;
+    }
+    if (propertyName == "undoPrepareRemoval")
+    {
+        undoPrepareRemovalVar = 0;
+    }
+    if (propertyName == "setCBConf")
+    {
+        setCBConfVar = 0;
+    }
+    if (propertyName == "startCB")
+    {
+        startCBVar = 0;
+    }
+    if (propertyName == "stopCB")
+    {
+        stopCBVar = 0;
+    }
+    if (propertyName == "startLPD")
+    {
+        startLPDVar = 0;
+    }
+    if (propertyName == "stopLPD")
+    {
+        stopLPDVar = 0;
+    }
+    if (propertyName == "startLLD")
+    {
+        startLLDVar = 0;
+    }
+    if (propertyName == "stopLLD")
+    {
+        stopLLDVar = 0;
+    }
+    if (propertyName == "setPDS")
+    {
+        setPDSVar = 0;
+    }
+    if (propertyName == "personality")
+    {
+        personalityVar = 0;
+    }
+    if (propertyName == "setLDpro")
+    {
+        setLDproVar = 0;
+    }
+    if (propertyName == "setCTpro")
+    {
+        setCTproVar = 0;
+    }
+}
+
 void raidStatusTask(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
                     task::Payload&& payload, const std::string& propertyName)
 {
@@ -82,390 +161,1449 @@ void raidStatusTask(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
             return task::completed;
         }
 
-        std::string iface;
-        dbus::utility::DBusPropertiesMap values;
+        std::uint64_t messageId;
+        std::string errorCode;
+        std::string whatEC;
+
+        std::unordered_set<uint64_t> values_to_check = {
+            createVar,         deleteVar,         addHotSpareVar,
+            deleteHotSpareVar, prepareRemovalVar, undoPrepareRemovalVar,
+            setCBConfVar,      startCBVar,        stopCBVar,
+            startLPDVar,       stopLPDVar,        startLLDVar,
+            stopLLDVar,        setPDSVar,         personalityVar,
+            setLDproVar,       setCTproVar};
 
         std::string index = std::to_string(taskData->index);
-        msg.read(iface, values);
+        msg.read(messageId, errorCode, whatEC);
 
-        if (iface == "xyz.openbmc_project.raid.Base")
+        if (values_to_check.find(messageId) != values_to_check.end())
         {
-            const uint32_t* status = nullptr;
-
-            for (const auto& property : values)
-            {
-                if (property.first == propertyName)
-                {
-                    status = std::get_if<uint32_t>(&property.second);
-                    if (status == nullptr)
-                    {
-                        taskData->messages.emplace_back(
-                            messages::internalError());
-                        return task::completed;
-                    }
-                }
-            }
-
-            if (status == nullptr)
-            {
-                return !task::completed;
-            }
+            std::size_t lastPos = errorCode.rfind('.');
+            std::string ec = errorCode.substr(lastPos + 1);
 
-            if (*status == 4294967295)
-            {
-                BMCWEB_LOG_DEBUG("COMMAND_IN_PROGRESS case");
-                taskData->state = "COMMAND_IN_PROGRESS";
-                taskData->messages.emplace_back(messages::taskStarted(index));
-                taskData->extendTimer(std::chrono::minutes(3));
-                return !task::completed;
-            }
-            if (*status == 0)
+            if (ec == "Success")
             {
                 BMCWEB_LOG_DEBUG("Command SUCCESS case");
                 taskData->state = "SUCCESS";
                 taskData->messages.emplace_back(
                     messages::taskCompletedOK(index));
                 taskData->percentComplete = 100;
+                cleanVar(propertyName);
                 return task::completed;
             }
-            if (*status == 129)
-            {
-                BMCWEB_LOG_DEBUG("RAID_DEVICE_NOT_PRESENT Failed case");
-                taskData->state = "RAID_DEVICE_NOT_PRESENT";
-                taskData->messages.emplace_back(messages::taskAborted(index));
-                taskData->percentComplete = 100;
-                return task::completed;
-            }
-            if (*status == 130)
-            {
-                BMCWEB_LOG_DEBUG("RAID_CTRL_ID_INVALID Failed case");
-                taskData->state = "RAID_CTRL_ID_INVALID";
-                taskData->messages.emplace_back(messages::taskAborted(index));
-                taskData->percentComplete = 100;
-                return task::completed;
-            }
-            if (*status == 131)
-            {
-                BMCWEB_LOG_DEBUG("RAID_CTRL_DEVID_INVALID Failed case");
-                taskData->state = "RAID_CTRL_DEVID_INVALID";
-                taskData->messages.emplace_back(messages::taskAborted(index));
-                taskData->percentComplete = 100;
-                return task::completed;
-            }
-            if (*status == 132)
-            {
-                BMCWEB_LOG_DEBUG("RAID_NO_VIRTUAL_DEVICE_PRESENT Failed case");
-                taskData->state = "RAID_NO_VIRTUAL_DEVICE_PRESENT";
-                taskData->messages.emplace_back(messages::taskAborted(index));
-                taskData->percentComplete = 100;
-                return task::completed;
-            }
-            if (*status == 133)
-            {
-                BMCWEB_LOG_DEBUG("RAID_OPERATION_NOT_PERMITTED case");
-                taskData->state = "RAID_OPERATION_NOT_PERMITTED";
-                taskData->messages.emplace_back(messages::taskAborted(index));
-                taskData->percentComplete = 100;
-                return task::completed;
-            }
-            if (*status == 134)
-            {
-                BMCWEB_LOG_DEBUG("RAID_UNSUPPORTED_LOGICAL_DEV Failed case");
-                taskData->state = "RAID_UNSUPPORTED_LOGICAL_DEV";
-                taskData->messages.emplace_back(messages::taskAborted(index));
-                taskData->percentComplete = 100;
-                return task::completed;
-            }
-            if (*status == 135)
-            {
-                BMCWEB_LOG_DEBUG("RAID_OPERATION_NOT_PERMITTED case");
-                taskData->state = "RAID_OPERATION_NOT_PERMITTED";
-                taskData->messages.emplace_back(messages::taskAborted(index));
-                taskData->percentComplete = 100;
-                return task::completed;
-            }
-            if (*status == 140)
-            {
-                BMCWEB_LOG_DEBUG("RAID_COMMAND_FAILED case");
-                taskData->state = "RAID_COMMAND_FAILED";
-                taskData->messages.emplace_back(messages::taskAborted(index));
-                taskData->percentComplete = 100;
-                return task::completed;
-            }
-            if (*status == 255)
+            if ((ec == "Timeout") || (ec == "InternalFailure") ||
+                (ec == "InvalidArgument") || (ec == "NotAllowed") ||
+                (ec == "Unavailable") || (ec == "UnsupportedRequest") ||
+                (ec == "DeviceOrResourceBusy"))
             {
-                BMCWEB_LOG_DEBUG("UNSPECIFIED_ERR case");
-                taskData->state = "UNSPECIFIED_ERR";
+                BMCWEB_LOG_DEBUG("Error case: ", ec);
+                taskData->state = ec;
                 taskData->messages.emplace_back(messages::taskAborted(index));
                 taskData->percentComplete = 100;
+                cleanVar(propertyName);
                 return task::completed;
             }
         }
+        return !task::completed;
+    },
+        "type='signal',interface='xyz.openbmc_project.raid.Base',"
+        "member='MethodCompletedSignal',path='/xyz/openbmc_project/Raid'");
+    task->startTimer(std::chrono::minutes(2));
+    task->populateResp(asyncResp->res);
+    task->payload.emplace(std::move(payload));
+}
+
+inline void requestRoutesDeleteLogicalDriveAction(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/"
+                      "<str>/Actions/StorageLDrive.Delete")
+        .privileges(redfish::privileges::postChassis)
+        .methods(boost::beast::http::verb::post)(
+            [](const crow::Request& req,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& name) {
+        std::size_t type = name.find("_");
+        if (type != std::string::npos)
+        {
+            const std::string& path = "/xyz/openbmc_project/" +
+                                      name.substr(0, type) + "/" +
+                                      name.substr(type + 1);
+
+            crow::connections::systemBus->async_method_call(
+                [asyncResp, req, name,
+                 type](const boost::system::error_code ec,
+                       const std::variant<uint32_t> value) {
+                if (ec)
+                {
+                    BMCWEB_LOG_DEBUG("failed to get property Value  ", ec);
+                    messages::resourceNotFound(asyncResp->res, "", "LDriveId");
+                    return;
+                }
+
+                const uint32_t* ctrlId = std::get_if<uint32_t>(&value);
+
+                std::string ldriveId;
+
+                if (!json_util::readJsonAction(req, asyncResp->res, "LDriveId",
+                                               ldriveId))
+                {
+                    BMCWEB_LOG_DEBUG("Paramaters are not provided");
+                    return;
+                }
+
+                const std::string& ldpath =
+                    "/xyz/openbmc_project/" + name.substr(0, type) + "/" +
+                    name.substr(type + 1) + "/ld/" + ldriveId;
+
+                const uint32_t val = *ctrlId;
+
+                crow::connections::systemBus->async_method_call(
+                    [asyncResp, req, val](const boost::system::error_code ec,
+                                          const std::variant<uint16_t> value) {
+                    if (ec)
+                    {
+                        BMCWEB_LOG_DEBUG("failed to get property Value  ", ec);
+                        messages::resourceNotFound(asyncResp->res, "",
+                                                   "LDriveId");
+                        return;
+                    }
+                    const uint16_t* targetId = std::get_if<uint16_t>(&value);
+
+                    if (deleteVar == 0)
+                    {
+                        task::Payload payload(req);
+                        raidStatusTask(asyncResp, std::move(payload), "delete");
+                        crow::connections::systemBus->async_method_call(
+                            [asyncResp](const boost::system::error_code ec,
+                                        uint64_t val) {
+                            if (ec)
+                            {
+                                BMCWEB_LOG_ERROR("Bad D-Bus request error: ",
+                                                 ec);
+                                messages::resourceNotFound(asyncResp->res, "",
+                                                           "LDriveId");
+                                return;
+                            }
+                            deleteVar = val;
+                        },
+                            "xyz.openbmc_project.raid.manager",
+                            "/xyz/openbmc_project/Raid",
+                            "xyz.openbmc_project.raid.Base",
+                            "DeleteLogicalDrive", val, *targetId);
+                    }
+                    else
+                    {
+                        messages::actionNotSupported(
+                            asyncResp->res,
+                            "StorageLDrive.Delete already running or busy");
+                        return;
+                    }
+                },
+                    "xyz.openbmc_project.raid.manager", ldpath,
+                    "org.freedesktop.DBus.Properties", "Get",
+                    "xyz.openbmc_project.raid.LogicalDrive", "Id");
+            },
+                "xyz.openbmc_project.raid.manager", path,
+                "org.freedesktop.DBus.Properties", "Get",
+                "xyz.openbmc_project.raid.Controller", "Id");
+        }
+        else
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+    });
+}
+
+inline void requestRoutesCreateLogicalDriveAction(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/"
+                      "<str>/Actions/StorageLDrive.Create")
+        .privileges(redfish::privileges::postChassis)
+        .methods(boost::beast::http::verb::post)(
+            [](const crow::Request& req,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& name) {
+        std::size_t type = name.find("_");
+        if (type != std::string::npos)
+        {
+            const std::string& path = "/xyz/openbmc_project/" +
+                                      name.substr(0, type) + "/" +
+                                      name.substr(type + 1);
+
+            crow::connections::systemBus->async_method_call(
+                [asyncResp, req](const boost::system::error_code ec,
+                                 const std::variant<uint32_t> value) {
+                if (ec)
+                {
+                    BMCWEB_LOG_DEBUG("Failed to get property Value  ", ec);
+                    return;
+                }
+
+                std::string ldName;
+                std::string raidLevel;
+                std::uint64_t stripeSize;
+                std::uint64_t size;
+                std::uint8_t initState;
+                std::uint8_t diskCachePolicy;
+                std::uint8_t readpolicy;
+                std::uint8_t writepolicy;
+                std::uint8_t iopolicy;
+                std::uint8_t accesspolicy;
+                std::uint8_t spanDepth;
+                std::uint8_t numDrives;
+                std::vector<uint8_t> SpanID;
+                std::vector<uint16_t> deviceID;
+
+                if (!json_util::readJsonAction(
+                        req, asyncResp->res, "LDName", ldName, "RaidLevel",
+                        raidLevel, "Size", size, "StripeSize", stripeSize,
+                        "InitState", initState, "DiskCachePolicy",
+                        diskCachePolicy, "Readpolicy", readpolicy,
+                        "Writepolicy", writepolicy, "Iopolicy", iopolicy,
+                        "Accesspolicy", accesspolicy, "SpanDepth", spanDepth,
+                        "NumDrives", numDrives, "SpanID", SpanID, "DeviceID",
+                        deviceID))
+                {
+                    BMCWEB_LOG_DEBUG("Paramaters are not provided");
+                    return;
+                }
+
+                const uint32_t* ctrlId = std::get_if<uint32_t>(&value);
+
+                if (createVar == 0)
+                {
+                    task::Payload payload(req);
+                    raidStatusTask(asyncResp, std::move(payload), "create");
+                    crow::connections::systemBus->async_method_call(
+                        [asyncResp](const boost::system::error_code ec,
+                                    uint64_t val) {
+                        if (ec)
+                        {
+                            BMCWEB_LOG_ERROR(
+                                "Bad Invalid Arguments D-Bus request error:  ",
+                                ec);
+                            messages::internalError(asyncResp->res);
+                            return;
+                        }
+                        createVar = val;
+                    },
+                        "xyz.openbmc_project.raid.manager",
+                        "/xyz/openbmc_project/Raid",
+                        "xyz.openbmc_project.raid.Base", "CreateLogicalDrive",
+                        *ctrlId, ldName, raidLevel, size, stripeSize, initState,
+                        diskCachePolicy, readpolicy, writepolicy, iopolicy,
+                        accesspolicy, spanDepth, numDrives, SpanID, deviceID);
+                }
+                else
+                {
+                    messages::actionNotSupported(
+                        asyncResp->res,
+                        "StorageLDrive.Create already running or busy");
+                    return;
+                }
+            },
+                "xyz.openbmc_project.raid.manager", path,
+                "org.freedesktop.DBus.Properties", "Get",
+                "xyz.openbmc_project.raid.Controller", "Id");
+        }
+        else
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+    });
+}
+
+inline void requestRoutesAddHotSparePhysicalDriveAction(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/"
+                      "<str>/Actions/StoragePDrive.AddGlobalHotSpare")
+        .privileges(redfish::privileges::postChassis)
+        .methods(boost::beast::http::verb::post)(
+            [](const crow::Request& req,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& name) {
+        std::size_t type = name.find("_");
+        if (type != std::string::npos)
+        {
+            const std::string& path = "/xyz/openbmc_project/" +
+                                      name.substr(0, type) + "/" +
+                                      name.substr(type + 1);
+            crow::connections::systemBus->async_method_call(
+                [asyncResp, req](const boost::system::error_code ec,
+                                 const std::variant<uint32_t> value) {
+                if (ec)
+                {
+                    BMCWEB_LOG_DEBUG("Failed to get property Value  ", ec);
+                    return;
+                }
+
+                const uint32_t* ctrlId = std::get_if<uint32_t>(&value);
+
+                std::uint16_t pDriveId;
+                if (!json_util::readJsonAction(req, asyncResp->res, "PDriveId",
+                                               pDriveId))
+                {
+                    BMCWEB_LOG_DEBUG("Paramaters are not provided");
+                    return;
+                }
+
+                if (addHotSpareVar == 0)
+                {
+                    task::Payload payload(req);
+                    raidStatusTask(asyncResp, std::move(payload),
+                                   "addHotSpare");
+                    crow::connections::systemBus->async_method_call(
+                        [asyncResp](const boost::system::error_code ec,
+                                    uint64_t val) {
+                        if (ec)
+                        {
+                            BMCWEB_LOG_ERROR(
+                                "Bad Invalid Arguments D-Bus request error:  ",
+                                ec);
+                            messages::internalError(asyncResp->res);
+                            return;
+                        }
+                        addHotSpareVar = val;
+                    },
+                        "xyz.openbmc_project.raid.manager",
+                        "/xyz/openbmc_project/Raid",
+                        "xyz.openbmc_project.raid.Base", "AddGlobalHotSpare",
+                        *ctrlId, pDriveId);
+                }
+                else
+                {
+                    messages::actionNotSupported(
+                        asyncResp->res,
+                        "StoragePDrive.AddGlobalHotSpare already running or busy");
+                    return;
+                }
+            },
+                "xyz.openbmc_project.raid.manager", path,
+                "org.freedesktop.DBus.Properties", "Get",
+                "xyz.openbmc_project.raid.Controller", "Id");
+        }
+        else
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+    });
+}
+
+inline void requestRoutesDeleteHotSparePhysicalDriveAction(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/"
+                      "<str>/Actions/StoragePDrive.DeleteGlobalHotSpare")
+        .privileges(redfish::privileges::postChassis)
+        .methods(boost::beast::http::verb::post)(
+            [](const crow::Request& req,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& name) {
+        std::size_t type = name.find("_");
+        if (type != std::string::npos)
+        {
+            const std::string& path = "/xyz/openbmc_project/" +
+                                      name.substr(0, type) + "/" +
+                                      name.substr(type + 1);
+            crow::connections::systemBus->async_method_call(
+                [asyncResp, req](const boost::system::error_code ec,
+                                 const std::variant<uint32_t> value) {
+                if (ec)
+                {
+                    BMCWEB_LOG_DEBUG("Failed to get property Value  ", ec);
+                    return;
+                }
+
+                const uint32_t* ctrlId = std::get_if<uint32_t>(&value);
+
+                std::uint16_t pDriveId;
+                if (!json_util::readJsonAction(req, asyncResp->res, "PDriveId",
+                                               pDriveId))
+                {
+                    BMCWEB_LOG_DEBUG("Paramaters are not provided");
+                    return;
+                }
+
+                if (deleteHotSpareVar == 0)
+                {
+                    task::Payload payload(req);
+                    raidStatusTask(asyncResp, std::move(payload),
+                                   "deleteHotSpare");
+                    crow::connections::systemBus->async_method_call(
+                        [asyncResp](const boost::system::error_code ec,
+                                    uint64_t val) {
+                        if (ec)
+                        {
+                            BMCWEB_LOG_ERROR(
+                                "Bad Invalid Arguments D-Bus request error:  ",
+                                ec);
+                            messages::internalError(asyncResp->res);
+                            return;
+                        }
+                        deleteHotSpareVar = val;
+                    },
+                        "xyz.openbmc_project.raid.manager",
+                        "/xyz/openbmc_project/Raid",
+                        "xyz.openbmc_project.raid.Base", "RemoveHotSpare",
+                        *ctrlId, pDriveId);
+                }
+                else
+                {
+                    messages::actionNotSupported(
+                        asyncResp->res,
+                        "StoragePDrive.GlobalHotSpare already running or busy");
+                    return;
+                }
+            },
+                "xyz.openbmc_project.raid.manager", path,
+                "org.freedesktop.DBus.Properties", "Get",
+                "xyz.openbmc_project.raid.Controller", "Id");
+        }
+        else
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+    });
+}
+
+inline void requestRoutesPreparePhysicalDriveForRemovalAction(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/"
+                      "<str>/Actions/StoragePDrive.PrepareRemovalAction")
+        .privileges(redfish::privileges::postChassis)
+        .methods(boost::beast::http::verb::post)(
+            [](const crow::Request& req,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& name) {
+        std::size_t type = name.find("_");
+        if (type != std::string::npos)
+        {
+            const std::string& path = "/xyz/openbmc_project/" +
+                                      name.substr(0, type) + "/" +
+                                      name.substr(type + 1);
+            crow::connections::systemBus->async_method_call(
+                [asyncResp, req](const boost::system::error_code ec,
+                                 const std::variant<uint32_t> value) {
+                if (ec)
+                {
+                    BMCWEB_LOG_DEBUG("Failed to get property Value  ", ec);
+                    return;
+                }
+
+                const uint32_t* ctrlId = std::get_if<uint32_t>(&value);
+
+                std::uint16_t pDriveId;
+                if (!json_util::readJsonAction(req, asyncResp->res, "PDriveId",
+                                               pDriveId))
+                {
+                    BMCWEB_LOG_DEBUG("Paramaters are not provided");
+                    return;
+                }
+
+                if (prepareRemovalVar == 0)
+                {
+                    task::Payload payload(req);
+                    raidStatusTask(asyncResp, std::move(payload),
+                                   "prepareRemoval");
+                    crow::connections::systemBus->async_method_call(
+                        [asyncResp](const boost::system::error_code ec,
+                                    uint64_t val) {
+                        if (ec)
+                        {
+                            BMCWEB_LOG_ERROR(
+                                "Bad Invalid Arguments D-Bus request error:  ",
+                                ec);
+                            messages::internalError(asyncResp->res);
+                            return;
+                        }
+                        prepareRemovalVar = val;
+                    },
+                        "xyz.openbmc_project.raid.manager",
+                        "/xyz/openbmc_project/Raid",
+                        "xyz.openbmc_project.raid.Base",
+                        "PreparePhysicalDriveForRemoval", *ctrlId, pDriveId);
+                }
+                else
+                {
+                    messages::actionNotSupported(
+                        asyncResp->res,
+                        "StoragePDrive.PrepareRemovalAction already running or busy");
+                    return;
+                }
+            },
+                "xyz.openbmc_project.raid.manager", path,
+                "org.freedesktop.DBus.Properties", "Get",
+                "xyz.openbmc_project.raid.Controller", "Id");
+        }
+        else
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+    });
+}
+
+inline void requestRoutesUndoPreparePhysicalDriveForRemovalAction(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/"
+                      "<str>/Actions/StoragePDrive.UndoPrepareRemovalAction")
+        .privileges(redfish::privileges::postChassis)
+        .methods(boost::beast::http::verb::post)(
+            [](const crow::Request& req,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& name) {
+        std::size_t type = name.find("_");
+        if (type != std::string::npos)
+        {
+            const std::string& path = "/xyz/openbmc_project/" +
+                                      name.substr(0, type) + "/" +
+                                      name.substr(type + 1);
+            crow::connections::systemBus->async_method_call(
+                [asyncResp, req](const boost::system::error_code ec,
+                                 const std::variant<uint32_t> value) {
+                if (ec)
+                {
+                    BMCWEB_LOG_DEBUG("Failed to get property Value  ", ec);
+                    return;
+                }
+
+                const uint32_t* ctrlId = std::get_if<uint32_t>(&value);
+
+                std::uint16_t pDriveId;
+                if (!json_util::readJsonAction(req, asyncResp->res, "PDriveId",
+                                               pDriveId))
+                {
+                    BMCWEB_LOG_DEBUG("Paramaters are not provided");
+                    return;
+                }
+
+                if (undoPrepareRemovalVar == 0)
+                {
+                    task::Payload payload(req);
+                    raidStatusTask(asyncResp, std::move(payload),
+                                   "undoPrepareRemoval");
+                    crow::connections::systemBus->async_method_call(
+                        [asyncResp](const boost::system::error_code ec,
+                                    uint64_t val) {
+                        if (ec)
+                        {
+                            BMCWEB_LOG_ERROR(
+                                "Bad Invalid Arguments D-Bus request error:  ",
+                                ec);
+                            messages::internalError(asyncResp->res);
+                            return;
+                        }
+                        undoPrepareRemovalVar = val;
+                    },
+                        "xyz.openbmc_project.raid.manager",
+                        "/xyz/openbmc_project/Raid",
+                        "xyz.openbmc_project.raid.Base",
+                        "UndoPreparePhysicalDriveForRemoval", *ctrlId,
+                        pDriveId);
+                }
+                else
+                {
+                    messages::actionNotSupported(
+                        asyncResp->res,
+                        "StoragePDrive.UndoPrepareRemovalAction already running or busy");
+                    return;
+                }
+            },
+                "xyz.openbmc_project.raid.manager", path,
+                "org.freedesktop.DBus.Properties", "Get",
+                "xyz.openbmc_project.raid.Controller", "Id");
+        }
+        else
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+    });
+}
+
+inline void requestRoutesSetCopybackConfigurationAction(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/"
+                      "<str>/Actions/StorageDrive.CopybackConfigurationAction")
+        .privileges(redfish::privileges::postChassis)
+        .methods(boost::beast::http::verb::post)(
+            [](const crow::Request& req,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& name) {
+        std::size_t type = name.find("_");
+        if (type != std::string::npos)
+        {
+            const std::string& path = "/xyz/openbmc_project/" +
+                                      name.substr(0, type) + "/" +
+                                      name.substr(type + 1);
+            crow::connections::systemBus->async_method_call(
+                [asyncResp, req](const boost::system::error_code ec,
+                                 const std::variant<uint32_t> value) {
+                if (ec)
+                {
+                    BMCWEB_LOG_DEBUG("Failed to get property Value  ", ec);
+                    return;
+                }
+
+                const uint32_t* ctrlId = std::get_if<uint32_t>(&value);
+
+                bool enableCopyBack;
+                bool enableHDDCopyBack;
+                bool enableSSDCopyBack;
+
+                if (!json_util::readJsonAction(
+                        req, asyncResp->res, "EnableCopyBack", enableCopyBack,
+                        "EnableHDDCopyBack", enableHDDCopyBack,
+                        "EnableSSDCopyBack", enableSSDCopyBack))
+                {
+                    BMCWEB_LOG_DEBUG("Paramaters are not provided");
+                    return;
+                }
+
+                if (setCBConfVar == 0)
+                {
+                    task::Payload payload(req);
+                    raidStatusTask(asyncResp, std::move(payload), "setCBConf");
+                    crow::connections::systemBus->async_method_call(
+                        [asyncResp](const boost::system::error_code ec,
+                                    uint64_t val) {
+                        if (ec)
+                        {
+                            BMCWEB_LOG_ERROR(
+                                "Bad Invalid Arguments D-Bus request error:  ",
+                                ec);
+                            messages::internalError(asyncResp->res);
+                            return;
+                        }
+                        setCBConfVar = val;
+                    },
+                        "xyz.openbmc_project.raid.manager",
+                        "/xyz/openbmc_project/Raid",
+                        "xyz.openbmc_project.raid.Base",
+                        "SetCopybackConfiguration", *ctrlId, enableCopyBack,
+                        enableHDDCopyBack, enableSSDCopyBack);
+                }
+                else
+                {
+                    messages::actionNotSupported(
+                        asyncResp->res,
+                        "StorageDrive.CopybackConfigurationAction already running or busy");
+                    return;
+                }
+            },
+                "xyz.openbmc_project.raid.manager", path,
+                "org.freedesktop.DBus.Properties", "Get",
+                "xyz.openbmc_project.raid.Controller", "Id");
+        }
+        else
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+    });
+}
+
+inline void requestRoutesStartCopybackAction(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/"
+                      "<str>/Actions/StorageDrive.StartCopybackAction")
+        .privileges(redfish::privileges::postChassis)
+        .methods(boost::beast::http::verb::post)(
+            [](const crow::Request& req,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& name) {
+        std::size_t type = name.find("_");
+        if (type != std::string::npos)
+        {
+            const std::string& path = "/xyz/openbmc_project/" +
+                                      name.substr(0, type) + "/" +
+                                      name.substr(type + 1);
+            crow::connections::systemBus->async_method_call(
+                [asyncResp, req](const boost::system::error_code ec,
+                                 const std::variant<uint32_t> value) {
+                if (ec)
+                {
+                    BMCWEB_LOG_DEBUG("Failed to get property Value  ", ec);
+                    return;
+                }
+
+                const uint32_t* ctrlId = std::get_if<uint32_t>(&value);
+                std::uint16_t sourcePDriveId;
+                std::uint16_t destinationPDriveId;
+
+                if (!json_util::readJsonAction(
+                        req, asyncResp->res, "SourcePDriveId", sourcePDriveId,
+                        "DestinationPDriveId", destinationPDriveId))
+                {
+                    BMCWEB_LOG_DEBUG("Paramaters are not provided");
+                    return;
+                }
+
+                if (startCBVar == 0)
+                {
+                    task::Payload payload(req);
+                    raidStatusTask(asyncResp, std::move(payload), "startCB");
+                    crow::connections::systemBus->async_method_call(
+                        [asyncResp](const boost::system::error_code ec,
+                                    uint64_t val) {
+                        if (ec)
+                        {
+                            BMCWEB_LOG_ERROR(
+                                "Bad Invalid Arguments D-Bus request error:  ",
+                                ec);
+                            messages::internalError(asyncResp->res);
+                            return;
+                        }
+                        startCBVar = val;
+                    },
+                        "xyz.openbmc_project.raid.manager",
+                        "/xyz/openbmc_project/Raid",
+                        "xyz.openbmc_project.raid.Base", "StartCopyback",
+                        *ctrlId, sourcePDriveId, destinationPDriveId);
+                }
+                else
+                {
+                    messages::actionNotSupported(
+                        asyncResp->res,
+                        "StoragePDrive.StartCopybackAction already running or busy");
+                    return;
+                }
+            },
+                "xyz.openbmc_project.raid.manager", path,
+                "org.freedesktop.DBus.Properties", "Get",
+                "xyz.openbmc_project.raid.Controller", "Id");
+        }
+        else
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+    });
+}
+
+inline void requestRoutesStopCopybackAction(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/"
+                      "<str>/Actions/StorageDrive.StopCopybackAction")
+        .privileges(redfish::privileges::postChassis)
+        .methods(boost::beast::http::verb::post)(
+            [](const crow::Request& req,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& name) {
+        std::size_t type = name.find("_");
+        if (type != std::string::npos)
+        {
+            const std::string& path = "/xyz/openbmc_project/" +
+                                      name.substr(0, type) + "/" +
+                                      name.substr(type + 1);
+            crow::connections::systemBus->async_method_call(
+                [asyncResp, req](const boost::system::error_code ec,
+                                 const std::variant<uint32_t> value) {
+                if (ec)
+                {
+                    BMCWEB_LOG_DEBUG("Failed to get property Value  ", ec);
+                    return;
+                }
+
+                const uint32_t* ctrlId = std::get_if<uint32_t>(&value);
+                std::uint16_t pDriveId;
+
+                if (!json_util::readJsonAction(req, asyncResp->res, "PDriveId",
+                                               pDriveId))
+                {
+                    BMCWEB_LOG_DEBUG("Paramaters are not provided");
+                    return;
+                }
+
+                if (stopCBVar == 0)
+                {
+                    task::Payload payload(req);
+                    raidStatusTask(asyncResp, std::move(payload), "stopCB");
+                    crow::connections::systemBus->async_method_call(
+                        [asyncResp](const boost::system::error_code ec,
+                                    uint64_t val) {
+                        if (ec)
+                        {
+                            BMCWEB_LOG_ERROR(
+                                "Bad Invalid Arguments D-Bus request error:  ",
+                                ec);
+                            messages::internalError(asyncResp->res);
+                            return;
+                        }
+                        stopCBVar = val;
+                    },
+                        "xyz.openbmc_project.raid.manager",
+                        "/xyz/openbmc_project/Raid",
+                        "xyz.openbmc_project.raid.Base", "StopCopyback",
+                        *ctrlId, pDriveId);
+                }
+                else
+                {
+                    messages::actionNotSupported(
+                        asyncResp->res,
+                        "StoragePDrive.StopCopybackAction already running or busy");
+                    return;
+                }
+            },
+                "xyz.openbmc_project.raid.manager", path,
+                "org.freedesktop.DBus.Properties", "Get",
+                "xyz.openbmc_project.raid.Controller", "Id");
+        }
+        else
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+    });
+}
+
+inline void requestRoutesStartLocatePhysicalDriveAction(App& app)
+{
+    BMCWEB_ROUTE(app,
+                 "/redfish/v1/Systems/system/Storage/"
+                 "<str>/Actions/StoragePDrive.StartLocatePhysicalDriveAction")
+        .privileges(redfish::privileges::postChassis)
+        .methods(boost::beast::http::verb::post)(
+            [](const crow::Request& req,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& name) {
+        std::size_t type = name.find("_");
+        if (type != std::string::npos)
+        {
+            const std::string& path = "/xyz/openbmc_project/" +
+                                      name.substr(0, type) + "/" +
+                                      name.substr(type + 1);
+            crow::connections::systemBus->async_method_call(
+                [asyncResp, req](const boost::system::error_code ec,
+                                 const std::variant<uint32_t> value) {
+                if (ec)
+                {
+                    BMCWEB_LOG_DEBUG("Failed to get property Value  ", ec);
+                    return;
+                }
+
+                const uint32_t* ctrlId = std::get_if<uint32_t>(&value);
+                std::uint16_t pDriveId;
+                std::uint8_t time;
+
+                if (!json_util::readJsonAction(req, asyncResp->res, "PDriveId",
+                                               pDriveId, "Time", time))
+                {
+                    BMCWEB_LOG_DEBUG("Paramaters are not provided");
+                    return;
+                }
+
+                if (startLPDVar == 0)
+                {
+                    task::Payload payload(req);
+                    raidStatusTask(asyncResp, std::move(payload), "startLPD");
+                    crow::connections::systemBus->async_method_call(
+                        [asyncResp](const boost::system::error_code ec,
+                                    uint64_t val) {
+                        if (ec)
+                        {
+                            BMCWEB_LOG_ERROR(
+                                "Bad Invalid Arguments D-Bus request error:  ",
+                                ec);
+                            messages::internalError(asyncResp->res);
+                            return;
+                        }
+                        startLPDVar = val;
+                    },
+                        "xyz.openbmc_project.raid.manager",
+                        "/xyz/openbmc_project/Raid",
+                        "xyz.openbmc_project.raid.Base",
+                        "StartLocatePhysicalDrive", *ctrlId, pDriveId, time);
+                }
+                else
+                {
+                    messages::actionNotSupported(
+                        asyncResp->res,
+                        "StoragePDrive.StartLocatePhysicalDriveAction already running or busy");
+                    return;
+                }
+            },
+                "xyz.openbmc_project.raid.manager", path,
+                "org.freedesktop.DBus.Properties", "Get",
+                "xyz.openbmc_project.raid.Controller", "Id");
+        }
+        else
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+    });
+}
+
+inline void requestRoutesStopLocatePhysicalDriveAction(App& app)
+{
+    BMCWEB_ROUTE(app,
+                 "/redfish/v1/Systems/system/Storage/"
+                 "<str>/Actions/StoragePDrive.StopLocatePhysicalDriveAction")
+        .privileges(redfish::privileges::postChassis)
+        .methods(boost::beast::http::verb::post)(
+            [](const crow::Request& req,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& name) {
+        std::size_t type = name.find("_");
+        if (type != std::string::npos)
+        {
+            const std::string& path = "/xyz/openbmc_project/" +
+                                      name.substr(0, type) + "/" +
+                                      name.substr(type + 1);
+            crow::connections::systemBus->async_method_call(
+                [asyncResp, req](const boost::system::error_code ec,
+                                 const std::variant<uint32_t> value) {
+                if (ec)
+                {
+                    BMCWEB_LOG_DEBUG("Failed to get property Value  ", ec);
+                    return;
+                }
+
+                const uint32_t* ctrlId = std::get_if<uint32_t>(&value);
+                std::uint16_t pDriveId;
+
+                if (!json_util::readJsonAction(req, asyncResp->res, "PDriveId",
+                                               pDriveId))
+                {
+                    BMCWEB_LOG_DEBUG("Paramaters are not provided");
+                    return;
+                }
+
+                if (stopLPDVar == 0)
+                {
+                    task::Payload payload(req);
+                    raidStatusTask(asyncResp, std::move(payload), "stopLPD");
+                    crow::connections::systemBus->async_method_call(
+                        [asyncResp](const boost::system::error_code ec,
+                                    uint64_t val) {
+                        if (ec)
+                        {
+                            BMCWEB_LOG_ERROR(
+                                "Bad Invalid Arguments D-Bus request error:  ",
+                                ec);
+                            messages::internalError(asyncResp->res);
+                            return;
+                        }
+                        stopLPDVar = val;
+                    },
+                        "xyz.openbmc_project.raid.manager",
+                        "/xyz/openbmc_project/Raid",
+                        "xyz.openbmc_project.raid.Base",
+                        "StopLocatePhysicalDrive", *ctrlId, pDriveId);
+                }
+                else
+                {
+                    messages::actionNotSupported(
+                        asyncResp->res,
+                        "StoragePDrive.StopLocatePhysicalDriveAction already running or busy");
+                    return;
+                }
+            },
+                "xyz.openbmc_project.raid.manager", path,
+                "org.freedesktop.DBus.Properties", "Get",
+                "xyz.openbmc_project.raid.Controller", "Id");
+        }
+        else
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+    });
+}
+
+inline void requestRoutesStartLocateLogicalDriveAction(App& app)
+{
+    BMCWEB_ROUTE(app,
+                 "/redfish/v1/Systems/system/Storage/"
+                 "<str>/Actions/StorageLDrive.StartLocateLogicalDriveAction")
+        .privileges(redfish::privileges::postChassis)
+        .methods(boost::beast::http::verb::post)(
+            [](const crow::Request& req,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& name) {
+        std::size_t type = name.find("_");
+        if (type != std::string::npos)
+        {
+            const std::string& path = "/xyz/openbmc_project/" +
+                                      name.substr(0, type) + "/" +
+                                      name.substr(type + 1);
+            crow::connections::systemBus->async_method_call(
+                [asyncResp, req](const boost::system::error_code ec,
+                                 const std::variant<uint32_t> value) {
+                if (ec)
+                {
+                    BMCWEB_LOG_DEBUG("Failed to get property Value  ", ec);
+                    return;
+                }
+
+                const uint32_t* ctrlId = std::get_if<uint32_t>(&value);
+                std::uint16_t lDriveId;
+                std::uint8_t time;
+
+                if (!json_util::readJsonAction(req, asyncResp->res, "LDriveId",
+                                               lDriveId, "Time", time))
+                {
+                    BMCWEB_LOG_DEBUG("Paramaters are not provided");
+                    return;
+                }
+
+                if (startLLDVar == 0)
+                {
+                    task::Payload payload(req);
+                    raidStatusTask(asyncResp, std::move(payload), "startLLD");
+                    crow::connections::systemBus->async_method_call(
+                        [asyncResp](const boost::system::error_code ec,
+                                    uint64_t val) {
+                        if (ec)
+                        {
+                            BMCWEB_LOG_ERROR(
+                                "Bad Invalid Arguments D-Bus request error:  ",
+                                ec);
+                            messages::internalError(asyncResp->res);
+                            return;
+                        }
+                        startLLDVar = val;
+                    },
+                        "xyz.openbmc_project.raid.manager",
+                        "/xyz/openbmc_project/Raid",
+                        "xyz.openbmc_project.raid.Base",
+                        "StartLocateLogicalDrive", *ctrlId, lDriveId, time);
+                }
+                else
+                {
+                    messages::actionNotSupported(
+                        asyncResp->res,
+                        "StorageLDrive.StartLocateLogicalDriveAction already running or busy");
+                    return;
+                }
+            },
+                "xyz.openbmc_project.raid.manager", path,
+                "org.freedesktop.DBus.Properties", "Get",
+                "xyz.openbmc_project.raid.Controller", "Id");
+        }
+        else
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+    });
+}
+
+inline void requestRoutesStopLocateLogicalDriveAction(App& app)
+{
+    BMCWEB_ROUTE(app,
+                 "/redfish/v1/Systems/system/Storage/"
+                 "<str>/Actions/StorageLDrive.StopLocateLogicalDriveAction")
+        .privileges(redfish::privileges::postChassis)
+        .methods(boost::beast::http::verb::post)(
+            [](const crow::Request& req,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& name) {
+        std::size_t type = name.find("_");
+        if (type != std::string::npos)
+        {
+            const std::string& path = "/xyz/openbmc_project/" +
+                                      name.substr(0, type) + "/" +
+                                      name.substr(type + 1);
+            crow::connections::systemBus->async_method_call(
+                [asyncResp, req](const boost::system::error_code ec,
+                                 const std::variant<uint32_t> value) {
+                if (ec)
+                {
+                    BMCWEB_LOG_DEBUG("Failed to get property Value  ", ec);
+                    return;
+                }
+
+                const uint32_t* ctrlId = std::get_if<uint32_t>(&value);
+                std::uint16_t lDriveId;
+
+                if (!json_util::readJsonAction(req, asyncResp->res, "LDriveId",
+                                               lDriveId))
+                {
+                    BMCWEB_LOG_DEBUG("Paramaters are not provided");
+                    return;
+                }
+
+                if (stopLLDVar == 0)
+                {
+                    task::Payload payload(req);
+                    raidStatusTask(asyncResp, std::move(payload), "stopLLD");
+                    crow::connections::systemBus->async_method_call(
+                        [asyncResp](const boost::system::error_code ec,
+                                    uint64_t val) {
+                        if (ec)
+                        {
+                            BMCWEB_LOG_ERROR(
+                                "Bad Invalid Arguments D-Bus request error:  ",
+                                ec);
+                            messages::internalError(asyncResp->res);
+                            return;
+                        }
+                        stopLLDVar = val;
+                    },
+                        "xyz.openbmc_project.raid.manager",
+                        "/xyz/openbmc_project/Raid",
+                        "xyz.openbmc_project.raid.Base",
+                        "StopLocateLogicalDrive", *ctrlId, lDriveId);
+                }
+                else
+                {
+                    messages::actionNotSupported(
+                        asyncResp->res,
+                        "StorageLDrive.StopLocateLogicalDriveAction already running or busy");
+                    return;
+                }
+            },
+                "xyz.openbmc_project.raid.manager", path,
+                "org.freedesktop.DBus.Properties", "Get",
+                "xyz.openbmc_project.raid.Controller", "Id");
+        }
+        else
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+    });
+}
+
+inline void requestRoutesSetPhysicalDriveStateAction(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/"
+                      "<str>/Actions/StoragePDrive.SetPhysicalDriveStateAction")
+        .privileges(redfish::privileges::postChassis)
+        .methods(boost::beast::http::verb::post)(
+            [](const crow::Request& req,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& name) {
+        std::size_t type = name.find("_");
+        if (type != std::string::npos)
+        {
+            const std::string& path = "/xyz/openbmc_project/" +
+                                      name.substr(0, type) + "/" +
+                                      name.substr(type + 1);
+            crow::connections::systemBus->async_method_call(
+                [asyncResp, req](const boost::system::error_code ec,
+                                 const std::variant<uint32_t> value) {
+                if (ec)
+                {
+                    BMCWEB_LOG_DEBUG("Failed to get property Value  ", ec);
+                    return;
+                }
+
+                const uint32_t* ctrlId = std::get_if<uint32_t>(&value);
+                std::uint16_t pDriveId;
+                std::string state;
+
+                if (!json_util::readJsonAction(req, asyncResp->res, "PDriveId",
+                                               pDriveId, "State", state))
+                {
+                    BMCWEB_LOG_DEBUG("Paramaters are not provided");
+                    return;
+                }
 
-        return !task::completed;
-    },
-        "type='signal',interface='org.freedesktop.DBus.Properties',"
-        "member='PropertiesChanged',path='/xyz/openbmc_project/Raid'");
-    task->startTimer(std::chrono::minutes(3));
-    task->populateResp(asyncResp->res);
-    task->payload.emplace(std::move(payload));
+                if (setPDSVar == 0)
+                {
+                    task::Payload payload(req);
+                    raidStatusTask(asyncResp, std::move(payload), "setPDS");
+                    crow::connections::systemBus->async_method_call(
+                        [asyncResp](const boost::system::error_code ec,
+                                    uint64_t val) {
+                        if (ec)
+                        {
+                            BMCWEB_LOG_ERROR(
+                                "Bad Invalid Arguments D-Bus request error:  ",
+                                ec);
+                            messages::internalError(asyncResp->res);
+                            return;
+                        }
+                        setPDSVar = val;
+                    },
+                        "xyz.openbmc_project.raid.manager",
+                        "/xyz/openbmc_project/Raid",
+                        "xyz.openbmc_project.raid.Base",
+                        "SetPhysicalDriveState", *ctrlId, pDriveId, state);
+                }
+                else
+                {
+                    messages::actionNotSupported(
+                        asyncResp->res,
+                        "StoragePDrive.SetPhysicalDriveStateAction already running or busy");
+                    return;
+                }
+            },
+                "xyz.openbmc_project.raid.manager", path,
+                "org.freedesktop.DBus.Properties", "Get",
+                "xyz.openbmc_project.raid.Controller", "Id");
+        }
+        else
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+    });
 }
 
-inline void requestRoutesDeleteLogicalDriveAction(App& app)
+inline void requestRoutesSetControllerPersonalityAction(App& app)
 {
-    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/"
-                      "<str>/Actions/StorageLDrive.Delete")
+    BMCWEB_ROUTE(app,
+                 "/redfish/v1/Systems/system/Storage/"
+                 "<str>/Actions/StorageDrive.SetControllerPersonalityAction")
         .privileges(redfish::privileges::postChassis)
         .methods(boost::beast::http::verb::post)(
             [](const crow::Request& req,
                const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
                const std::string& name) {
-        //            if (!redfish::utils::checkLicenseStatus(asyncResp,
-        //                                                    "StorageLDrive.Delete"))
-        //            {
-        //                return;
-        //            }
-        crow::connections::systemBus->async_method_call(
-            [asyncResp, req, name](const boost::system::error_code ec1,
-                                   const std::variant<uint32_t>& val) {
-            if (ec1)
-            {
-                BMCWEB_LOG_DEBUG("Failed to get property Value  ", ec1);
-                return;
-            }
+        std::size_t type = name.find("_");
+        if (type != std::string::npos)
+        {
+            const std::string& path = "/xyz/openbmc_project/" +
+                                      name.substr(0, type) + "/" +
+                                      name.substr(type + 1);
+            crow::connections::systemBus->async_method_call(
+                [asyncResp, req](const boost::system::error_code ec,
+                                 const std::variant<uint32_t> value) {
+                if (ec)
+                {
+                    BMCWEB_LOG_DEBUG("Failed to get property Value  ", ec);
+                    return;
+                }
 
-            const uint32_t* status = std::get_if<uint32_t>(&val);
+                const uint32_t* ctrlId = std::get_if<uint32_t>(&value);
+                std::string personality;
 
-            if (*status == 0)
-            {
-                std::size_t type = name.find("_");
-                if (type != std::string::npos)
+                if (!json_util::readJsonAction(req, asyncResp->res,
+                                               "Personality", personality))
                 {
-                    const std::string& path = "/xyz/openbmc_project/" +
-                                              name.substr(0, type) + "/" +
-                                              name.substr(type + 1);
+                    BMCWEB_LOG_DEBUG("Paramaters are not provided");
+                    return;
+                }
 
+                if (personalityVar == 0)
+                {
+                    task::Payload payload(req);
+                    raidStatusTask(asyncResp, std::move(payload),
+                                   "personality");
                     crow::connections::systemBus->async_method_call(
-                        [asyncResp, req, name,
-                         type](const boost::system::error_code ec,
-                               const std::variant<uint32_t> value) {
+                        [asyncResp](const boost::system::error_code ec,
+                                    uint64_t val) {
                         if (ec)
                         {
-                            BMCWEB_LOG_DEBUG("failed to get property Value  ",
-                                             ec);
-                            messages::resourceNotFound(asyncResp->res, "",
-                                                       "LDriveId");
+                            BMCWEB_LOG_ERROR(
+                                "Bad Invalid Arguments D-Bus request error:  ",
+                                ec);
+                            messages::internalError(asyncResp->res);
                             return;
                         }
+                        personalityVar = val;
+                    },
+                        "xyz.openbmc_project.raid.manager",
+                        "/xyz/openbmc_project/Raid",
+                        "xyz.openbmc_project.raid.Base",
+                        "SetControllerPersonality", *ctrlId, personality);
+                }
+                else
+                {
+                    messages::actionNotSupported(
+                        asyncResp->res,
+                        "StorageDrive.SetControllerPersonalityAction already running or busy");
+                    return;
+                }
+            },
+                "xyz.openbmc_project.raid.manager", path,
+                "org.freedesktop.DBus.Properties", "Get",
+                "xyz.openbmc_project.raid.Controller", "Id");
+        }
+        else
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+    });
+}
 
-                        const uint32_t* ctrlId = std::get_if<uint32_t>(&value);
+inline void requestRoutesSetLogicalDrivePropertiesAction(App& app)
+{
+    BMCWEB_ROUTE(app,
+                 "/redfish/v1/Systems/system/Storage/"
+                 "<str>/Actions/StorageLDrive.SetLogicalDrivePropertiesAction")
+        .privileges(redfish::privileges::postChassis)
+        .methods(boost::beast::http::verb::post)(
+            [](const crow::Request& req,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& name) {
+        std::size_t type = name.find("_");
+        if (type != std::string::npos)
+        {
+            const std::string& path = "/xyz/openbmc_project/" +
+                                      name.substr(0, type) + "/" +
+                                      name.substr(type + 1);
+            crow::connections::systemBus->async_method_call(
+                [asyncResp, req](const boost::system::error_code ec,
+                                 const std::variant<uint32_t> value) {
+                if (ec)
+                {
+                    BMCWEB_LOG_DEBUG("Failed to get property Value  ", ec);
+                    return;
+                }
 
-                        std::string ldriveId;
+                const uint32_t* ctrlId = std::get_if<uint32_t>(&value);
+                std::uint16_t lDriveId;
+                std::string driveName;
+                std::uint8_t diskCachePolicy;
+                std::uint8_t readPolicy;
+                std::uint8_t writePolicy;
+                std::uint8_t ioPolicy;
+                std::uint8_t accessPolicy;
+                bool enableBGI;
+
+                if (!json_util::readJsonAction(
+                        req, asyncResp->res, "LDriveId", lDriveId, "DriveName",
+                        driveName, "DiskCachePolicy", diskCachePolicy,
+                        "ReadPolicy", readPolicy, "WritePolicy", writePolicy,
+                        "IOPolicy", ioPolicy, "AccessPolicy", accessPolicy,
+                        "EnableBGI", enableBGI))
+                {
+                    BMCWEB_LOG_DEBUG("Paramaters are not provided");
+                    return;
+                }
 
-                        if (!json_util::readJsonAction(req, asyncResp->res,
-                                                       "LDriveId", ldriveId))
+                if (setLDproVar == 0)
+                {
+                    task::Payload payload(req);
+                    raidStatusTask(asyncResp, std::move(payload), "setLDpro");
+                    crow::connections::systemBus->async_method_call(
+                        [asyncResp](const boost::system::error_code ec,
+                                    uint64_t val) {
+                        if (ec)
                         {
-                            BMCWEB_LOG_DEBUG("Paramaters are not provided");
+                            BMCWEB_LOG_ERROR(
+                                "Bad Invalid Arguments D-Bus request error:  ",
+                                ec);
+                            messages::internalError(asyncResp->res);
                             return;
                         }
-
-                        const std::string& ldpath =
-                            "/xyz/openbmc_project/" + name.substr(0, type) +
-                            "/" + name.substr(type + 1) + "/ld/" + ldriveId;
-
-                        const uint32_t val = *ctrlId;
-
-                        crow::connections::systemBus->async_method_call(
-                            [asyncResp, req,
-                             val](const boost::system::error_code ec,
-                                  const std::variant<uint16_t> value) {
-                            if (ec)
-                            {
-                                BMCWEB_LOG_DEBUG(
-                                    "failed to get property Value  ", ec);
-                                messages::resourceNotFound(asyncResp->res, "",
-                                                           "LDriveId");
-                                return;
-                            }
-                            const uint16_t* targetId =
-                                std::get_if<uint16_t>(&value);
-
-                            crow::connections::systemBus->async_method_call(
-                                [asyncResp,
-                                 req](const boost::system::error_code ec) {
-                                if (ec)
-                                {
-                                    BMCWEB_LOG_ERROR(
-                                        "Bad D-Bus request error: ", ec);
-                                    messages::resourceNotFound(asyncResp->res,
-                                                               "", "LDriveId");
-                                    return;
-                                }
-                                task::Payload payload(req);
-                                raidStatusTask(asyncResp, std::move(payload),
-                                               "setRAIDDeleteLDStatus");
-                            },
-                                "xyz.openbmc_project.raid.manager",
-                                "/xyz/openbmc_project/Raid",
-                                "xyz.openbmc_project.raid.Base",
-                                "setRAIDDeleteLD", val, *targetId);
-                        },
-                            "xyz.openbmc_project.raid.manager", ldpath,
-                            "org.freedesktop.DBus.Properties", "Get",
-                            "xyz.openbmc_project.raid.LogicalDrive", "Id");
+                        setLDproVar = val;
                     },
-                        "xyz.openbmc_project.raid.manager", path,
-                        "org.freedesktop.DBus.Properties", "Get",
-                        "xyz.openbmc_project.raid.Controller", "Id");
+                        "xyz.openbmc_project.raid.manager",
+                        "/xyz/openbmc_project/Raid",
+                        "xyz.openbmc_project.raid.Base",
+                        "SetLogicalDriveProperties", *ctrlId, lDriveId,
+                        driveName, diskCachePolicy, readPolicy, writePolicy,
+                        ioPolicy, accessPolicy, enableBGI);
                 }
                 else
                 {
-                    messages::internalError(asyncResp->res);
+                    messages::actionNotSupported(
+                        asyncResp->res,
+                        "StorageLDrive.SetLogicalDrivePropertiesAction already running or busy");
                     return;
                 }
-            }
-            else
-            {
-                messages::actionNotSupported(
-                    asyncResp->res,
-                    "StorageLDrive.Delete already running and it");
-                return;
-            }
-        },
-            "xyz.openbmc_project.raid.manager", "/xyz/openbmc_project/Raid",
-            "org.freedesktop.DBus.Properties", "Get",
-            "xyz.openbmc_project.raid.Base", "configComplete");
+            },
+                "xyz.openbmc_project.raid.manager", path,
+                "org.freedesktop.DBus.Properties", "Get",
+                "xyz.openbmc_project.raid.Controller", "Id");
+        }
+        else
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
     });
 }
 
-inline void requestRoutesCreateLogicalDriveAction(App& app)
+inline void requestRoutesSetControllerPropertiesAction(App& app)
 {
-    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/"
-                      "<str>/Actions/StorageLDrive.Create")
+    BMCWEB_ROUTE(app,
+                 "/redfish/v1/Systems/system/Storage/"
+                 "<str>/Actions/StorageDrive.SetControllerPropertiesAction")
         .privileges(redfish::privileges::postChassis)
         .methods(boost::beast::http::verb::post)(
             [](const crow::Request& req,
                const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
                const std::string& name) {
-        //                if (!redfish::utils::checkLicenseStatus(asyncResp,
-        //                                                        "StorageLDrive.Create"))
-        //                {
-        //                    return;
-        //                }
+        std::size_t type = name.find("_");
+        if (type != std::string::npos)
+        {
+            const std::string& path = "/xyz/openbmc_project/" +
+                                      name.substr(0, type) + "/" +
+                                      name.substr(type + 1);
+            crow::connections::systemBus->async_method_call(
+                [asyncResp, req](const boost::system::error_code ec,
+                                 const std::variant<uint32_t> value) {
+                if (ec)
+                {
+                    BMCWEB_LOG_DEBUG("Failed to get property Value  ", ec);
+                    return;
+                }
 
-        crow::connections::systemBus->async_method_call(
-            [asyncResp, req, name](const boost::system::error_code ec1,
-                                   const std::variant<uint32_t>& val) {
-            if (ec1)
-            {
-                BMCWEB_LOG_DEBUG("Failed to get property Value ", ec1);
-                return;
-            }
-            const uint32_t* status = std::get_if<uint32_t>(&val);
-            if (*status == 0)
-            {
-                std::size_t type = name.find("_");
-                if (type != std::string::npos)
+                const uint32_t* ctrlId = std::get_if<uint32_t>(&value);
+
+                std::uint8_t rebuildRate;
+                std::uint8_t patrolReadRate;
+                std::uint8_t bgiRate;
+                std::uint8_t consistencyCheckRate;
+                std::uint8_t reconstructionRate;
+                bool enableJBODMode;
+                bool enableSSDPatrolread;
+
+                if (!json_util::readJsonAction(
+                        req, asyncResp->res, "RebuildRate", rebuildRate,
+                        "PatrolReadRate", patrolReadRate, "BGIRate", bgiRate,
+                        "ConsistencyCheckRate", consistencyCheckRate,
+                        "ReconstructionRate", reconstructionRate,
+                        "EnableJBODMode", enableJBODMode, "EnableSSDPatrolread",
+                        enableSSDPatrolread))
                 {
-                    const std::string& path = "/xyz/openbmc_project/" +
-                                              name.substr(0, type) + "/" +
-                                              name.substr(type + 1);
+                    BMCWEB_LOG_DEBUG("Paramaters are not provided");
+                    return;
+                }
 
+                if (setCTproVar == 0)
+                {
+                    task::Payload payload(req);
+                    raidStatusTask(asyncResp, std::move(payload), "setCTpro");
                     crow::connections::systemBus->async_method_call(
-                        [asyncResp, req](const boost::system::error_code ec,
-                                         const std::variant<uint32_t> value) {
+                        [asyncResp](const boost::system::error_code ec,
+                                    uint64_t val) {
                         if (ec)
                         {
-                            BMCWEB_LOG_DEBUG("Failed to get property Value  ",
-                                             ec);
-                            return;
-                        }
-
-                        std::uint8_t cmdParm;
-                        std::uint8_t prl;
-                        std::uint8_t stripeSize;
-                        std::uint8_t initState;
-                        std::uint8_t diskCachePolicy;
-                        std::uint32_t sizeLow;
-                        std::uint32_t sizeHigh;
-                        std::uint8_t readpolicy;
-                        std::uint8_t writepolicy;
-                        std::uint8_t iopolicy;
-                        std::uint8_t accesspolicy;
-                        std::uint8_t spanDepth;
-                        std::uint8_t numDrives;
-                        std::uint8_t Accelerator;
-                        std::uint8_t ParityGroupCount;
-                        std::uint16_t ArrayNumber;
-                        std::vector<uint8_t> VDName;
-                        std::vector<uint8_t> SpanID;
-                        std::vector<uint16_t> deviceID;
-
-                        if (!json_util::readJsonAction(
-                                req, asyncResp->res, "CmdParm", cmdParm, "Prl",
-                                prl, "StripeSize", stripeSize, "InitState",
-                                initState, "DiskCachePolicy", diskCachePolicy,
-                                "SizeLow", sizeLow, "SizeHigh", sizeHigh,
-                                "Readpolicy", readpolicy, "Writepolicy",
-                                writepolicy, "Iopolicy", iopolicy,
-                                "Accesspolicy", accesspolicy, "SpanDepth",
-                                spanDepth, "NumDrives", numDrives,
-                                "Accelerator", Accelerator, "ParityGroupCount",
-                                ParityGroupCount, "ArrayNumber", ArrayNumber,
-                                "VDName", VDName, "SpanID", SpanID, "DeviceID",
-                                deviceID))
-                        {
-                            BMCWEB_LOG_DEBUG("Paramaters are not provided");
+                            BMCWEB_LOG_ERROR(
+                                "Bad Invalid Arguments D-Bus request error:  ",
+                                ec);
+                            messages::internalError(asyncResp->res);
                             return;
                         }
-
-                        const uint32_t* ctrlId = std::get_if<uint32_t>(&value);
-
-                        crow::connections::systemBus->async_method_call(
-                            [asyncResp,
-                             req](const boost::system::error_code ec) {
-                            if (ec)
-                            {
-                                BMCWEB_LOG_ERROR(
-                                    "Bad Invalid Arguments D-Bus request error:  ",
-                                    ec);
-                                messages::internalError(asyncResp->res);
-                                return;
-                            }
-                            task::Payload payload(req);
-                            raidStatusTask(asyncResp, std::move(payload),
-                                           "manageRAIDConfigStatus");
-                        },
-                            "xyz.openbmc_project.raid.manager",
-                            "/xyz/openbmc_project/Raid",
-                            "xyz.openbmc_project.raid.Base", "manageRAIDConfig",
-                            *ctrlId, cmdParm, prl, stripeSize, initState,
-                            diskCachePolicy, sizeLow, sizeHigh, readpolicy,
-                            writepolicy, iopolicy, accesspolicy, spanDepth,
-                            numDrives, Accelerator, ParityGroupCount,
-                            ArrayNumber, VDName, SpanID, deviceID);
+                        setCTproVar = val;
                     },
-                        "xyz.openbmc_project.raid.manager", path,
-                        "org.freedesktop.DBus.Properties", "Get",
-                        "xyz.openbmc_project.raid.Controller", "Id");
+                        "xyz.openbmc_project.raid.manager",
+                        "/xyz/openbmc_project/Raid",
+                        "xyz.openbmc_project.raid.Base",
+                        "SetControllerProperties", *ctrlId, rebuildRate,
+                        patrolReadRate, bgiRate, consistencyCheckRate,
+                        reconstructionRate, enableJBODMode,
+                        enableSSDPatrolread);
                 }
                 else
                 {
-                    messages::internalError(asyncResp->res);
+                    messages::actionNotSupported(
+                        asyncResp->res,
+                        "StorageDrive.SetControllerPropertiesAction already running or busy");
                     return;
                 }
-            }
-            else
-            {
-                messages::actionNotSupported(
-                    asyncResp->res,
-                    "StorageLDrive.Create already running and it");
-                return;
-            }
-        },
-            "xyz.openbmc_project.raid.manager", "/xyz/openbmc_project/Raid",
-            "org.freedesktop.DBus.Properties", "Get",
-            "xyz.openbmc_project.raid.Base", "configComplete");
+            },
+                "xyz.openbmc_project.raid.manager", path,
+                "org.freedesktop.DBus.Properties", "Get",
+                "xyz.openbmc_project.raid.Controller", "Id");
+        }
+        else
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
     });
 }
 
@@ -615,12 +1753,6 @@ inline void requestRoutesRaidLogicalDrive(App& app)
             [](const crow::Request&,
                const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
                const std::string& name, const std::string& drive) {
-        //            if (!redfish::utils::checkLicenseStatus(asyncResp,
-        //                                                    "Raid_" +
-        //                                                    raidName))
-        //            {
-        //                return;
-        //            }
         asyncResp->res.jsonValue["@odata.type"] = "#Volume.v1_6_2.Volume";
         asyncResp->res.jsonValue["@odata.id"] =
             "/redfish/v1/Systems/system/Storage/" + name + "/Volumes/" + drive;
@@ -666,7 +1798,8 @@ inline void requestRoutesRaidLogicalDrive(App& app)
                     const std::vector<std::pair<
                         std::string,
                         std::variant<std::string, uint64_t, uint32_t, uint16_t,
-                                     std::vector<uint16_t>>>>& propertiesList) {
+                                     bool, std::vector<uint16_t>>>>&
+                        propertiesList) {
                 if (ec2)
                 {
                     return;
@@ -674,7 +1807,7 @@ inline void requestRoutesRaidLogicalDrive(App& app)
                 for (const std::pair<
                          std::string,
                          std::variant<std::string, uint64_t, uint32_t, uint16_t,
-                                      std::vector<uint16_t>>>& property :
+                                      bool, std::vector<uint16_t>>>& property :
                      propertiesList)
                 {
                     const std::string& propertyName = property.first;
@@ -710,8 +1843,7 @@ inline void requestRoutesRaidLogicalDrive(App& app)
                             }
                             else if (propertyName == "RaidLevel")
                             {
-                                asyncResp->res.jsonValue["RAIDType"] =
-                                    value->substr(value->find_last_of(".") + 1);
+                                asyncResp->res.jsonValue["RAIDType"] = *value;
                             }
                             else if (propertyName == "Health")
                             {
@@ -770,6 +1902,16 @@ inline void requestRoutesRaidLogicalDrive(App& app)
                                                     ["LDeviceId"] = *value;
                         }
                     }
+                    if ((propertyName == "EnableBgi"))
+                    {
+                        const bool* value = std::get_if<bool>(&property.second);
+
+                        if (value != nullptr)
+                        {
+                            asyncResp->res.jsonValue["Oem"]["OpenBmc"]
+                                                    [propertyName] = *value;
+                        }
+                    }
                 }
             },
                 service, ldPath, "org.freedesktop.DBus.Properties", "GetAll",
@@ -885,14 +2027,111 @@ void getStorageInstance(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
                 {"@odata.id",
                  "/redfish/v1/Systems/system/Storage/" + name + "/Volumes"}};
             asyncResp->res.jsonValue["Actions"]["Oem"]
-                                    ["#StorageCollection.CreateDrive"] = {
-                {"target", "/redfish/v1/Systems/system/Storage/" + name +
-                               "/Actions/StorageMSCCLDrive.Create"}};
+                                    ["#StorageCollection.CreateLogicalDrive"] =
+                {{"target",
+                  "/redfish/v1/Systems/system/Storage/" + name +
+                      "/Actions/StorageMSCCLDrive.CreateLogicalDrive"}};
 
             asyncResp->res.jsonValue["Actions"]["Oem"]
-                                    ["#StorageCollection.DeleteDrive"] = {
+                                    ["#StorageCollection.DeleteLogicalDrive"] =
+                {{"target",
+                  "/redfish/v1/Systems/system/Storage/" + name +
+                      "/Actions/StorageMSCCLDrive.DeleteLogicalDrive"}};
+
+            asyncResp->res.jsonValue
+                ["Actions"]["Oem"]
+                ["#StorageCollection.CreateLogicalDriveOnArrayDrive"] = {
+                {"target",
+                 "/redfish/v1/Systems/system/Storage/" + name +
+                     "/Actions/StorageMSCCLDrive.CreateLogicalDriveOnArrayDrive"}};
+
+            asyncResp->res.jsonValue["Actions"]["Oem"]
+                                    ["#StorageCollection.CreateLuCacheDrive"] =
+                {{"target",
+                  "/redfish/v1/Systems/system/Storage/" + name +
+                      "/Actions/StorageMSCCLDrive.CreateLuCacheDrive"}};
+
+            asyncResp->res.jsonValue["Actions"]["Oem"]
+                                    ["#StorageCollection.DeleteArrayDrive"] = {
                 {"target", "/redfish/v1/Systems/system/Storage/" + name +
-                               "/Actions/StorageMSCCLDrive.Delete"}};
+                               "/Actions/StorageMSCCLDrive.DeleteArrayDrive"}};
+
+            asyncResp->res
+                .jsonValue["Actions"]["Oem"]
+                          ["#StorageCollection.SetControllerProperties"] = {
+                {"target",
+                 "/redfish/v1/Systems/system/Storage/" + name +
+                     "/Actions/StorageMSCCLDrive.SetControllerProperties"}};
+
+            asyncResp->res.jsonValue
+                ["Actions"]["Oem"]
+                ["#StorageCollection.AddPhysicalDriveToArrayDrive"] = {
+                {"target",
+                 "/redfish/v1/Systems/system/Storage/" + name +
+                     "/Actions/StorageMSCCLDrive.AddPhysicalDriveToArrayDrive"}};
+
+            asyncResp->res.jsonValue
+                ["Actions"]["Oem"]
+                ["#StorageCollection.RemovePhysicalDriveFromArrayDrive"] = {
+                {"target",
+                 "/redfish/v1/Systems/system/Storage/" + name +
+                     "/Actions/StorageMSCCLDrive.RemovePhysicalDriveFromArrayDrive"}};
+
+            asyncResp->res
+                .jsonValue["Actions"]["Oem"]
+                          ["#StorageCollection.AddSpareDriveToArrayDrive"] = {
+                {"target",
+                 "/redfish/v1/Systems/system/Storage/" + name +
+                     "/Actions/StorageMSCCLDrive.AddSpareDriveToArrayDrive"}};
+
+            asyncResp->res.jsonValue
+                ["Actions"]["Oem"]
+                ["#StorageCollection.RemoveSpareDriveFromArrayDrive"] = {
+                {"target",
+                 "/redfish/v1/Systems/system/Storage/" + name +
+                     "/Actions/StorageMSCCLDrive.RemoveSpareDriveFromArrayDrive"}};
+
+            asyncResp->res
+                .jsonValue["Actions"]["Oem"]
+                          ["#StorageCollection.StartLocatePhysicalDrive"] = {
+                {"target",
+                 "/redfish/v1/Systems/system/Storage/" + name +
+                     "/Actions/StorageMSCCLDrive.StartLocatePhysicalDrive"}};
+
+            asyncResp->res
+                .jsonValue["Actions"]["Oem"]
+                          ["#StorageCollection.StartLocateArrayDrive"] = {
+                {"target",
+                 "/redfish/v1/Systems/system/Storage/" + name +
+                     "/Actions/StorageMSCCLDrive.StartLocateArrayDrive"}};
+
+            asyncResp->res
+                .jsonValue["Actions"]["Oem"]
+                          ["#StorageCollection.StartLocateLogicalDrive"] = {
+                {"target",
+                 "/redfish/v1/Systems/system/Storage/" + name +
+                     "/Actions/StorageMSCCLDrive.StartLocateLogicalDrive"}};
+
+            asyncResp->res
+                .jsonValue["Actions"]["Oem"]
+                          ["#StorageCollection.StopLocatePhysicalDrive"] = {
+                {"target",
+                 "/redfish/v1/Systems/system/Storage/" + name +
+                     "/Actions/StorageMSCCLDrive.StopLocatePhysicalDrive"}};
+
+            asyncResp->res
+                .jsonValue["Actions"]["Oem"]
+                          ["#StorageCollection.StopLocateArrayDrive"] = {
+                {"target",
+                 "/redfish/v1/Systems/system/Storage/" + name +
+                     "/Actions/StorageMSCCLDrive.StopLocateArrayDrive"}};
+
+            asyncResp->res
+                .jsonValue["Actions"]["Oem"]
+                          ["#StorageCollection.StopLocateLogicalDrive"] = {
+                {"target",
+                 "/redfish/v1/Systems/system/Storage/" + name +
+                     "/Actions/StorageMSCCLDrive.StopLocateLogicalDrive"}};
         }
         else
         {
@@ -914,6 +2153,103 @@ void getStorageInstance(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
                                     ["#StorageCollection.DeleteDrive"] = {
                 {"target", "/redfish/v1/Systems/system/Storage/" + name +
                                "/Actions/StorageLDrive.Delete"}};
+
+            asyncResp->res.jsonValue["Actions"]["Oem"]
+                                    ["#StorageCollection.AddGlobalHotSpare"] = {
+                {"target", "/redfish/v1/Systems/system/Storage/" + name +
+                               "/Actions/StoragePDrive.AddGlobalHotSpare"}};
+
+            asyncResp->res
+                .jsonValue["Actions"]["Oem"]
+                          ["#StorageCollection.DeleteGlobalHotSpare"] = {
+                {"target", "/redfish/v1/Systems/system/Storage/" + name +
+                               "/Actions/StoragePDrive.DeleteGlobalHotSpare"}};
+
+            asyncResp->res
+                .jsonValue["Actions"]["Oem"]
+                          ["#StorageCollection.PrepareRemovalAction"] = {
+                {"target", "/redfish/v1/Systems/system/Storage/" + name +
+                               "/Actions/StoragePDrive.PrepareRemovalAction"}};
+
+            asyncResp->res
+                .jsonValue["Actions"]["Oem"]
+                          ["#StorageCollection.UndoPrepareRemovalAction"] = {
+                {"target",
+                 "/redfish/v1/Systems/system/Storage/" + name +
+                     "/Actions/StoragePDrive.UndoPrepareRemovalAction"}};
+
+            asyncResp->res
+                .jsonValue["Actions"]["Oem"]
+                          ["#StorageCollection.CopybackConfigurationAction"] = {
+                {"target",
+                 "/redfish/v1/Systems/system/Storage/" + name +
+                     "/Actions/StorageDrive.CopybackConfigurationAction"}};
+
+            asyncResp->res.jsonValue["Actions"]["Oem"]
+                                    ["#StorageCollection.StartCopybackAction"] =
+                {{"target", "/redfish/v1/Systems/system/Storage/" + name +
+                                "/Actions/StorageDrive.StartCopybackAction"}};
+
+            asyncResp->res.jsonValue["Actions"]["Oem"]
+                                    ["#StorageCollection.StopCopybackAction"] =
+                {{"target", "/redfish/v1/Systems/system/Storage/" + name +
+                                "/Actions/StorageDrive.StopCopybackAction"}};
+
+            asyncResp->res.jsonValue
+                ["Actions"]["Oem"]
+                ["#StorageCollection.StartLocatePhysicalDriveAction"] = {
+                {"target",
+                 "/redfish/v1/Systems/system/Storage/" + name +
+                     "/Actions/StoragePDrive.StartLocatePhysicalDriveAction"}};
+
+            asyncResp->res
+                .jsonValue["Actions"]["Oem"]
+                          ["#StorageCollection.StopLocatePhysicalDriveAction"] =
+                {{"target",
+                  "/redfish/v1/Systems/system/Storage/" + name +
+                      "/Actions/StoragePDrive.StopLocatePhysicalDriveAction"}};
+
+            asyncResp->res
+                .jsonValue["Actions"]["Oem"]
+                          ["#StorageCollection.StartLocateLogicalDriveAction"] =
+                {{"target",
+                  "/redfish/v1/Systems/system/Storage/" + name +
+                      "/Actions/StorageLDrive.StartLocateLogicalDriveAction"}};
+
+            asyncResp->res
+                .jsonValue["Actions"]["Oem"]
+                          ["#StorageCollection.StopLocateLogicalDriveAction"] =
+                {{"target",
+                  "/redfish/v1/Systems/system/Storage/" + name +
+                      "/Actions/StorageLDrive.StopLocateLogicalDriveAction"}};
+
+            asyncResp->res
+                .jsonValue["Actions"]["Oem"]
+                          ["#StorageCollection.SetPhysicalDriveStateAction"] = {
+                {"target",
+                 "/redfish/v1/Systems/system/Storage/" + name +
+                     "/Actions/StoragePDrive.SetPhysicalDriveStateAction"}};
+
+            asyncResp->res.jsonValue
+                ["Actions"]["Oem"]
+                ["#StorageCollection.SetControllerPersonalityAction"] = {
+                {"target",
+                 "/redfish/v1/Systems/system/Storage/" + name +
+                     "/Actions/StorageDrive.SetControllerPersonalityAction"}};
+
+            asyncResp->res.jsonValue
+                ["Actions"]["Oem"]
+                ["#StorageCollection.SetLogicalDrivePropertiesAction"] = {
+                {"target",
+                 "/redfish/v1/Systems/system/Storage/" + name +
+                     "/Actions/StorageLDrive.SetLogicalDrivePropertiesAction"}};
+
+            asyncResp->res
+                .jsonValue["Actions"]["Oem"]
+                          ["#StorageCollection.SetControllerPropertiesAction"] =
+                {{"target",
+                  "/redfish/v1/Systems/system/Storage/" + name +
+                      "/Actions/StorageDrive.SetControllerPropertiesAction"}};
         }
 
         nlohmann::json& storageControllerArray =
@@ -927,46 +2263,14 @@ void getStorageInstance(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
                           (interfaces));
         asyncResp->res.jsonValue["Oem"]["OpenBmc"]["@odata.type"] =
             "#OemStorage.v1_0_0.OemStorage";
-        if ((name.substr(0, type) == "Raid"))
-        {
-            crow::connections::systemBus->async_method_call(
-                [asyncResp](
-                    const boost::system::error_code ec2,
-                    const std::vector<
-                        std::pair<std::string, std::variant<bool, uint32_t>>>&
-                        propertiesList) {
-                if (ec2)
-                {
-                    return;
-                }
-                for (const std::pair<std::string, std::variant<bool, uint32_t>>&
-                         property : propertiesList)
-                {
-                    const std::string& propertyName = property.first;
-                    if ((propertyName == "manageRAIDConfigStatus") ||
-                        (propertyName == "setRAIDDeleteLDStatus") ||
-                        (propertyName == "configComplete"))
-                    {
-                        const uint32_t* value =
-                            std::get_if<uint32_t>(&property.second);
-                        if (value != nullptr)
-                        {
-                            asyncResp->res.jsonValue["Oem"]["OpenBmc"]
-                                                    [propertyName] = *value;
-                        }
-                    }
-                }
-            },
-                "xyz.openbmc_project.raid.manager", "/xyz/openbmc_project/Raid",
-                "org.freedesktop.DBus.Properties", "GetAll",
-                "xyz.openbmc_project.raid.Base");
-        }
+
         crow::connections::systemBus->async_method_call(
             [asyncResp, name, type](
                 const boost::system::error_code ec2,
                 const std::vector<std::pair<
                     std::string,
-                    std::variant<bool, std::string, uint32_t, uint16_t,
+                    std::variant<bool, std::string, uint32_t, uint16_t, uint8_t,
+                                 std::vector<uint64_t>,
                                  std::vector<std::string>>>>& propertiesList) {
             if (ec2)
             {
@@ -975,6 +2279,12 @@ void getStorageInstance(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
                 return;
             }
 
+            nlohmann::json& ratesArray = asyncResp->res.jsonValue["Rates"];
+            ratesArray = nlohmann::json::array();
+
+            nlohmann::json& rate =
+                ratesArray.emplace_back(nlohmann::json::object());
+
             nlohmann::json& controllerArray =
                 asyncResp->res.jsonValue["StorageControllers"];
             controllerArray = nlohmann::json::array();
@@ -992,6 +2302,7 @@ void getStorageInstance(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
             for (const std::pair<
                      std::string,
                      std::variant<bool, std::string, uint32_t, uint16_t,
+                                  uint8_t, std::vector<uint64_t>,
                                   std::vector<std::string>>>& property :
                  propertiesList)
             {
@@ -1010,6 +2321,19 @@ void getStorageInstance(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
                     }
                 }
 
+                if ((propertyName == "CurrentPersonality") ||
+                    (propertyName == "RequestedPersonality"))
+                {
+                    const std::string* value =
+                        std::get_if<std::string>(&property.second);
+
+                    if (value != nullptr)
+                    {
+                        asyncResp->res
+                            .jsonValue["Oem"]["OpenBmc"][propertyName] = *value;
+                    }
+                }
+
                 if (propertyName == "Health")
                 {
                     const std::string* value =
@@ -1033,13 +2357,64 @@ void getStorageInstance(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
                     }
                 }
 
-                if (propertyName == "SupportedRaidLevel")
+                if ((propertyName == "SupportedRaidLevel") ||
+                    (propertyName == "SupportedPersonality"))
                 {
                     const std::vector<std::string>* value =
                         std::get_if<std::vector<std::string>>(&property.second);
                     if (value != nullptr)
                     {
-                        storageController["SupportedRAIDTypes"] = *value;
+                        if (propertyName == "SupportedRaidLevel")
+                            storageController["SupportedRAIDTypes"] = *value;
+                        if (propertyName == "SupportedPersonality")
+                            asyncResp->res.jsonValue["Oem"]["OpenBmc"]
+                                                    [propertyName] = *value;
+                    }
+                }
+
+                if ((propertyName == "SupportedStripSize"))
+                {
+                    const std::vector<uint64_t>* value =
+                        std::get_if<std::vector<uint64_t>>(&property.second);
+                    if (value != nullptr)
+                    {
+                        asyncResp->res
+                            .jsonValue["Oem"]["OpenBmc"][propertyName] = *value;
+                    }
+                }
+
+                if ((propertyName == "ConsistencyCheckRate") ||
+                    (propertyName == "ReconstructionRate") ||
+                    (propertyName == "RebuildRate") ||
+                    (propertyName == "BgiRate") ||
+                    (propertyName == "PatrolReadRate"))
+                {
+                    const std::uint8_t* value =
+                        std::get_if<std::uint8_t>(&property.second);
+                    if (value != nullptr)
+                    {
+                        if (propertyName == "ConsistencyCheckRate")
+                            rate["ConsistencyCheckRatePercent"] = *value;
+                        else if (propertyName == "ReconstructionRate")
+                            rate["TransformationRatePercent"] = *value;
+                        else if (propertyName == "RebuildRate")
+                            rate["RebuildRatePercent"] = *value;
+                        else
+                            asyncResp->res.jsonValue["Oem"]["OpenBmc"]
+                                                    [propertyName] = *value;
+                    }
+                }
+                if ((propertyName == "EnableCopyback") ||
+                    (propertyName == "EnableHddSmartCopyback") ||
+                    (propertyName == "EnableJbod") ||
+                    (propertyName == "EnableSsdPatrolRead") ||
+                    (propertyName == "EnableSsdSmartCopyback"))
+                {
+                    const bool* value = std::get_if<bool>(&property.second);
+                    if (value != nullptr)
+                    {
+                        asyncResp->res
+                            .jsonValue["Oem"]["OpenBmc"][propertyName] = *value;
                     }
                 }
             }
@@ -1172,6 +2547,17 @@ inline void requestRoutesPhysicalDrive(App& app)
                         }
                     }
 
+                    if (propertyName == "CopybackProgress")
+                    {
+                        const uint8_t* value =
+                            std::get_if<uint8_t>(&property.second);
+                        if (value != nullptr)
+                        {
+                            asyncResp->res.jsonValue["Oem"]["OpenBmc"]
+                                                    [propertyName] = *value;
+                        }
+                    }
+
                     if ((propertyName == "FailurePredicted"))
                     {
                         const uint32_t* value =
@@ -1201,7 +2587,8 @@ inline void requestRoutesPhysicalDrive(App& app)
                         (propertyName == "LinkSpeed") ||
                         (propertyName == "ProductId") ||
                         (propertyName == "Slot") ||
-                        (propertyName == "InterfaceType"))
+                        (propertyName == "InterfaceType") ||
+                        (propertyName == "State"))
                     {
                         const std::string* value =
                             std::get_if<std::string>(&property.second);
@@ -1210,6 +2597,10 @@ inline void requestRoutesPhysicalDrive(App& app)
                             if ((propertyName == "ProductId"))
                                 asyncResp->res.jsonValue["Oem"]["OpenBmc"]
                                                         [propertyName] = *value;
+                            else if ((propertyName == "State"))
+                                asyncResp->res.jsonValue["Oem"]["OpenBmc"]
+                                                        ["PDrivestate"] =
+                                    *value;
                             else if (propertyName == "LinkSpeed")
                             {
                                 std::string gbs_value;
@@ -1243,15 +2634,11 @@ inline void requestRoutesPhysicalDrive(App& app)
                         {
                             asyncResp->res.jsonValue["Status"][propertyName] =
                                 *value;
-                            asyncResp->res.jsonValue["Status"]["State"] =
-                                "Enabled";
                         }
                         else
                         {
                             asyncResp->res.jsonValue["Status"][propertyName] =
                                 *value;
-                            asyncResp->res.jsonValue["Status"]["State"] =
-                                "Disabled";
                         }
                     }
                 }
-- 
2.34.1

