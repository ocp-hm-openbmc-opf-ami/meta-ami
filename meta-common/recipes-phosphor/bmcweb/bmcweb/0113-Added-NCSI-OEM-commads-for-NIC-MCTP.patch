From 15d16eef0f32ae6faf05ea0a49487d0e7a7f09d7 Mon Sep 17 00:00:00 2001
From: gokulp <gokulp@ami.com>
Date: Mon, 25 Sep 2023 16:37:38 +0530
Subject: [PATCH 125/125] Added NCSI OEM commads for NIC-MCTP

---
 redfish-core/lib/chassis.hpp | 310 +++++++++++++++++++++++++++--------
 1 file changed, 241 insertions(+), 69 deletions(-)

diff --git a/redfish-core/lib/chassis.hpp b/redfish-core/lib/chassis.hpp
index 98295e42..d33d4522 100644
--- a/redfish-core/lib/chassis.hpp
+++ b/redfish-core/lib/chassis.hpp
@@ -1400,7 +1400,7 @@ inline void
                    const std::string& value) {
             if (error_code)
             {
-                messages::internalError(asyncResp->res);
+            //    messages::internalError(asyncResp->res);
                 return;
             }
 
@@ -1416,7 +1416,7 @@ inline void
                             subtree) {
                         if (ec)
                         {
-                            messages::internalError(asyncResp->res);
+                        //    messages::internalError(asyncResp->res);
                             return;
                         }
 
@@ -1427,45 +1427,49 @@ inline void
                                 std::string, std::vector<std::string>>>&
                                 connectionNames = object.second;
 
-                            if (connectionNames.size() != 1)
+                            const std::string& objectPath = object.first;
+                            std::size_t found = objectPath.find(netName);
+                            if (found != std::string::npos)
                             {
-                                BMCWEB_LOG_ERROR << "Connection size "
-                                                 << connectionNames.size()
-                                                 << ", greater than 1";
-                                messages::internalError(asyncResp->res);
-                                return;
-                            }
-
-                            const std::vector<std::string>& interfaces3 =
-                                connectionNames[0].second;
-                            
-                            for (auto i = interfaces3.begin();
-                                 i != interfaces3.end(); ++i)
-                            {
-                                if (*i != "xyz.openbmc_project.NicInf" &&
-                                    !boost::starts_with(*i, "org."))
+                                if (connectionNames.size() != 1)
                                 {
-                                    std::string str = *i;
-                                    std::size_t port_instance = str.rfind(".");
-                                    networkPortCollection.push_back(
-                                        {{"@odata.id",
-                                          "/redfish/v1/Chassis/" + chassisId +
-                                              "/NetworkAdapters/" + netName +
-                                              "/NetworkPorts/" +
-                                              str.substr(port_instance + 1)}});
+                                    BMCWEB_LOG_ERROR << "Connection size "
+                                                    << connectionNames.size()
+                                                    << ", greater than 1";
+                                    messages::internalError(asyncResp->res);
+                                    return;
                                 }
-                            }
 
-                            nlohmann::json& ctrlResp =
+                                const std::vector<std::string>& interfaces3 =
+                                    connectionNames[0].second;
+                                
+                                for (auto i = interfaces3.begin();
+                                    i != interfaces3.end(); ++i)
+                                {
+                                    if (*i != "xyz.openbmc_project.NicInf" && !boost::starts_with(*i, "org."))
+                                    {
+                                        std::string str = *i;
+                                        std::size_t port_instance = str.rfind(".");
+                                        networkPortCollection.push_back(
+                                            {{"@odata.id",
+                                            "/redfish/v1/Chassis/" + chassisId +
+                                                "/NetworkAdapters/" + netName +
+                                                "/NetworkPorts/" +
+                                                str.substr(port_instance + 1)}});
+                                                break;
+                                    }                              
+                                }  
+                                nlohmann::json& ctrlResp =
                                 asyncResp->res.jsonValue["Controllers"];
-                            ctrlResp.push_back({
-                                {"FirmwarePackageVersion", value},
-                                {"Links",
-                                 {{"NetworkPorts", networkPortCollection},
-                                  {"NetworkPorts@odata.count",
-                                   networkPortCollection.size()}}},
-                            });
-                        }
+                                ctrlResp.push_back({
+                                    {"FirmwarePackageVersion", value},
+                                    {"Links",
+                                    {{"NetworkPorts", networkPortCollection},
+                                    {"NetworkPorts@odata.count",
+                                    networkPortCollection.size()}}},
+                                });     
+                            }
+                        }                        
                     },
                     "xyz.openbmc_project.ObjectMapper",
                     "/xyz/openbmc_project/object_mapper",
@@ -1552,36 +1556,40 @@ inline void getNicPorts(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
             {
                 const std::vector<
                     std::pair<std::string, std::vector<std::string>>>&
-                    connectionNames = object.second;
+                    connectionNames = object.second;                
+                const std::string& objectPath = object.first;
 
-                if (connectionNames.size() != 1)
+                std::size_t found = objectPath.find(netName);
+                if (found != std::string::npos)
                 {
-                    BMCWEB_LOG_ERROR << "Connection size "
-                                     << connectionNames.size()
-                                     << ", greater than 1";
-                    messages::internalError(asyncResp->res);
-                    return;
-                }
-
-                const std::vector<std::string>& interfaces3 =
-                    connectionNames[0].second;
-                for (auto i = interfaces3.begin(); i != interfaces3.end(); ++i)
-                {
-                    if (*i != "xyz.openbmc_project.NicInf" && !boost::starts_with(*i, "org."))
+                    if (connectionNames.size() != 1)
+                    {
+                        BMCWEB_LOG_ERROR << "Connection size "
+                                        << connectionNames.size()
+                                        << ", greater than 1";
+                        messages::internalError(asyncResp->res);
+                        return;
+                    }
+                    const std::vector<std::string>& interfaces3 =
+                        connectionNames[0].second;
+                    for (auto i = interfaces3.begin(); i != interfaces3.end(); ++i)
                     {
-                        std::string str = *i;
-                        std::size_t port_instance = str.rfind(".");
-                        entriesArray.push_back(
-                            {{"@odata.id", "/redfish/v1/Chassis/" + chassisId +
-                                               "/NetworkAdapters/" + netName +
-                                               "/NetworkPorts/" +
-                                               str.substr(port_instance + 1)}});
+                        if (*i != "xyz.openbmc_project.NicInf" && !boost::starts_with(*i, "org."))
+                        {
+                            std::string str = *i;                            
+                            std::size_t port_instance = str.rfind(".");
+                            entriesArray.push_back(
+                                {{"@odata.id", "/redfish/v1/Chassis/" + chassisId +
+                                                "/NetworkAdapters/" + netName +
+                                                "/NetworkPorts/" +
+                                                str.substr(port_instance + 1)}});
+                        }
                     }
+                    if (val == 1)
+                        asyncResp->res.jsonValue["Members@odata.count"] =
+                            entriesArray.size();
+                    return;
                 }
-                if (val == 1)
-                    asyncResp->res.jsonValue["Members@odata.count"] =
-                        entriesArray.size();
-                return;
             }
         },
         "xyz.openbmc_project.ObjectMapper",
@@ -1603,7 +1611,7 @@ inline void getProperty(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
                                   const std::string& value) {
             if (error_code)
             {
-                messages::internalError(asyncResp->res);
+             //   messages::internalError(asyncResp->res);
                 return;
             }
 
@@ -1612,13 +1620,96 @@ inline void getProperty(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
                 asyncResp->res.jsonValue["Oem"]["OpenBmc"][propertyName] =
                     value;
             }
-            else if (propertyName == "MACAddress")
+            else if (propertyName == "CurrentTemperature")
+            {
+                asyncResp->res.jsonValue["Oem"]["OpenBmc"][propertyName] =
+                    value;
+            }
+            else if (propertyName == "FirmwareName")
+            {
+                asyncResp->res.jsonValue["Oem"]["OpenBmc"][propertyName] =
+                    value;
+            }
+            else if (propertyName == "FirmwareVersion")
+            {
+                asyncResp->res.jsonValue["Oem"]["OpenBmc"][propertyName] =
+                    value;
+            }
+            else if (propertyName == "MCTP_over_PCIE_EID")
+            {
+                asyncResp->res.jsonValue["Oem"]["OpenBmc"][propertyName] =
+                    value;
+            }
+            else if (propertyName == "MCTP_over_SMBUS_EID")
+            {
+                asyncResp->res.jsonValue["Oem"]["OpenBmc"][propertyName] =
+                    value;
+            }
+            else if (propertyName == "ManufacturerId")
+            {
+                asyncResp->res.jsonValue["Oem"]["OpenBmc"][propertyName] =
+                    value;
+            }
+            else if (propertyName == "NCSIVersion")
+            {
+                asyncResp->res.jsonValue["Oem"]["OpenBmc"][propertyName] =
+                    value;
+            }
+            else if (propertyName == "OEM_Mac_Address")
+            {
+                asyncResp->res.jsonValue["Oem"]["OpenBmc"][propertyName] =
+                    value;
+            }
+            else if (propertyName == "SSId")
+            {
+                asyncResp->res.jsonValue["Oem"]["OpenBmc"][propertyName] =
+                    value;
+            }
+            else if (propertyName == "SVId")
             {
-                std::vector<std::string> associateNwAddrs;
-                associateNwAddrs.push_back(value);
-                asyncResp->res.jsonValue["AssociatedNetworkAddresses"] =
-                    associateNwAddrs;
+                asyncResp->res.jsonValue["Oem"]["OpenBmc"][propertyName] =
+                    value;
             }
+            else if (propertyName == "UUID")
+            {
+                asyncResp->res.jsonValue["Oem"]["OpenBmc"][propertyName] =
+                    value;
+            }
+            else if (propertyName == "GetNCCapabilitiesAndSettings")
+            {
+                asyncResp->res.jsonValue["Oem"]["OpenBmc"][propertyName] =
+                    value;
+            }
+            else if (propertyName == "GetBootConfigProperties")
+            {
+                asyncResp->res.jsonValue["Oem"]["OpenBmc"][propertyName] =
+                    value;
+            }
+            else if (propertyName == "GetPFAssignmentProperties")
+            {
+                asyncResp->res.jsonValue["Oem"]["OpenBmc"][propertyName] =
+                    value;
+            }
+            else if (propertyName == "GetPackageStatus")
+            {
+                asyncResp->res.jsonValue["Oem"]["OpenBmc"][propertyName] =
+                    value;
+            }
+            else if (propertyName == "GetPartitionProperties")
+            {
+                asyncResp->res.jsonValue["Oem"]["OpenBmc"][propertyName] =
+                    value;
+            }
+            else if (propertyName == "GetPartitionStatisticsProperties")
+            {
+                asyncResp->res.jsonValue["Oem"]["OpenBmc"][propertyName] =
+                    value;
+            }
+            else if (propertyName == "GetPortConfigurationProperties")
+            {
+                asyncResp->res.jsonValue["Oem"]["OpenBmc"][propertyName] =
+                    value;
+            }            
             else
             {
                 asyncResp->res.jsonValue[propertyName] = value;
@@ -1841,15 +1932,96 @@ inline void requestRoutesChassisNetworkPorts(App& app)
                             "VendorId");
                 getProperty(asyncResp, netPath, mctpServiceName, mctpInfPath,
                             "DeviceId");
+                getProperty(asyncResp, netPath, mctpServiceName, mctpInfPath,
+                            "CurrentTemperature");
+                getProperty(asyncResp, netPath, mctpServiceName, mctpInfPath,
+                            "FirmwareName");
+                getProperty(asyncResp, netPath, mctpServiceName, mctpInfPath,
+                            "FirmwareVersion");
+                getProperty(asyncResp, netPath, mctpServiceName, mctpInfPath,
+                            "MCTP_over_PCIE_EID");
+                getProperty(asyncResp, netPath, mctpServiceName, mctpInfPath,
+                            "MCTP_over_SMBUS_EID");
+                getProperty(asyncResp, netPath, mctpServiceName, mctpInfPath,
+                            "ManufacturerId");
+                getProperty(asyncResp, netPath, mctpServiceName, mctpInfPath,
+                            "NCSIVersion");                            
+                getProperty(asyncResp, netPath, mctpServiceName, mctpInfPath,
+                            "OEM_Mac_Address");
+                getProperty(asyncResp, netPath, mctpServiceName, mctpInfPath,
+                            "SSId");
+                getProperty(asyncResp, netPath, mctpServiceName, mctpInfPath,
+                            "SVId");
+                getProperty(asyncResp, netPath, mctpServiceName, mctpInfPath,
+                            "UUID");  
                 getProperty(asyncResp, netPath, mctpServiceName, infPath,
-                            "MACAddress");
+                             "GetNCCapabilitiesAndSettings");
+                getProperty(asyncResp, netPath, mctpServiceName, infPath,
+                             "GetBootConfigProperties");
+                getProperty(asyncResp, netPath, mctpServiceName, infPath,
+                             "GetPFAssignmentProperties");
+                getProperty(asyncResp, netPath, mctpServiceName, infPath,
+                             "GetPackageStatus");
+                getProperty(asyncResp, netPath, mctpServiceName, infPath,
+                             "GetPartitionProperties");
+                getProperty(asyncResp, netPath, mctpServiceName, infPath,
+                             "GetPartitionStatisticsProperties");
+                getProperty(asyncResp, netPath, mctpServiceName, infPath,
+                             "GetPortConfigurationProperties");                                 
+
+                sdbusplus::asio::getProperty<uint8_t>(
+                        *crow::connections::systemBus, "xyz.openbmc_project.NICMgt", 
+                        objPath, infPath, "MACAddressCount",[asyncResp, objPath, infPath]
+                            (const boost::system::error_code& ec,
+                                        const uint8_t& macAddressCount) {
+                        if (ec)
+                        {
+                            return;
+                        }
+                        for( int i =1; i <= macAddressCount; i++)
+                        {
+                            std::string macName = "MACAddress";
+                            macName = macName + std::to_string(i);
+
+                            sdbusplus::asio::getProperty<std::string>(
+                            *crow::connections::systemBus, "xyz.openbmc_project.NICMgt", 
+                            objPath, infPath,macName,[asyncResp, macName]
+                                (const boost::system::error_code& ec,
+                                            const std::string& property) 
+                            {
+                                if (ec)
+                                {                                
+                                    return;
+                                }
+                                
+                                asyncResp->res.jsonValue["Oem"]["OpenBmc"]
+                                                        [macName] = property;
+                            });
+                        }
+                        asyncResp->res.jsonValue["Oem"]["OpenBmc"]
+                                                ["MACAddressCount"] = macAddressCount;
+                } );
+                                        
+                sdbusplus::asio::getProperty<uint32_t>(
+                        *crow::connections::systemBus, mctpServiceName, 
+                        objPath, mctpInfPath, 
+                        "ChannelCount",[asyncResp]
+                            (const boost::system::error_code& ec,
+                                        const uint32_t channelCount) {
+                        if (ec)
+                        {
+                            return;
+                        }                                            
+                        asyncResp->res.jsonValue["Oem"]["OpenBmc"]
+                                                ["ChannelCount"] = channelCount;
+             } );
 
                 crow::connections::systemBus->async_method_call(
                     [asyncResp](const boost::system::error_code error_code,
                                 const PropertiesType& dbus_data) {
                         if (error_code)
                         {
-                            messages::internalError(asyncResp->res);
+                          //  messages::internalError(asyncResp->res);
                             return;
                         }
                         for (const auto& property : dbus_data)
-- 
2.34.1

