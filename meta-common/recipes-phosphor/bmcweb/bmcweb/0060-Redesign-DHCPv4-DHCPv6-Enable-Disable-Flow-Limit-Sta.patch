From d8ab236964cee56e48fa59662eeabd371c6ec467 Mon Sep 17 00:00:00 2001
From: ginugeorge <ginugeorge@ami.com>
Date: Tue, 17 Oct 2023 19:53:27 +0530
Subject: [PATCH 60/60] Redesign DHCPv4,DHCPv6 Enable/Disable Flow, Limit
 Static IPv6, Restrict IPv4 PATCH from DHCP to Static and vice versa, Pass
 address and gateway values in proper order to deleteAndCreateIPAddress method
 for both IPv4 & IPv6

---
 redfish-core/lib/ethernet.hpp | 145 +++++++++++++++++++++++++++-------
 1 file changed, 116 insertions(+), 29 deletions(-)

diff --git a/redfish-core/lib/ethernet.hpp b/redfish-core/lib/ethernet.hpp
index 70e49816..9551b19c 100644
--- a/redfish-core/lib/ethernet.hpp
+++ b/redfish-core/lib/ethernet.hpp
@@ -1157,6 +1157,44 @@ inline void handleSLAACAutoConfigPatch(
     });
 }
 
+inline void triggerDHCPDisable(
+    const std::string& ifaceId, const EthernetInterfaceData& ethData,
+    const DHCPParameters& v4dhcpParms, const DHCPParameters& v6dhcpParms,
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp, const bool flag)
+{
+    bool ipv4Active = translateDhcpEnabledToBool(ethData.dhcpEnabled, true);
+    bool ipv6Active = translateDhcpEnabledToBool(ethData.dhcpEnabled, false);
+
+    bool nextv4DHCPState{};
+    if (flag)
+    {
+        nextv4DHCPState = false;
+    }
+    else if (v4dhcpParms.dhcpv4Enabled)
+    {
+        nextv4DHCPState = *v4dhcpParms.dhcpv4Enabled;
+    }
+    else
+    {
+        nextv4DHCPState = ipv4Active;
+    }
+    bool nextv6DHCPState{};
+    if (!flag)
+    {
+        nextv6DHCPState = false;
+    }
+    else if (v6dhcpParms.dhcpv6OperatingMode)
+    {
+        nextv6DHCPState = (*v6dhcpParms.dhcpv6OperatingMode == "Enabled");
+    }
+    else
+    {
+        nextv6DHCPState = ipv6Active;
+    }
+    setDHCPEnabled(ifaceId, "DHCPEnabled", nextv4DHCPState, nextv6DHCPState,
+                   asyncResp);
+}
+
 inline void handleDHCPPatch(const std::string& ifaceId,
                             const EthernetInterfaceData& ethData,
                             const DHCPParameters& v4dhcpParms,
@@ -1285,11 +1323,12 @@ inline std::vector<IPv6AddressData>::const_iterator getNextStaticIpEntry(
     });
 }
 
-inline void
-    handleIPv4StaticPatch(const std::string& ifaceId,
-                          nlohmann::json::array_t& input,
-                          const std::vector<IPv4AddressData>& ipv4Data,
-                          const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
+inline void handleIPv4StaticPatch(
+    const std::string& ifaceId, nlohmann::json::array_t& input,
+    const std::vector<IPv4AddressData>& ipv4Data,
+    const EthernetInterfaceData& ethData, const DHCPParameters& v4dhcpParms,
+    const DHCPParameters& v6dhcpParms,
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
 {
     if (input.empty())
     {
@@ -1299,6 +1338,11 @@ inline void
     }
     else if (input.size() > 1)
     {
+        if (!v4dhcpParms.dhcpv4Enabled)
+        {
+            messages::arraySizeTooLong(asyncResp->res, "IPv4StaticAddresses",
+                                       1);
+        }
         return;
     }
 
@@ -1423,8 +1467,8 @@ inline void
             if (nicIpEntry != ipv4Data.cend())
             {
                 deleteAndCreateIPAddress(IpVersion::IpV4, ifaceId,
-                                         nicIpEntry->id, prefixLength, *gw,
-                                         *addr, asyncResp);
+                                         nicIpEntry->id, prefixLength, *addr,
+                                         *gw, asyncResp);
                 nicIpEntry = getNextStaticIpEntry(++nicIpEntry,
                                                   ipv4Data.cend());
             }
@@ -1464,6 +1508,12 @@ inline void
             entryIdx++;
         }
     }
+    if (!v4dhcpParms.dhcpv4Enabled) // Invoke triggerDHCPDisable when DHCPv4 ->
+                                    // DHCPEnabled not present
+    {
+        triggerDHCPDisable(ifaceId, ethData, v4dhcpParms, v6dhcpParms,
+                           asyncResp, true);
+    }
 }
 
 inline void handleStaticNameServersPatch(
@@ -1581,6 +1631,8 @@ inline void handleIPv6StaticDefaultGatewaysPatch(
 inline void handleIPv6StaticAddressesPatch(
     const std::string& ifaceId, const nlohmann::json::array_t& input,
     const std::vector<IPv6AddressData>& ipv6Data,
+    const EthernetInterfaceData& ethData, const DHCPParameters& v4dhcpParms,
+    const DHCPParameters& v6dhcpParms,
     const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
 {
     if (input.empty())
@@ -1589,6 +1641,15 @@ inline void handleIPv6StaticAddressesPatch(
                                          "IPv6StaticAddresses");
         return;
     }
+    else if (input.size() > 16)
+    {
+        if (!v6dhcpParms.dhcpv6OperatingMode)
+        {
+            messages::arraySizeTooLong(asyncResp->res, "IPv6StaticAddresses",
+                                       16);
+        }
+        return;
+    }
     size_t entryIdx = 1;
     std::vector<IPv6AddressData>::const_iterator nicIpEntry =
         getNextStaticIpEntry(ipv6Data.cbegin(), ipv6Data.cend());
@@ -1650,7 +1711,7 @@ inline void handleIPv6StaticAddressesPatch(
             if (nicIpEntry != ipv6Data.end())
             {
                 deleteAndCreateIPAddress(IpVersion::IpV6, ifaceId,
-                                         nicIpEntry->id, prefix, "", *addr,
+                                         nicIpEntry->id, prefix, *addr, "",
                                          asyncResp);
                 nicIpEntry = getNextStaticIpEntry(++nicIpEntry,
                                                   ipv6Data.cend());
@@ -1690,6 +1751,12 @@ inline void handleIPv6StaticAddressesPatch(
             entryIdx++;
         }
     }
+    if (!v6dhcpParms.dhcpv6OperatingMode) // Invoke triggerDHCPDisable when
+                                          // DHCPv6 -> OperatingMode not present
+    {
+        triggerDHCPDisable(ifaceId, ethData, v4dhcpParms, v6dhcpParms,
+                           asyncResp, false);
+    }
 }
 
 inline std::string extractParentInterfaceName(const std::string& ifaceId)
@@ -2222,7 +2289,7 @@ inline void requestEthernetInterfacesRoutes(App& app)
                                 nlohmann::json IPv4Static = *ipv4StaticAddresses;
                                 if(IPv4Static.size() > 1)
                                 {
-                                    messages::invalidIndex(asyncResp->res, 1);
+                                    messages::arraySizeTooLong(asyncResp->res,"IPv4StaticAddresses", 1);
                                     return;
                                 }
                             }
@@ -2233,8 +2300,36 @@ inline void requestEthernetInterfacesRoutes(App& app)
                             return;
                         }
                     }
-                }    
+                }
 
+                if(dhcpv6)
+                {
+                    if (v6dhcpParms.dhcpv6OperatingMode) // DHCPv6 -> OperatingMode is present
+                    {
+                        if ((*v6dhcpParms.dhcpv6OperatingMode == "Enabled") && ipv6StaticAddresses)
+                        {
+                            messages::propertyValueConflict(asyncResp->res, "DHCPv6.OperatingMode","IPv6StaticAddresses");
+                            return;
+                        }
+                        else if (*v6dhcpParms.dhcpv6OperatingMode == "Disabled")
+                        {
+                            if (!ipv6StaticAddresses) // and IPv6StaticAddresses attribute is not present
+                            {
+                                messages::propertyMissing(asyncResp->res, "IPv6StaticAddresses");
+                                return;
+                            }
+                            else if(ipv6StaticAddresses) // and IPv6StaticAddresses attribute is present
+                            {
+                                nlohmann::json IPv6Static = *ipv6StaticAddresses;
+                                if(IPv6Static.size() > 16)
+                                {
+                                    messages::arraySizeTooLong(asyncResp->res,"IPv6StaticAddresses", 16);
+                                    return;
+                                }
+                            }
+                        }
+                    }
+                }
 
                 handleDHCPPatch(ifaceId, ethData, v4dhcpParms, v6dhcpParms,
                                 asyncResp);
@@ -2263,23 +2358,15 @@ inline void requestEthernetInterfacesRoutes(App& app)
 
             if (ipv4StaticAddresses)
             {
-		if(!v4dhcpParms.dhcpv4Enabled)
-		{
-		   messages::propertyMissing(asyncResp->res, "DHCPv4.DHCPEnabled");
-		   return;
-		}
-		else
-		{
-		   // TODO(ed) for some reason the capture of
-		   // ipv4Addresses above is returning a const value,
-		   // not a non-const value. This doesn't really work
-		   // for us, as we need to be able to efficiently move
-		   // out the intermedia nlohmann::json objects. This
-		   // makes a copy of the structure, and operates on
-		   // that, but could be done more efficiently
-                   nlohmann::json::array_t ipv4Static = *ipv4StaticAddresses;
-                   handleIPv4StaticPatch(ifaceId, ipv4Static, ipv4Data, asyncResp);
-		}
+                // TODO(ed) for some reason the capture of
+                // ipv4Addresses above is returning a const value,
+                // not a non-const value. This doesn't really work
+                // for us, as we need to be able to efficiently move
+                // out the intermedia nlohmann::json objects. This
+                // makes a copy of the structure, and operates on
+                // that, but could be done more efficiently
+                nlohmann::json::array_t ipv4Static = *ipv4StaticAddresses;
+                handleIPv4StaticPatch(ifaceId, ipv4Static, ipv4Data, ethData, v4dhcpParms, v6dhcpParms, asyncResp);
             }
 
             if (ipv6StaticDefaultGateways)
@@ -2303,8 +2390,8 @@ inline void requestEthernetInterfacesRoutes(App& app)
 
             if (ipv6StaticAddresses)
             {
-                handleIPv6StaticAddressesPatch(ifaceId, *ipv6StaticAddresses,
-                                               ipv6Data, asyncResp);
+                handleIPv6StaticAddressesPatch(ifaceId, *ipv6StaticAddresses, ipv6Data, ethData, v4dhcpParms, v6dhcpParms,
+                                               asyncResp);
             }
 
             if (interfaceEnabled)
-- 
2.39.2

