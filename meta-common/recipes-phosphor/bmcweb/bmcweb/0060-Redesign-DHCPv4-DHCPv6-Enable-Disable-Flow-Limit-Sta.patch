From 21570b906fee72e97f06282cafdad899cdb1eced Mon Sep 17 00:00:00 2001
From: ginugeorge <ginugeorge@ami.com>
Date: Wed, 19 Jul 2023 17:48:54 +0530
Subject: [PATCH 60/60] Redesign DHCPv4,DHCPv6 Enable/Disable Flow, Limit
 Static IPv6, Restrict IPv4 PATCH from DHCP to Static and vice versa

---
 redfish-core/lib/ethernet.hpp | 126 +++++++++++++++++++++++++++-------
 1 file changed, 100 insertions(+), 26 deletions(-)

diff --git a/redfish-core/lib/ethernet.hpp b/redfish-core/lib/ethernet.hpp
index ac26fb83..5e56cb73 100644
--- a/redfish-core/lib/ethernet.hpp
+++ b/redfish-core/lib/ethernet.hpp
@@ -1108,6 +1108,40 @@ inline void setDHCPv4Config(const std::string& propertyName, const bool& value,
         dbus::utility::DbusVariantType{value});
 }
 
+inline void triggerDHCPDisable(const std::string& ifaceId, const EthernetInterfaceData& ethData, const DHCPParameters& v4dhcpParms, const DHCPParameters& v6dhcpParms, const std::shared_ptr<bmcweb::AsyncResp>& asyncResp, const bool flag)
+{
+    bool ipv4Active = translateDhcpEnabledToBool(ethData.dhcpEnabled, true);
+    bool ipv6Active = translateDhcpEnabledToBool(ethData.dhcpEnabled, false);
+
+    bool nextv4DHCPState{};
+    if(flag)
+    {
+        nextv4DHCPState = false;
+    }
+    else if(v4dhcpParms.dhcpv4Enabled)
+    {
+        nextv4DHCPState = *v4dhcpParms.dhcpv4Enabled;
+    }
+    else
+    {
+        nextv4DHCPState = ipv4Active;
+    }
+    bool nextv6DHCPState{};
+    if(!flag)
+    {
+        nextv6DHCPState = false;
+    }
+    else if(v6dhcpParms.dhcpv6OperatingMode)
+    {
+        nextv6DHCPState = (*v6dhcpParms.dhcpv6OperatingMode == "Stateful" || *v6dhcpParms.dhcpv6OperatingMode == "Stateless");
+    }
+    else
+    {
+        nextv6DHCPState = ipv6Active;
+    }
+    setDHCPEnabled(ifaceId, "DHCPEnabled", nextv4DHCPState, nextv6DHCPState, asyncResp);
+}
+
 inline void handleDHCPPatch(const std::string& ifaceId,
                             const EthernetInterfaceData& ethData,
                             const DHCPParameters& v4dhcpParms,
@@ -1132,7 +1166,7 @@ inline void handleDHCPPatch(const std::string& ifaceId,
                                                "OperatingMode");
             return;
         }
-        nextv6DHCPState = (*v6dhcpParms.dhcpv6OperatingMode == "Stateful");
+        nextv6DHCPState = (*v6dhcpParms.dhcpv6OperatingMode == "Stateful" || *v6dhcpParms.dhcpv6OperatingMode == "Stateless");
     }
     else
     {
@@ -1241,6 +1275,7 @@ inline void
     handleIPv4StaticPatch(const std::string& ifaceId,
                           nlohmann::json::array_t& input,
                           const std::vector<IPv4AddressData>& ipv4Data,
+                          const EthernetInterfaceData& ethData, const DHCPParameters& v4dhcpParms, const DHCPParameters& v6dhcpParms,
                           const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
 {
     if (input.empty())
@@ -1254,7 +1289,11 @@ inline void
     }
     else if(input.size() > 1)
     {
-       return;
+        if(!v4dhcpParms.dhcpv4Enabled)
+        {
+            messages::propertySizeExceeded(asyncResp->res, "IPv4StaticAddresses");
+        }
+        return;
     }
 
     unsigned entryIdx = 1;
@@ -1425,6 +1464,10 @@ inline void
             entryIdx++;
         }
     }
+    if(!v4dhcpParms.dhcpv4Enabled) // Invoke triggerDHCPDisable when DHCPv4 -> DHCPEnabled not present
+    {
+        triggerDHCPDisable(ifaceId, ethData, v4dhcpParms, v6dhcpParms, asyncResp, true);
+    }
 }
 
 inline void handleStaticNameServersPatch(
@@ -1540,11 +1583,10 @@ inline void handleIPv6StaticDefaultGatewaysPatch(
     }
 }
 
-
-
 inline void handleIPv6StaticAddressesPatch(
     const std::string& ifaceId, const nlohmann::json::array_t& input,
     const std::vector<IPv6AddressData>& ipv6Data,
+    const EthernetInterfaceData& ethData, const DHCPParameters& v4dhcpParms, const DHCPParameters& v6dhcpParms,
     const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
 {
     if (input.empty())
@@ -1556,6 +1598,14 @@ inline void handleIPv6StaticAddressesPatch(
             "IPv6StaticAddresses");
         return;
     }
+    else if(input.size() > 16)
+    {
+        if(!v6dhcpParms.dhcpv6OperatingMode)
+        {
+            messages::propertySizeExceeded(asyncResp->res, "IPv6StaticAddresses");
+        }
+        return;
+    }
     size_t entryIdx = 1;
     std::vector<IPv6AddressData>::const_iterator nicIpEntry =
         getNextStaticIpEntry(ipv6Data.cbegin(), ipv6Data.cend());
@@ -1663,6 +1713,10 @@ inline void handleIPv6StaticAddressesPatch(
             entryIdx++;
         }
     }
+    if(!v6dhcpParms.dhcpv6OperatingMode) // Invoke triggerDHCPDisable when DHCPv6 -> OperatingMode not present
+    {
+        triggerDHCPDisable(ifaceId, ethData, v4dhcpParms, v6dhcpParms, asyncResp, false);
+    }
 }
 
 inline void
@@ -2008,7 +2062,7 @@ inline void requestEthernetInterfacesRoutes(App& app)
                                 nlohmann::json IPv4Static = *ipv4StaticAddresses;
                                 if(IPv4Static.size() > 1)
                                 {
-                                    messages::invalidIndex(asyncResp->res, 1);
+                                    messages::propertySizeExceeded(asyncResp->res, "IPv4StaticAddresses");
                                     return;
                                 }
                             }
@@ -2019,8 +2073,36 @@ inline void requestEthernetInterfacesRoutes(App& app)
                             return;
                         }
                     }
-                }    
+                }
 
+                if(dhcpv6)
+                {
+                    if (v6dhcpParms.dhcpv6OperatingMode) // DHCPv6 -> OperatingMode is present
+                    {
+                        if (((*v6dhcpParms.dhcpv6OperatingMode == "Stateful") || (*v6dhcpParms.dhcpv6OperatingMode == "Stateless")) && ipv6StaticAddresses)
+                        {
+                            messages::propertyValueConflict(asyncResp->res, "DHCPv6.OperatingMode","IPv6StaticAddresses");
+                            return;
+                        }
+                        else if (*v6dhcpParms.dhcpv6OperatingMode == "Disabled")
+                        {
+                            if (!ipv6StaticAddresses) // and IPv6StaticAddresses attribute is not present
+                            {
+                                messages::propertyMissing(asyncResp->res, "IPv6StaticAddresses");
+                                return;
+                            }
+                            else if(ipv6StaticAddresses) // and IPv6StaticAddresses attribute is present
+                            {
+                                nlohmann::json IPv6Static = *ipv6StaticAddresses;
+                                if(IPv6Static.size() > 16)
+                                {
+                                    messages::propertySizeExceeded(asyncResp->res, "IPv6StaticAddresses");
+                                    return;
+                                }
+                            }
+                        }
+                    }
+                }
 
                 handleDHCPPatch(ifaceId, ethData, v4dhcpParms, v6dhcpParms,
                                 asyncResp);
@@ -2042,24 +2124,16 @@ inline void requestEthernetInterfacesRoutes(App& app)
             }
 
             if (ipv4StaticAddresses)
-        {
-		if(!v4dhcpParms.dhcpv4Enabled)
-		{
-		   messages::propertyMissing(asyncResp->res, "DHCPv4.DHCPEnabled");
-		   return;
-		}
-		else
-		{
-		   // TODO(ed) for some reason the capture of
-		   // ipv4Addresses above is returning a const value,
-		   // not a non-const value. This doesn't really work
-		   // for us, as we need to be able to efficiently move
-		   // out the intermedia nlohmann::json objects. This
-		   // makes a copy of the structure, and operates on
-		   // that, but could be done more efficiently
-                   nlohmann::json::array_t ipv4Static = *ipv4StaticAddresses;
-                   handleIPv4StaticPatch(ifaceId, ipv4Static, ipv4Data, asyncResp);
-		}
+            {
+                // TODO(ed) for some reason the capture of
+                // ipv4Addresses above is returning a const value,
+                // not a non-const value. This doesn't really work
+                // for us, as we need to be able to efficiently move
+                // out the intermedia nlohmann::json objects. This
+                // makes a copy of the structure, and operates on
+                // that, but could be done more efficiently
+                nlohmann::json::array_t ipv4Static = *ipv4StaticAddresses;
+                handleIPv4StaticPatch(ifaceId, ipv4Static, ipv4Data, ethData, v4dhcpParms, v6dhcpParms, asyncResp);
             }
 
             if (staticNameServers)
@@ -2082,8 +2156,8 @@ inline void requestEthernetInterfacesRoutes(App& app)
 
             if (ipv6StaticAddresses)
             {
-                handleIPv6StaticAddressesPatch(ifaceId, *ipv6StaticAddresses,
-                                               ipv6Data, asyncResp);
+                handleIPv6StaticAddressesPatch(ifaceId, *ipv6StaticAddresses, ipv6Data, ethData, v4dhcpParms, v6dhcpParms,
+                                               asyncResp);
             }
 
             if (interfaceEnabled)
-- 
2.39.2

