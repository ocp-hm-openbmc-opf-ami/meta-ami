diff --git a/redfish-core/lib/managers.hpp b/redfish-core/lib/managers.hpp
index aa4c694da..81ac7015a 100644
--- a/redfish-core/lib/managers.hpp
+++ b/redfish-core/lib/managers.hpp
@@ -2225,10 +2308,11 @@ inline void requestRoutesManager(App& app)
                 std::optional<nlohmann::json> oem;
                 std::optional<nlohmann::json> links;
                 std::optional<std::string> datetime;
+                std::optional<std::string> timeZone;

                 if (!json_util::readJsonPatch(req, asyncResp->res, "Oem", oem,
                                               "DateTime", datetime, "Links",
-                                              links))
+                                              links,"DateTimeLocalOffset", timeZone))
                 {
                     return;
                 }
@@ -2296,6 +2380,11 @@ inline void requestRoutesManager(App& app)
                 {
                     setDateTime(asyncResp, std::move(*datetime));
                 }
+               if (timeZone)
+                {
+                    setTimeZone(asyncResp, std::move(*timeZone));
+                }
+
             });
 }

diff --git a/http/utility.hpp b/http/utility.hpp
index da457bec7..fbab11f56 100644
--- a/http/utility.hpp
+++ b/http/utility.hpp
@@ -20,6 +20,10 @@
 #include <type_traits>
 #include <utility>
 #include <variant>
+#include <fstream>
+#include "nlohmann/json.hpp"
+#include <cstring>
+#include <regex>

 namespace crow
 {
@@ -511,10 +515,35 @@ inline bool base64Decode(const std::string_view input, std::string& output)
     return true;
 }

+inline float tzFormatConvert(std::string timeZone)
+{
+try {
+    auto i = timeZone.find(':');
+    timeZone = timeZone.replace(i, 1, ".");
+    std::string minute = timeZone.substr(i + 1);
+    float fValue = std::stof(minute.c_str());
+    fValue /= 60;
+    minute = std::to_string(fValue);
+    auto j = minute.find('.');
+    minute = minute.substr(j + 1);
+    timeZone = timeZone.replace(i + 1, 2, minute);
+
+    float res = std::stof(timeZone.c_str());
+   return res ;
+}
+catch (std::exception &ex) {
+        BMCWEB_LOG_ERROR << "Invalid parameter type" << ex.what();
+return 0;
+}
+}
+
+
+static std::string localTimeZone = "/etc/timezone";
+
 namespace details
 {
-constexpr uint64_t maxMilliSeconds = 253402300799999;
-constexpr uint64_t maxSeconds = 253402300799;
+//constexpr uint64_t maxMilliSeconds = 253402300799999;
+//constexpr uint64_t maxSeconds = 253402300799;
 inline std::string getDateTime(boost::posix_time::milliseconds timeSinceEpoch)
 {
     boost::posix_time::ptime epoch(boost::gregorian::date(1970, 1, 1));
@@ -524,13 +553,63 @@ inline std::string getDateTime(boost::posix_time::milliseconds timeSinceEpoch)
 }
 } // namespace details

+
+inline std::string getTimeZone(std::string filePath)
+{
+    std::fstream in(filePath, std::ios::in);
+    if (!in.is_open())
+    {
+        return "+00:00";
+    }
+    std::string temp = "";
+    in >> temp;
+    in.close();
+    return temp;
+}
+
+inline void saveTimeZone(std::string filePath, std::string timeZone)
+{
+    std::fstream out(filePath, std::ios::out);
+    if (!out.is_open())
+        return;
+    out << timeZone;
+    out.close();
+    return;
+}
+
+inline std::string getDateTime(const std::time_t& time)
+{
+    std::array<char, 128> dateTime;
+    std::string redfishDateTime("0000-00-00T00:00:00Z00:00");
+
+    std::string timeZone = getTimeZone(crow::utility::localTimeZone);
+    auto value = tzFormatConvert(timeZone);
+    int seconds = static_cast<int>(value * 3600);
+    std::chrono::time_point<std::chrono::system_clock> now =
+        std::chrono::system_clock::from_time_t(time);
+    std::time_t now_offset = std::chrono::system_clock::to_time_t(
+        now + std::chrono::seconds(seconds));
+
+    if (std::strftime(dateTime.begin(), dateTime.size(), "%FT%T%z",
+                      std::localtime(&now_offset)))
+    {
+        // insert the colon required by the ISO 8601 standard
+        redfishDateTime = std::string(dateTime.data());
+        redfishDateTime.replace(redfishDateTime.begin() + 19,
+                                redfishDateTime.end(), timeZone);
+    }
+
+    return redfishDateTime;
+}
+
+
 // Returns the formatted date time string.
 // Note that the maximum supported date is 9999-12-31T23:59:59+00:00, if
 // the given |secondsSinceEpoch| is too large, we return the maximum supported
 // date. This behavior is to avoid exceptions throwed by Boost.
 inline std::string getDateTimeUint(uint64_t secondsSinceEpoch)
 {
-    secondsSinceEpoch = std::min(secondsSinceEpoch, details::maxSeconds);
+   // secondsSinceEpoch = std::min(secondsSinceEpoch, details::maxSeconds);
     boost::posix_time::seconds boostSeconds(secondsSinceEpoch);
     return details::getDateTime(
         boost::posix_time::milliseconds(boostSeconds.total_milliseconds()));
@@ -542,8 +621,8 @@ inline std::string getDateTimeUint(uint64_t secondsSinceEpoch)
 // supported date.
 inline std::string getDateTimeUintMs(uint64_t milliSecondsSinceEpoch)
 {
-    milliSecondsSinceEpoch =
-        std::min(details::maxMilliSeconds, milliSecondsSinceEpoch);
+    //milliSecondsSinceEpoch =
+     //   std::min(details::maxMilliSeconds, milliSecondsSinceEpoch);
     return details::getDateTime(
         boost::posix_time::milliseconds(milliSecondsSinceEpoch));
 }
@@ -551,14 +630,14 @@ inline std::string getDateTimeUintMs(uint64_t milliSecondsSinceEpoch)
 inline std::string getDateTimeStdtime(std::time_t secondsSinceEpoch)
 {
     // secondsSinceEpoch >= maxSeconds
-    if constexpr (std::cmp_less_equal(details::maxSeconds,
-                                      std::numeric_limits<std::time_t>::max()))
-    {
-        if (std::cmp_greater_equal(secondsSinceEpoch, details::maxSeconds))
-        {
-            secondsSinceEpoch = details::maxSeconds;
-        }
-    }
+    //if constexpr (std::cmp_less_equal(details::maxSeconds,
+      //                                std::numeric_limits<std::time_t>::max()))
+   // {
+     //   if (std::cmp_greater_equal(secondsSinceEpoch, details::maxSeconds))
+       // {
+         //   secondsSinceEpoch = details::maxSeconds;
+       // }
+    //}
     boost::posix_time::ptime time =
         boost::posix_time::from_time_t(secondsSinceEpoch);
     return boost::posix_time::to_iso_extended_string(time) + "+00:00";
@@ -576,7 +655,8 @@ inline std::string getDateTimeStdtime(std::time_t secondsSinceEpoch)
 inline std::pair<std::string, std::string> getDateTimeOffsetNow()
 {
     std::time_t time = std::time(nullptr);
-    std::string dateTime = getDateTimeStdtime(time);
+    //std::string dateTime = getDateTimeStdtime(time);
+    std::string dateTime = getDateTime(time);

     /* extract the local Time Offset value from the
      * recevied dateTime string.
@@ -612,6 +692,17 @@ struct ConstantTimeCompare
     }
 };

+inline std::time_t getTimestamp(uint64_t millisTimeStamp)
+{
+    // Retrieve Created property with format:
+    // yyyy-mm-ddThh:mm:ss
+    std::chrono::milliseconds chronoTimeStamp(millisTimeStamp);
+    return std::chrono::duration_cast<std::chrono::duration<int>>(
+               chronoTimeStamp)
+        .count();
+}
+
+
 namespace details
 {
 inline boost::urls::url

--- a/redfish-core/lib/managers.hpp
+++ b/redfish-core/lib/managers.hpp
@@ -1954,6 +1956,22 @@ inline void setDateTime(std::shared_ptr<bmcweb::AsyncResp> aResp,
         return;
     }
 }
+inline void setTimeZone(std::shared_ptr<bmcweb::AsyncResp> aResp,
+                        std::string timeZone)
+{
+    std::regex tz_regex("[-+][0-1][0-9]:[0-5][0-9]");
+    auto reg = std::regex_match(timeZone, tz_regex);
+    if (reg)
+    {
+        crow::utility::saveTimeZone(crow::utility::localTimeZone, timeZone);
+    }
+    else
+    {
+        messages::propertyValueFormatError(aResp->res, timeZone,
+                                           "DateTimeLocalOffset");
+    }
+}
+
