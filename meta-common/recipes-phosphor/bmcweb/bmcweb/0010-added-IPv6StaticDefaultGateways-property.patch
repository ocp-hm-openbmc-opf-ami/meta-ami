diff -Naur bmcweb_b/redfish-core/lib/ethernet.hpp bmcweb_a/redfish-core/lib/ethernet.hpp
--- bmcweb_b/redfish-core/lib/ethernet.hpp	2022-10-06 11:39:07.901161821 +0530
+++ bmcweb_a/redfish-core/lib/ethernet.hpp	2022-10-06 11:46:52.029219589 +0530
@@ -56,6 +56,24 @@
     }
 };
 
+struct IPv6StaticDefaultGatewaysData
+{
+    IPv6StaticDefaultGatewaysData(const std::string& id,
+                                  const std::string address,
+                                  const uint8_t prefixLength) :
+        id(id),
+        address(address), prefixLength(prefixLength)
+    {}
+    std::string id;
+    std::string address;
+    uint8_t prefixLength;
+
+    bool operator<(const IPv6StaticDefaultGatewaysData& obj) const
+    {
+        return id < obj.id;
+    }
+};
+
 /**
  * Structure for keeping IPv6 data required by Redfish
  */
@@ -1534,6 +1552,99 @@
         dbus::utility::DbusVariantType{updatedStaticNameServers});
 }
 
+inline void updateIPv6DefaultGateway(
+    const std::string& ifaceId, const std::string& gateway,
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
+{
+    crow::connections::systemBus->async_method_call(
+        [asyncResp](const boost::system::error_code ec) {
+            if (ec)
+            {
+                messages::internalError(asyncResp->res);
+                return;
+            }
+            asyncResp->res.result(boost::beast::http::status::no_content);
+        },
+        "xyz.openbmc_project.Network",
+        "/xyz/openbmc_project/network/" + ifaceId,
+        "org.freedesktop.DBus.Properties", "Set",
+        "xyz.openbmc_project.Network.EthernetInterface", "DefaultGateway6",
+        dbus::utility::DbusVariantType(gateway));
+}
+
+inline void handleIPv6StaticDefaultGatewaysPatch(
+    const std::string& ifaceId, const nlohmann::json& input,
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
+{
+    if (!input.is_array() || input.empty())
+    {
+        messages::propertyValueTypeError(
+            asyncResp->res,
+            input.dump(2, ' ', true, nlohmann::json::error_handler_t::replace),
+            "IPv6StaticDefaultGateways");
+        return;
+    }
+
+    size_t entryIdx = 1;
+    boost::container::flat_set<IPv6StaticDefaultGatewaysData> ipv6GatewaysData;
+    for (const nlohmann::json& thisJson : input)
+    {
+        std::string pathString =
+            "IPv6StaticDefaultGateways/" + std::to_string(entryIdx);
+
+        if (!thisJson.is_null() && !thisJson.empty())
+        {
+            std::optional<std::string> address;
+            std::optional<uint8_t> prefixLength;
+            nlohmann::json thisJsonCopy = thisJson;
+
+            if (!json_util::readJson(thisJsonCopy, asyncResp->res, "Address",
+                                     address, "PrefixLength", prefixLength))
+            {
+                messages::propertyValueFormatError(
+                    asyncResp->res,
+                    thisJson.dump(2, ' ', true,
+                                  nlohmann::json::error_handler_t::replace),
+                    pathString);
+                return;
+            }
+
+            const std::string* addr;
+            uint8_t prefix;
+            if (address)
+            {
+                addr = &(*address);
+            }
+            else
+            {
+                messages::propertyMissing(asyncResp->res,
+                                          pathString + "/Address");
+                return;
+            }
+            if (prefixLength)
+            {
+                prefix = *prefixLength;
+            }
+            else
+            {
+                messages::propertyMissing(asyncResp->res,
+                                          pathString + "/PrefixLength");
+                return;
+            }
+            if (entryIdx == 1)
+            {
+                updateIPv6DefaultGateway(ifaceId, *addr, asyncResp);
+            }
+            ipv6GatewaysData.emplace(std::to_string(entryIdx), *addr, prefix);
+            entryIdx++;
+        }
+        else
+        {
+            updateIPv6DefaultGateway(ifaceId, "", asyncResp);
+        }
+    }
+}
+
 inline void handleIPv6StaticAddressesPatch(
     const std::string& ifaceId, const nlohmann::json& input,
     const boost::container::flat_set<IPv6AddressData>& ipv6Data,
@@ -1927,6 +2038,7 @@
                 std::optional<std::string> fqdn;
                 std::optional<std::string> macAddress;
                 std::optional<std::string> ipv6DefaultGateway;
+                std::optional<nlohmann::json> ipv6StaticDefaultGateways;
                 std::optional<nlohmann::json> ipv4StaticAddresses;
                 std::optional<nlohmann::json> ipv6StaticAddresses;
                 std::optional<std::vector<std::string>> staticNameServers;
@@ -1942,7 +2054,8 @@
                         "IPv4StaticAddresses", ipv4StaticAddresses,
                         "MACAddress", macAddress, "StaticNameServers",
                         staticNameServers, "IPv6DefaultGateway",
-                        ipv6DefaultGateway, "IPv6StaticAddresses",
+                        ipv6DefaultGateway, "IPv6StaticDefaultGateways",
+                        ipv6StaticDefaultGateways, "IPv6StaticAddresses",
                         ipv6StaticAddresses, "DHCPv4", dhcpv4, "DHCPv6", dhcpv6,
                         "MTUSize", mtuSize, "InterfaceEnabled",
                         interfaceEnabled))
@@ -1983,6 +2096,8 @@
                      fqdn = std::move(fqdn), macAddress = std::move(macAddress),
                      ipv4StaticAddresses = std::move(ipv4StaticAddresses),
                      ipv6DefaultGateway = std::move(ipv6DefaultGateway),
+                     ipv6StaticDefaultGateways =
+                         std::move(ipv6StaticDefaultGateways),
                      ipv6StaticAddresses = std::move(ipv6StaticAddresses),
                      staticNameServers = std::move(staticNameServers),
                      dhcpv4 = std::move(dhcpv4), dhcpv6 = std::move(dhcpv6),
@@ -2052,6 +2167,14 @@
                                                           "IPv6DefaultGateway");
                         }
 
+                        if (ipv6StaticDefaultGateways)
+                        {
+                            nlohmann::json ipv6Gateways =
+                                *ipv6StaticDefaultGateways;
+                            handleIPv6StaticDefaultGatewaysPatch(
+                                ifaceId, ipv6Gateways, asyncResp);
+                        }
+
                         if (ipv6StaticAddresses)
                         {
                             const nlohmann::json& ipv6Static =
