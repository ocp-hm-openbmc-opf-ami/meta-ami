From beb545d5cd6683b5143e5d0528c0933934f52a65 Mon Sep 17 00:00:00 2001
From: Pranoy Goru <gorumanip@ami.com>
Date: Tue, 22 Nov 2022 11:21:16 +0530
Subject: [PATCH] Integrated NIC Interface in Redfish

Description

Added NIC interface in redfish,
It will show how many NIC adapters conneted to server.

Test:

busctl tree xyz.openbmc_project.NICMgt
`-/xyz
  `-/xyz/openbmc_project
    |-/xyz/openbmc_project/Nic
    `-/xyz/openbmc_project/NicBMC0

busctl introspect xyz.openbmc_project.NICMgt /xyz/openbmc_project/NicBMC0
NAME                                TYPE      SIGNATURE RESULT/VALUE                  FLAGS
org.freedesktop.DBus.Introspectable interface -         -                             -
.Introspect                         method    -         s                             -
org.freedesktop.DBus.Peer           interface -         -                             -
.GetMachineId                       method    -         s                             -
.Ping                               method    -         -                             -
org.freedesktop.DBus.Properties     interface -         -                             -
.Get                                method    ss        v                             -
.GetAll                             method    s         a{sv}                         -
.Set                                method    ssv       -                             -
.PropertiesChanged                  signal    sa{sv}as  -                             -
xyz.openbmc_project.NICChannel3     interface -         -                             -
.LinkSpeed                          property  s         "Auto-negotiate not complete" emits-change
.LinkStatus                         property  b         false                         emits-change
.MACAddress                         property  s         "00:00:00:00:00:00"           emits-change
xyz.openbmc_project.NicInf          interface -         -                             -
.ChannelCount                       property  u         4                             emits-change
.DeviceId                           property  s         "1593h"                       emits-change
.FirmwareName                       property  s         "E810 FW ver"                 emits-change
.FirmwareVersion                    property  s         "00.00.02.52"                 emits-change
.ManufacturerId                     property  s         "0x00000157"                  emits-change
.VendorId                           property  s         "8086h"                       emits-change

1) Get Network Adapters

https://x.x.x.x/redfish/v1/Chassis/AC_Baseboard/NetworkAdapters

{
    "@odata.id": "/redfish/v1/Chassis/AC_Baseboard/NetworkAdapters",
    "@odata.type": "#NetworkAdapterCollection.NetworkAdapterCollection",
    "Members": [
        {
            "@odata.id": "/redfish/v1/Chassis/AC_Baseboard/NetworkAdapters/NicBMC0"
        }
    ],
    "Members@odata.count": 1,
    "Name": "NetworkAdapter Collection"
}

2) Get Adapter instance

https://x.x.x.x/redfish/v1/Chassis/AC_Baseboard/NetworkAdapters/NicBMC0
{
    "@odata.id": "/redfish/v1/Chassis/AC_Baseboard/NetworkAdapters/NicBMC0",
    "@odata.type": "#NetworkAdapter.v1_4_0.NetworkAdapter",
    "Controllers": [
        {
            "FirmwarePackageVersion": "00.00.02.52",
            "Links": {
                "NetworkPorts": [
                    {
                        "@odata.id": "/redfish/v1/Chassis/AC_Baseboard/NetworkAdapters/NicBMC0/NetworkPorts/NICChannel3"
                    }
                ],
                "NetworkPorts@odata.count": 1
            }
        }
    ],
    "Id": "NicBMC0",
    "Name": "Network Adapter View",
    "NetworkPorts": {
        "@odata.id": "/redfish/v1/Chassis/AC_Baseboard/NetworkAdapters/NicBMC0/NetworkPorts"
    },
    "Status": {
        "Health": "OK",
        "HealthRollup": "OK"
    }
}

3) Get Network Port

https://x.x.x.x/redfish/v1/Chassis/AC_Baseboard/NetworkAdapters/NicBMC0/NetworkPorts/

{
    "@odata.id": "/redfish/v1/Chassis/AC_Baseboard/NetworkAdapters/NicBMC0/NetworkPorts",
    "@odata.type": "#NetworkPortCollection.NetworkPortCollection",
    "Description": "The Collection Network Ports",
    "Members": [
        {
            "@odata.id": "/redfish/v1/Chassis/AC_Baseboard/NetworkAdapters/NicBMC0/NetworkPorts/NICChannel3"
        }
    ],
    "Members@odata.count": 1,
    "Name": "Network Ports Collection"
}

4) Get Network Port Instance

https://x.x.x.x/redfish/v1/Chassis/AC_Baseboard/NetworkAdapters/NicBMC0/NetworkPorts/NICChannel3

{
    "@odata.id": "/redfish/v1/Chassis/AC_Baseboard/NetworkAdapters/NicBMC0/NetworkPorts/NICChannel3",
    "@odata.type": "#NetworkPort.v1_2_5.NetworkPort",
    "AssociatedNetworkAddresses": [
        "00:00:00:00:00:00"
    ],
    "FlowControlConfiguration": "None",
    "Id": "NICChannel3",
    "Name": "Network Port View",
    "Oem": {
        "OpenBmc": {
            "@odata.type": "#OemNetworkPort.v1_0_0.NetworkPort",
            "DeviceId": "1593h"
        }
    },
    "PhysicalPortNumber": "NICChannel3",
    "Status": {
        "Health": "OK",
        "HealthRollup": "OK",
        "State": "Enabled"
    },
    "VendorId": "8086h"
}

Signed-off-by: Pranoy Goru <gorumanip@ami.com>
---
---
 redfish-core/include/redfish.hpp |   9 +
 redfish-core/lib/chassis.hpp     | 640 +++++++++++++++++++++++++++++++
 redfish-core/lib/systems.hpp     | 104 +++++
 3 files changed, 753 insertions(+)

diff --git a/redfish-core/include/redfish.hpp b/redfish-core/include/redfish.hpp
index 7cbaa395..d0d5903a 100644
--- a/redfish-core/include/redfish.hpp
+++ b/redfish-core/include/redfish.hpp
@@ -124,6 +124,12 @@ class RedfishService
 #ifdef BMCWEB_INSECURE_ENABLE_REDFISH_FW_TFTP_UPDATE
         requestRoutesUpdateServiceActionsSimpleUpdate(app);
 #endif
+
+        requestRoutesChassisNetworkCollection(app);
+        requestRoutesChassisNetwork(app);
+        requestRoutesChassisNetworkPorts(app);
+        requestRoutesChassisNetworkPortsCollection(app);
+
         requestRoutesSoftwareInventoryCollection(app);
         requestRoutesSoftwareInventory(app);
 
@@ -183,6 +189,9 @@ class RedfishService
         requestRoutesAcpiEntry(app);
         requestRoutesAcpiFile(app);
 
+        requestRoutesSystemNetworkCollection(app);
+        requestRoutesSystemNetwork(app);
+
         requestRoutesProcessorCollection(app);
         requestRoutesProcessor(app);
         requestRoutesOperatingConfigCollection(app);
diff --git a/redfish-core/lib/chassis.hpp b/redfish-core/lib/chassis.hpp
index a43fd650..87527c93 100644
--- a/redfish-core/lib/chassis.hpp
+++ b/redfish-core/lib/chassis.hpp
@@ -31,6 +31,20 @@
 namespace redfish
 {
 
+
+constexpr const char* smbiosObjPath =
+    "/xyz/openbmc_project/inventory/system/chassis/motherboard/";
+constexpr const char* smbiosInfPath =
+    "xyz.openbmc_project.Inventory.Item.NICChannel0";
+//constexpr const char* mctpObjPath = "/xyz/openbmc_project/Nic";
+constexpr const char* mctpObjPath = "/xyz/openbmc_project/";
+constexpr const char* mctpInfPath = "xyz.openbmc_project.NicInf";
+constexpr const char* smbiosServiceName = "xyz.openbmc_project.Smbios.MDR_V2";
+constexpr const char* mctpServiceName = "xyz.openbmc_project.NICMgt";
+
+using PropertiesType =
+    boost::container::flat_map<std::string, dbus::utility::DbusVariantType>;
+
 /**
  * @brief Retrieves chassis state properties over dbus
  *
@@ -404,6 +418,11 @@ inline void
                     crow::utility::urlFromPieces("redfish", "v1", "Chassis",
                                                  chassisId, "ThermalSubsystem");
 #endif
+                // Network Adapters
+                asyncResp->res.jsonValue["NetworkAdapters"] = {
+                    {"@odata.id", "/redfish/v1/Chassis/" +
+                    chassisId + "/NetworkAdapters"}};
+
                 // SensorCollection
                 asyncResp->res.jsonValue["Sensors"]["@odata.id"] =
                     "/redfish/v1/Chassis/" + chassisId + "/Sensors";
@@ -770,4 +789,625 @@ inline void requestRoutesChassisResetActionInfo(App& app)
             std::bind_front(handleChassisResetActionInfoGet, std::ref(app)));
 }
 
+/*
+inline void getSmbiosNicDevices(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
+                                nlohmann::json& count,
+                                nlohmann::json& entriesArray, int value,
+                                const std::string& chassisId)
+{
+    crow::connections::systemBus->async_method_call(
+        [asyncResp, &entriesArray, &count, value, chassisId](
+            const boost::system::error_code ec,
+            const std::vector<std::pair<
+                std::string,
+                std::vector<std::pair<std::string, std::vector<std::string>>>>>&
+                subtree) {
+            if (ec)
+            {
+                BMCWEB_LOG_ERROR << "DBUS error: no matched iface " << ec
+                                 << "\n";
+                return;
+            }
+
+            for (const auto& netobject : subtree)
+            {
+                std::string net = netobject.first;
+                std::size_t lastPos = net.rfind("/");
+                if (lastPos == std::string::npos || lastPos + 1 >= net.size())
+                {
+                    BMCWEB_LOG_ERROR << "Invalid Nic object path: " << net;
+                    messages::internalError(asyncResp->res);
+                    return;
+                }
+                std::string netName = net.substr(lastPos + 1);
+                if (value == 1)
+                    entriesArray.push_back(
+                        {{"@odata.id", "/redfish/v1/Chassis/" + chassisId +
+                                           "/NetworkAdapters/" + netName}});
+                else
+                    entriesArray.push_back(
+                        {{"@odata.id", "/redfish/v1/Systems/system/"
+                                       "NetworkInterfaces/" +
+                                           netName}});
+            } // object path loop
+            count = entriesArray.size();
+        },
+        "xyz.openbmc_project.ObjectMapper",
+        "/xyz/openbmc_project/object_mapper",
+        "xyz.openbmc_project.ObjectMapper", "GetSubTree", smbiosObjPath, 1,
+        std::array<const char*, 1>{
+            "xyz.openbmc_project.Inventory.Item.NICChannel0"});
+}
+*/
+
+inline void requestRoutesChassisNetworkCollection(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Chassis/<str>/NetworkAdapters/")
+        .privileges(redfish::privileges::getActionInfo)
+        .methods(boost::beast::http::verb::get)(
+            [](const crow::Request&,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& chassisId) {
+                asyncResp->res.jsonValue["@odata.type"] =
+                    "#NetworkAdapterCollection.NetworkAdapterCollection";
+                asyncResp->res.jsonValue["Name"] = "NetworkAdapter Collection";
+                asyncResp->res.jsonValue["@odata.id"] =
+                    "/redfish/v1/Chassis/" + chassisId + "/NetworkAdapters";
+                nlohmann::json& entriesArray =
+                    asyncResp->res.jsonValue["Members"];
+                nlohmann::json& count =
+                    asyncResp->res.jsonValue["Members@odata.count"];
+                entriesArray = nlohmann::json::array();
+                count = 0;
+
+                crow::connections::systemBus->async_method_call(
+                    [asyncResp, chassisId, &entriesArray, &count](
+                        const boost::system::error_code ec,
+                        const std::vector<std::pair<
+                            std::string,
+                            std::vector<std::pair<std::string,
+                                                  std::vector<std::string>>>>>&
+                            subtree) {
+                        if (ec)
+                        {
+                            BMCWEB_LOG_ERROR << "DBUS error: no matched iface "
+                                             << ec << "\n";
+                            return;
+                        }
+
+                        for (const auto& netobject : subtree)
+                        {
+                            std::string net = netobject.first;
+                            std::size_t lastPos = net.rfind("/");
+
+                            if (lastPos == std::string::npos ||
+                                lastPos + 1 >= net.size())
+                            {
+                                BMCWEB_LOG_ERROR << "Invalid Nic object path: "
+                                                 << net;
+                                messages::internalError(asyncResp->res);
+                                return;
+                            }
+
+                            std::string netName = net.substr(lastPos + 1);
+                            entriesArray.push_back(
+                                {{"@odata.id",
+                                  "/redfish/v1/Chassis/" + chassisId +
+                                      "/NetworkAdapters/" + netName}});
+
+                        } // object path loop
+                        count = entriesArray.size();
+                    },
+                    "xyz.openbmc_project.ObjectMapper",
+                    "/xyz/openbmc_project/object_mapper",
+                    "xyz.openbmc_project.ObjectMapper", "GetSubTree",
+                    mctpObjPath, 1,
+                    std::array<const char*, 1>{"xyz.openbmc_project.NicInf"});
+
+/*                getSmbiosNicDevices(asyncResp, count, entriesArray, 1,
+                                    chassisId);*/
+            });
+}
+
+inline void
+    fillNetworkAdpResp(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
+                       const std::string& chassisId, const std::string& netName,
+                       const std::string& netPath, const std::string& objPath,
+                       const std::string& intfPath, const std::string& service)
+{
+    const std::string propertyName = "FirmwareVersion";
+    sdbusplus::asio::getProperty<std::string>(
+        *crow::connections::systemBus, service, netPath, intfPath, propertyName,
+        [asyncResp, propertyName, chassisId, netName, objPath,
+         intfPath](const boost::system::error_code error_code,
+                   const std::string& value) {
+            if (error_code)
+            {
+                messages::internalError(asyncResp->res);
+                return;
+            }
+
+            else if (propertyName == "FirmwareVersion")
+            {
+                crow::connections::systemBus->async_method_call(
+                    [asyncResp, chassisId, netName, value](
+                        const boost::system::error_code ec,
+                        const std::vector<std::pair<
+                            std::string,
+                            std::vector<std::pair<std::string,
+                                                  std::vector<std::string>>>>>&
+                            subtree) {
+                        if (ec)
+                        {
+                            messages::internalError(asyncResp->res);
+                            return;
+                        }
+
+                        std::vector<nlohmann::json> networkPortCollection;
+                        for (const auto& object : subtree)
+                        {
+                            const std::vector<std::pair<
+                                std::string, std::vector<std::string>>>&
+                                connectionNames = object.second;
+
+                            if (connectionNames.size() != 1)
+                            {
+                                BMCWEB_LOG_ERROR << "Connection size "
+                                                 << connectionNames.size()
+                                                 << ", greater than 1";
+                                messages::internalError(asyncResp->res);
+                                return;
+                            }
+
+                            const std::vector<std::string>& interfaces3 =
+                                connectionNames[0].second;
+                            
+                            for (auto i = interfaces3.begin();
+                                 i != interfaces3.end(); ++i)
+                            {
+                                if (*i != "xyz.openbmc_project.NicInf" &&
+                                    !boost::starts_with(*i, "org."))
+                                {
+                                    std::string str = *i;
+                                    std::size_t port_instance = str.rfind(".");
+                                    networkPortCollection.push_back(
+                                        {{"@odata.id",
+                                          "/redfish/v1/Chassis/" + chassisId +
+                                              "/NetworkAdapters/" + netName +
+                                              "/NetworkPorts/" +
+                                              str.substr(port_instance + 1)}});
+                                }
+                            }
+
+                            nlohmann::json& ctrlResp =
+                                asyncResp->res.jsonValue["Controllers"];
+                            ctrlResp.push_back({
+                                {"FirmwarePackageVersion", value},
+                                {"Links",
+                                 {{"NetworkPorts", networkPortCollection},
+                                  {"NetworkPorts@odata.count",
+                                   networkPortCollection.size()}}},
+                            });
+                        }
+                    },
+                    "xyz.openbmc_project.ObjectMapper",
+                    "/xyz/openbmc_project/object_mapper",
+                    "xyz.openbmc_project.ObjectMapper", "GetSubTree", objPath,
+                    0, std::array<const char*, 1>{intfPath.c_str()});
+            }
+        });
+}
+
+inline void requestRoutesChassisNetwork(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Chassis/<str>/NetworkAdapters/<str>/")
+        .privileges(redfish::privileges::getActionInfo)
+        .methods(boost::beast::http::verb::get)(
+            [](const crow::Request&,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& chassisId, const std::string& netName) {
+                asyncResp->res.jsonValue["@odata.type"] =
+                    "#NetworkAdapter.v1_4_0.NetworkAdapter";
+                asyncResp->res.jsonValue["@odata.id"] =
+                    "/redfish/v1/Chassis/" + chassisId + "/NetworkAdapters/" +
+                    netName;
+                asyncResp->res.jsonValue["Id"] = netName;
+                asyncResp->res.jsonValue["Name"] = "Network Adapter View";
+
+                const std::string& path = "/xyz/openbmc_project/" + netName;
+                asyncResp->res.jsonValue["NetworkPorts"] = {
+                    {"@odata.id", "/redfish/v1/Chassis/" + chassisId +
+                                      "/NetworkAdapters/" + netName +
+                                      "/NetworkPorts"}};
+                // nlohmann::json& entriesArray =
+                //    asyncResp->res.jsonValue["Controllers"]["Links"]["Ports"];
+                // entriesArray = nlohmann::json::array();
+
+                std::size_t found = netName.find("NicBMC");
+                if (found == std::string::npos)
+                {
+                    // getNicPorts(asyncResp, entriesArray, chassisId, netName,
+                    //            smbiosObjPath, smbiosInfPath, 0);
+                    const std::string& netPath = smbiosObjPath + netName;
+                    // getProperty(asyncResp, netPath, smbiosServiceName,
+                    //            smbiosInfPath, "FirmwareVersion");
+                    fillNetworkAdpResp(asyncResp, chassisId, netName, netPath,
+                                       smbiosObjPath, smbiosInfPath,
+                                       smbiosServiceName);
+                }
+                else
+                {
+                    // getNicPorts(asyncResp, entriesArray, chassisId, netName,
+                    //            mctpObjPath, mctpInfPath, 0);
+                    const std::string& netPath =
+                        "/xyz/openbmc_project/" + netName;
+                    // getProperty(asyncResp, netPath, mctpServiceName,
+                    //            mctpInfPath, "FirmwareVersion");
+                    fillNetworkAdpResp(asyncResp, chassisId, netName, netPath,
+                                       mctpObjPath, mctpInfPath,
+                                       mctpServiceName);
+                }
+                auto health = std::make_shared<HealthPopulate>(asyncResp);
+                health->populate();
+            });
+}
+
+inline void getNicPorts(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
+                        nlohmann::json& entriesArray,
+                        const std::string& chassisId,
+                        const std::string& netName, const std::string& obj,
+                        const std::string& inf, const int& val)
+{
+    crow::connections::systemBus->async_method_call(
+        [asyncResp, &entriesArray, chassisId, netName, obj, val](
+            const boost::system::error_code ec,
+            const std::vector<std::pair<
+                std::string,
+                std::vector<std::pair<std::string, std::vector<std::string>>>>>&
+                subtree) {
+            if (ec)
+            {
+                messages::internalError(asyncResp->res);
+                return;
+            }
+
+            for (const auto& object : subtree)
+            {
+                const std::vector<
+                    std::pair<std::string, std::vector<std::string>>>&
+                    connectionNames = object.second;
+
+                if (connectionNames.size() != 1)
+                {
+                    BMCWEB_LOG_ERROR << "Connection size "
+                                     << connectionNames.size()
+                                     << ", greater than 1";
+                    messages::internalError(asyncResp->res);
+                    return;
+                }
+
+                const std::vector<std::string>& interfaces3 =
+                    connectionNames[0].second;
+                for (auto i = interfaces3.begin(); i != interfaces3.end(); ++i)
+                {
+                    if (*i != "xyz.openbmc_project.NicInf" && !boost::starts_with(*i, "org."))
+                    {
+                        std::string str = *i;
+                        std::size_t port_instance = str.rfind(".");
+                        entriesArray.push_back(
+                            {{"@odata.id", "/redfish/v1/Chassis/" + chassisId +
+                                               "/NetworkAdapters/" + netName +
+                                               "/NetworkPorts/" +
+                                               str.substr(port_instance + 1)}});
+                    }
+                }
+                if (val == 1)
+                    asyncResp->res.jsonValue["Members@odata.count"] =
+                        entriesArray.size();
+                return;
+            }
+        },
+        "xyz.openbmc_project.ObjectMapper",
+        "/xyz/openbmc_project/object_mapper",
+        "xyz.openbmc_project.ObjectMapper", "GetSubTree", obj, 0,
+        std::array<const char*, 1>{inf.c_str()});
+}
+
+inline void getProperty(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
+                        const std::string& netPath,
+                        const std::string& serviceName,
+                        const std::string& infName,
+                        const std::string& propertyName)
+{
+    sdbusplus::asio::getProperty<std::string>(
+        *crow::connections::systemBus, serviceName, netPath, infName,
+        propertyName,
+        [asyncResp, propertyName](const boost::system::error_code error_code,
+                                  const std::string& value) {
+            if (error_code)
+            {
+                messages::internalError(asyncResp->res);
+                return;
+            }
+
+            if (propertyName == "DeviceId")
+            {
+                asyncResp->res.jsonValue["Oem"]["OpenBmc"][propertyName] =
+                    value;
+            }
+            else if (propertyName == "MACAddress")
+            {
+                std::vector<std::string> associateNwAddrs;
+                associateNwAddrs.push_back(value);
+                asyncResp->res.jsonValue["AssociatedNetworkAddresses"] =
+                    associateNwAddrs;
+            }
+            else
+            {
+                asyncResp->res.jsonValue[propertyName] = value;
+            }
+        });
+}
+
+inline void requestRoutesChassisNetworkPortsCollection(App& app)
+{
+    BMCWEB_ROUTE(
+        app, "/redfish/v1/Chassis/<str>/NetworkAdapters/<str>/NetworkPorts/")
+        .privileges(redfish::privileges::getActionInfo)
+        .methods(boost::beast::http::verb::get)(
+            [](const crow::Request&,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& chassisId, const std::string& netName) {
+                const std::string& path = "/xyz/openbmc_project/" + netName;
+                asyncResp->res.jsonValue["@odata.type"] =
+                    "#NetworkPortCollection.NetworkPortCollection";
+                asyncResp->res.jsonValue["@odata.id"] =
+                    "/redfish/v1/Chassis/" + chassisId + "/NetworkAdapters/" +
+                    netName + "/NetworkPorts";
+
+                asyncResp->res.jsonValue["Name"] = "Network Ports Collection";
+
+                asyncResp->res.jsonValue["Description"] =
+                    "The Collection Network Ports";
+                nlohmann::json& entriesArray =
+                    asyncResp->res.jsonValue["Members"];
+                entriesArray = nlohmann::json::array();
+
+                std::size_t found = netName.find("NicBMC");
+                if (found == std::string::npos)
+                    getNicPorts(asyncResp, entriesArray, chassisId, netName,
+                                smbiosObjPath, smbiosInfPath, 1);
+                else
+                    getNicPorts(asyncResp, entriesArray, chassisId, netName,
+                                mctpObjPath, mctpInfPath, 1);
+            });
+}
+
+inline void requestRoutesChassisNetworkPorts(App& app)
+{
+    BMCWEB_ROUTE(
+        app,
+        "/redfish/v1/Chassis/<str>/NetworkAdapters/<str>/NetworkPorts/<str>/")
+        .privileges(redfish::privileges::getActionInfo)
+        .methods(
+            boost::beast::http::verb::get)([](const crow::Request&,
+                                              const std::shared_ptr<
+                                                  bmcweb::AsyncResp>& asyncResp,
+                                              const std::string& chassisId,
+                                              const std::string& netName,
+                                              const std::string& portName) {
+            asyncResp->res.jsonValue["@odata.type"] =
+                "#NetworkPort.v1_2_5.NetworkPort";
+            asyncResp->res.jsonValue["@odata.id"] =
+                "/redfish/v1/Chassis/" + chassisId + "/NetworkAdapters/" +
+                netName + "/NetworkPorts/" + portName;
+
+            asyncResp->res.jsonValue["Id"] = portName;
+            asyncResp->res.jsonValue["PhysicalPortNumber"] = portName;
+            asyncResp->res.jsonValue["Name"] = "Network Port View";
+            asyncResp->res.jsonValue["FlowControlConfiguration"] = "None";
+
+            auto health = std::make_shared<HealthPopulate>(asyncResp);
+            health->populate();
+            asyncResp->res.jsonValue["Status"]["State"] = "Enabled";
+
+            const std::string objPath = "/xyz/openbmc_project/" + netName;
+            const std::string infPath = "xyz.openbmc_project." + portName;
+
+            const std::string dbusInfPath =
+                "xyz.openbmc_project.Inventory.Item." + portName;
+            const std::string dbusObjPath =
+                "/xyz/openbmc_project/inventory/system/chassis/motherboard/" +
+                netName;
+
+            asyncResp->res.jsonValue["Oem"]["OpenBmc"]["@odata.type"] =
+                "#OemNetworkPort.v1_0_0.NetworkPort";
+            std::size_t found = netName.find("NicBMC");
+            if (found == std::string::npos)
+            {
+                const std::string& netPath = smbiosObjPath + netName;
+                getProperty(asyncResp, netPath, smbiosServiceName, dbusInfPath,
+                            "VendorId");
+                getProperty(asyncResp, netPath, smbiosServiceName, dbusInfPath,
+                            "DeviceId");
+                getProperty(asyncResp, netPath, smbiosServiceName, dbusInfPath,
+                            "MACAddress");
+                crow::connections::systemBus->async_method_call(
+                    [asyncResp, netName, dbusInfPath,
+                     dbusObjPath](const boost::system::error_code ec,
+                                  const std::vector<std::string>& storageList) {
+                        if (ec)
+                        {
+                            BMCWEB_LOG_ERROR << "dbus abject mapper call error";
+                            messages::internalError(asyncResp->res);
+                            return;
+                        }
+
+                        for (const std::string& objpath : storageList)
+                        {
+                            std::size_t lastPos = objpath.rfind('/');
+                            if (lastPos == std::string::npos ||
+                                (objpath.size() <= lastPos + 1))
+                            {
+                                BMCWEB_LOG_ERROR << "Failed to find '/' in "
+                                                 << objpath;
+                                continue;
+                            }
+                            std::string objName = objpath.substr(lastPos + 1);
+
+                            if (objName == netName)
+                            {
+                                crow::connections::systemBus->async_method_call(
+                                    [asyncResp](
+                                        const boost::system::error_code ec2,
+                                        const std::vector<std::pair<
+                                            std::string,
+                                            std::variant<uint16_t, uint32_t,
+                                                         uint8_t>>>&
+                                            propertiesList) {
+                                        if (ec2)
+                                        {
+                                            return;
+                                        }
+                                        for (const std::pair<
+                                                 std::string,
+                                                 std::variant<
+                                                     uint16_t, uint32_t,
+                                                     uint8_t>>& property :
+                                             propertiesList)
+                                        {
+                                            const std::string& propertyName =
+                                                property.first;
+                                            if ((propertyName == "PortIndex") ||
+                                                (propertyName == "SlotNumber"))
+                                            {
+                                                const uint16_t* value =
+                                                    std::get_if<uint16_t>(
+                                                        &property.second);
+                                                if (value != nullptr)
+                                                {
+                                                    if (propertyName ==
+                                                        "PortIndex")
+                                                        asyncResp->res.jsonValue
+                                                            ["Oem"]["OpenBmc"]
+                                                            ["PortIndex"] =
+                                                            *value;
+
+                                                    if (propertyName ==
+                                                        "SlotNumber")
+                                                        asyncResp->res.jsonValue
+                                                            ["Oem"]["OpenBmc"]
+                                                            ["SlotNumber"] =
+                                                            *value;
+                                                }
+                                            }
+                                            if (propertyName == "PCIClassCode")
+                                            {
+                                                const uint8_t* value =
+                                                    std::get_if<uint8_t>(
+                                                        &property.second);
+                                                if (value != nullptr)
+                                                {
+                                                    asyncResp->res.jsonValue
+                                                        ["Oem"]["OpenBmc"]
+                                                        ["PCIClassCode"] =
+                                                        *value;
+                                                }
+                                            }
+                                            if (propertyName == "MediaState")
+                                            {
+                                                const uint8_t* value =
+                                                    std::get_if<uint8_t>(
+                                                        &property.second);
+                                                if (value != nullptr)
+                                                {
+                                                    asyncResp->res.jsonValue
+                                                        ["Oem"]["OpenBmc"]
+                                                        ["MediaState"] = *value;
+                                                }
+                                            }
+
+                                            if (propertyName == "CurrentSpeed")
+                                            {
+                                                const uint32_t* value =
+                                                    std::get_if<uint32_t>(
+                                                        &property.second);
+                                                if (value != nullptr)
+                                                {
+                                                    asyncResp->res.jsonValue
+                                                        ["CurrentLinkSpeedMbp"
+                                                         "s"] = *value;
+                                                }
+                                            }
+                                        }
+                                    },
+                                    "xyz.openbmc_project.Smbios.MDR_V2",
+                                    dbusObjPath,
+                                    "org.freedesktop.DBus.Properties", "GetAll",
+                                    dbusInfPath);
+                            }
+                        }
+                    },
+                    "xyz.openbmc_project.ObjectMapper",
+                    "/xyz/openbmc_project/object_mapper",
+                    "xyz.openbmc_project.ObjectMapper", "GetSubTreePaths",
+                    "/xyz/openbmc_project/inventory/system/chassis/"
+                    "motherboard/",
+                    int32_t(0),
+                    std::array<const char*, 1>{
+                        "xyz.openbmc_project.Inventory.Item.NICChannel0"});
+            }
+            else
+            {
+                const std::string& netPath = "/xyz/openbmc_project/" + netName;
+                getProperty(asyncResp, netPath, mctpServiceName, mctpInfPath,
+                            "VendorId");
+                getProperty(asyncResp, netPath, mctpServiceName, mctpInfPath,
+                            "DeviceId");
+                getProperty(asyncResp, netPath, mctpServiceName, infPath,
+                            "MACAddress");
+
+                crow::connections::systemBus->async_method_call(
+                    [asyncResp](const boost::system::error_code error_code,
+                                const PropertiesType& dbus_data) {
+                        if (error_code)
+                        {
+                            messages::internalError(asyncResp->res);
+                            return;
+                        }
+                        for (const auto& property : dbus_data)
+                        {
+                            std::string res = "";
+                            if (property.first == "LinkStatus")
+                            {
+                                const bool* linkStatus =
+                                    std::get_if<bool>(&property.second);
+                                if (linkStatus != nullptr)
+                                {
+                                    if (*linkStatus == true)
+                                    {
+                                        asyncResp->res.jsonValue["LinkStatus"] =
+                                            "Up";
+                                        asyncResp->res
+                                            .jsonValue["SignalDetected"] = true;
+                                    }
+                                    else
+                                    {
+                                        asyncResp->res.jsonValue["LinkStatus"] =
+                                            "Down";
+                                        asyncResp->res
+                                            .jsonValue["SignalDetected"] =
+                                            false;
+                                    }
+                                }
+                            }
+                        } // property loop end
+                    },
+                    "xyz.openbmc_project.NICMgt", objPath,
+                    "org.freedesktop.DBus.Properties", "GetAll", infPath);
+
+            }
+        });
+}
+
 } // namespace redfish
diff --git a/redfish-core/lib/systems.hpp b/redfish-core/lib/systems.hpp
index b92fc7e7..d0ad682d 100644
--- a/redfish-core/lib/systems.hpp
+++ b/redfish-core/lib/systems.hpp
@@ -3099,6 +3099,9 @@ inline void requestRoutesSystems(App& app)
         asyncResp->res.jsonValue["Status"]["Health"] = "OK";
         asyncResp->res.jsonValue["Status"]["State"] = "Enabled";
 
+        asyncResp->res.jsonValue["NetworkInterfaces"] = {
+                {"@odata.id", "/redfish/v1/Systems/system/NetworkInterfaces"}};
+
         // Fill in SerialConsole info
         asyncResp->res.jsonValue["SerialConsole"]["MaxConcurrentSessions"] = 15;
         asyncResp->res.jsonValue["SerialConsole"]["IPMI"]["ServiceEnabled"] =
@@ -3436,4 +3439,105 @@ inline void requestRoutesSystemResetActionInfo(App& app)
         asyncResp->res.jsonValue["Parameters"] = std::move(parameters);
         });
 }
+
+inline void requestRoutesSystemNetworkCollection(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/NetworkInterfaces/")
+        .privileges(redfish::privileges::getActionInfo)
+        .methods(boost::beast::http::verb::get)(
+            [](const crow::Request&,
+               const std::shared_ptr<bmcweb::AsyncResp>& aResp) {
+                aResp->res.jsonValue["@odata.type"] =
+                    "#NetworkInterfaceCollection.NetworkInterfaceCollection";
+                aResp->res.jsonValue["Name"] = "Network Interface Collection";
+                aResp->res.jsonValue["@odata.id"] =
+                    "/redfish/v1/Systems/system/NetworkInterfaces";
+                nlohmann::json& entriesArray = aResp->res.jsonValue["Members"];
+                nlohmann::json& count =
+                    aResp->res.jsonValue["Members@odata.count"];
+                entriesArray = nlohmann::json::array();
+                count = 0;
+
+                crow::connections::systemBus->async_method_call(
+                    [aResp, &entriesArray, &count](
+                        const boost::system::error_code ec,
+                        const std::vector<std::pair<
+                            std::string,
+                            std::vector<std::pair<std::string,
+                                                  std::vector<std::string>>>>>&
+                            subtree) {
+                        if (ec)
+                        {
+                            BMCWEB_LOG_ERROR << "DBUS error: no matched iface "
+                                             << ec << "\n";
+                            return;
+                        }
+
+                        for (const auto& netobject : subtree)
+                        {
+
+                            std::string net = netobject.first;
+                            std::size_t lastPos = net.rfind("/");
+
+                            if (lastPos == std::string::npos ||
+                                lastPos + 1 >= net.size())
+                            {
+                                messages::internalError(aResp->res);
+                                return;
+                            }
+
+                            std::string netName = net.substr(lastPos + 1);
+                            entriesArray.push_back(
+                                {{"@odata.id", "/redfish/v1/Systems/system/"
+                                               "NetworkInterfaces/" +
+                                                   netName}});
+
+                        } // object path loop
+
+                        count = entriesArray.size();
+                    },
+                    "xyz.openbmc_project.ObjectMapper",
+                    "/xyz/openbmc_project/object_mapper",
+                    "xyz.openbmc_project.ObjectMapper", "GetSubTree",
+                    "/xyz/openbmc_project/", 1,
+                    std::array<const char*, 1>{"xyz.openbmc_project.NicInf"});
+                /*getSmbiosNicDevices(aResp, count, entriesArray, 0, "");*/
+            });
+}
+
+inline void requestRoutesSystemNetwork(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/NetworkInterfaces/<str>/")
+        .privileges(redfish::privileges::getActionInfo)
+        .methods(boost::beast::http::verb::get)(
+            [](const crow::Request&,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& netName) {
+                asyncResp->res.jsonValue["@odata.type"] =
+                    "#NetworkInterface.v1_2_1.NetworkInterface";
+                asyncResp->res.jsonValue["@odata.id"] =
+                    "/redfish/v1/Systems/system/NetworkInterfaces/" + netName;
+
+                asyncResp->res.jsonValue["Name"] = "Network Device View";
+                asyncResp->res.jsonValue["Id"] = netName;
+
+                auto health = std::make_shared<HealthPopulate>(asyncResp);
+                health->isManagersHealth = true;
+                health->populate();
+
+                getMainChassisId(
+                    asyncResp,
+                    [netName](const std::string& chassisId,
+                              const std::shared_ptr<bmcweb::AsyncResp>& aRsp) {
+                        aRsp->res.jsonValue["Links"]["NetworkAdapter"] = {
+                            {"@odata.id", "/redfish/v1/Chassis/" + chassisId +
+                                              "/NetworkAdapters/" + netName}};
+                        aRsp->res.jsonValue["NetworkPorts"] = {
+                            {"@odata.id", "/redfish/v1/Chassis/" + chassisId +
+                                              "/NetworkAdapters/" + netName +
+                                              "/NetworkPorts"}};
+                    });
+            });
+}
+
 } // namespace redfish
