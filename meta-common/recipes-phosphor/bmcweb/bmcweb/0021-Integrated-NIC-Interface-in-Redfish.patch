From a52da4607368c4944143783424bd1824fb612782 Mon Sep 17 00:00:00 2001
From: gokulp <gokulp@ami.com>
Date: Tue, 17 Oct 2023 12:11:01 +0530
Subject: [PATCH 21/21] Integrated NIC Interface in Redfish

---
 redfish-core/include/redfish.hpp |   8 +
 redfish-core/lib/chassis.hpp     | 751 +++++++++++++++++++++++++++++++
 redfish-core/lib/systems.hpp     | 100 +++-
 3 files changed, 857 insertions(+), 2 deletions(-)

diff --git a/redfish-core/include/redfish.hpp b/redfish-core/include/redfish.hpp
index 540b0818..b41a8cd7 100644
--- a/redfish-core/include/redfish.hpp
+++ b/redfish-core/include/redfish.hpp
@@ -156,6 +156,11 @@ class RedfishService
 #ifdef BMCWEB_INSECURE_ENABLE_REDFISH_FW_TFTP_UPDATE
         requestRoutesUpdateServiceActionsSimpleUpdate(app);
 #endif
+        requestRoutesChassisNetworkCollection(app);
+        requestRoutesChassisNetwork(app);
+
+        requestRoutesChassisNetworkPorts(app);
+        requestRoutesChassisNetworkPortsCollection(app);
 
         requestRoutesFru(app);
         requestRoutesFruCollection(app);
@@ -218,6 +223,9 @@ class RedfishService
         requestRoutesAcpiEntry(app);
         requestRoutesAcpiFile(app);
 
+        requestRoutesSystemNetworkCollection(app);
+        requestRoutesSystemNetwork(app);
+
         requestRoutesProcessorCollection(app);
         requestRoutesProcessor(app);
         requestRoutesOperatingConfigCollection(app);
diff --git a/redfish-core/lib/chassis.hpp b/redfish-core/lib/chassis.hpp
index 06004d7a..90023b3e 100644
--- a/redfish-core/lib/chassis.hpp
+++ b/redfish-core/lib/chassis.hpp
@@ -47,6 +47,18 @@ namespace redfish
 {
 
 constexpr const char* dbusPropertyInterface = "org.freedesktop.DBus.Properties";
+constexpr const char* smbiosObjPath =
+    "/xyz/openbmc_project/inventory/system/chassis/motherboard/";
+constexpr const char* smbiosInfPath =
+    "xyz.openbmc_project.Inventory.Item.NICChannel0";
+// constexpr const char* mctpObjPath = "/xyz/openbmc_project/Nic";
+constexpr const char* mctpObjPath = "/xyz/openbmc_project/";
+constexpr const char* mctpInfPath = "xyz.openbmc_project.NicInf";
+constexpr const char* smbiosServiceName = "xyz.openbmc_project.Smbios.MDR_V2";
+constexpr const char* mctpServiceName = "xyz.openbmc_project.NICMgt";
+
+using PropertiesType =
+    boost::container::flat_map<std::string, dbus::utility::DbusVariantType>;
 
 using PropertyValue = std::variant<uint8_t, uint16_t, std::string,
                                    std::vector<std::string>, bool>;
@@ -618,6 +630,10 @@ inline void
                 asyncResp->res.jsonValue["Oem"]["AMI"]["@odata.id"] =
                     boost::urls::format("/redfish/v1/Chassis/{}#/Oem/AMI",
                                         chassisId);
+                // Network Adapters
+                asyncResp->res.jsonValue["NetworkAdapters"] = {
+                    {"@odata.id",
+                     "/redfish/v1/Chassis/" + chassisId + "/NetworkAdapters"}};
 
                 // SensorCollection
                 asyncResp->res.jsonValue["Sensors"]["@odata.id"] =
@@ -1436,5 +1452,740 @@ inline void requestRoutesChassisResetActionInfo(App& app)
         .methods(boost::beast::http::verb::get)(
             std::bind_front(handleChassisResetActionInfoGet, std::ref(app)));
 }
+/*
+inline void getSmbiosNicDevices(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
+                                nlohmann::json& count,
+                                nlohmann::json& entriesArray, int value,
+                                const std::string& chassisId)
+{
+    crow::connections::systemBus->async_method_call(
+        [asyncResp, &entriesArray, &count, value, chassisId](
+            const boost::system::error_code ec,
+            const std::vector<std::pair<
+                std::string,
+                std::vector<std::pair<std::string, std::vector<std::string>>>>>&
+                subtree) {
+            if (ec)
+            {
+                BMCWEB_LOG_ERROR << "DBUS error: no matched iface " << ec
+                                 << "\n";
+                return;
+            }
+
+            for (const auto& netobject : subtree)
+            {
+                std::string net = netobject.first;
+                std::size_t lastPos = net.rfind("/");
+                if (lastPos == std::string::npos || lastPos + 1 >= net.size())
+                {
+                    BMCWEB_LOG_ERROR << "Invalid Nic object path: " << net;
+                    messages::internalError(asyncResp->res);
+                    return;
+                }
+                std::string netName = net.substr(lastPos + 1);
+                if (value == 1)
+                    entriesArray.push_back(
+                        {{"@odata.id", "/redfish/v1/Chassis/" + chassisId +
+                                           "/NetworkAdapters/" + netName}});
+                else
+                    entriesArray.push_back(
+                        {{"@odata.id", "/redfish/v1/Systems/system/"
+                                       "NetworkInterfaces/" +
+                                           netName}});
+            } // object path loop
+            count = entriesArray.size();
+        },
+        "xyz.openbmc_project.ObjectMapper",
+        "/xyz/openbmc_project/object_mapper",
+        "xyz.openbmc_project.ObjectMapper", "GetSubTree", smbiosObjPath, 1,
+        std::array<const char*, 1>{
+            "xyz.openbmc_project.Inventory.Item.NICChannel0"});
+}
+*/
+
+inline void requestRoutesChassisNetworkCollection(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Chassis/<str>/NetworkAdapters/")
+        .privileges(redfish::privileges::getActionInfo)
+        .methods(boost::beast::http::verb::get)(
+            [](const crow::Request&,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& chassisId) {
+        asyncResp->res.jsonValue["@odata.type"] =
+            "#NetworkAdapterCollection.NetworkAdapterCollection";
+        asyncResp->res.jsonValue["Name"] = "NetworkAdapter Collection";
+        asyncResp->res.jsonValue["@odata.id"] = "/redfish/v1/Chassis/" +
+                                                chassisId + "/NetworkAdapters";
+        nlohmann::json& entriesArray = asyncResp->res.jsonValue["Members"];
+        nlohmann::json& count = asyncResp->res.jsonValue["Members@odata.count"];
+        entriesArray = nlohmann::json::array();
+        count = 0;
+
+        crow::connections::systemBus->async_method_call(
+            [asyncResp, chassisId, &entriesArray, &count](
+                const boost::system::error_code ec,
+                const std::vector<std::pair<
+                    std::string, std::vector<std::pair<
+                                     std::string, std::vector<std::string>>>>>&
+                    subtree) {
+            if (ec)
+            {
+                BMCWEB_LOG_DEBUG("Failed to open image file.", ec);
+                return;
+            }
+
+            for (const auto& netobject : subtree)
+            {
+                std::string net = netobject.first;
+                std::size_t lastPos = net.rfind("/");
+
+                if (lastPos == std::string::npos || lastPos + 1 >= net.size())
+                {
+                    BMCWEB_LOG_DEBUG("Invalid Nic object path: ", net);
+                    messages::internalError(asyncResp->res);
+                    return;
+                }
+
+                std::string netName = net.substr(lastPos + 1);
+                entriesArray.push_back(
+                    {{"@odata.id", "/redfish/v1/Chassis/" + chassisId +
+                                       "/NetworkAdapters/" + netName}});
+
+            } // object path loop
+            count = entriesArray.size();
+        },
+            "xyz.openbmc_project.ObjectMapper",
+            "/xyz/openbmc_project/object_mapper",
+            "xyz.openbmc_project.ObjectMapper", "GetSubTree", mctpObjPath, 1,
+            std::array<const char*, 1>{"xyz.openbmc_project.NicInf"});
+
+        /*                getSmbiosNicDevices(asyncResp, count, entriesArray, 1,
+                                            chassisId);*/
+    });
+}
+
+inline void
+    fillNetworkAdpResp(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
+                       const std::string& chassisId, const std::string& netName,
+                       const std::string& netPath, const std::string& objPath,
+                       const std::string& intfPath, const std::string& service)
+{
+    const std::string propertyName = "FirmwareVersion";
+    sdbusplus::asio::getProperty<std::string>(
+        *crow::connections::systemBus, service, netPath, intfPath, propertyName,
+        [asyncResp, propertyName, chassisId, netName, objPath,
+         intfPath](const boost::system::error_code error_code,
+                   const std::string& value) {
+        if (error_code)
+        {
+            //    messages::internalError(asyncResp->res);
+            return;
+        }
+
+        else if (propertyName == "FirmwareVersion")
+        {
+            crow::connections::systemBus->async_method_call(
+                [asyncResp, chassisId, netName, value](
+                    const boost::system::error_code ec,
+                    const std::vector<
+                        std::pair<std::string,
+                                  std::vector<std::pair<
+                                      std::string, std::vector<std::string>>>>>&
+                        subtree) {
+                if (ec)
+                {
+                    //    messages::internalError(asyncResp->res);
+                    return;
+                }
+
+                std::vector<nlohmann::json> networkPortCollection;
+                for (const auto& object : subtree)
+                {
+                    const std::vector<
+                        std::pair<std::string, std::vector<std::string>>>&
+                        connectionNames = object.second;
+
+                    const std::string& objectPath = object.first;
+                    std::size_t found = objectPath.find(netName);
+                    if (found != std::string::npos)
+                    {
+                        if (connectionNames.size() != 1)
+                        {
+                            messages::internalError(asyncResp->res);
+                            return;
+                        }
+
+                        const std::vector<std::string>& interfaces3 =
+                            connectionNames[0].second;
+
+                        for (auto i = interfaces3.begin();
+                             i != interfaces3.end(); ++i)
+                        {
+                            if (*i != "xyz.openbmc_project.NicInf" &&
+                                !boost::starts_with(*i, "org."))
+                            {
+                                std::string str = *i;
+                                std::size_t port_instance = str.rfind(".");
+                                networkPortCollection.push_back(
+                                    {{"@odata.id",
+                                      "/redfish/v1/Chassis/" + chassisId +
+                                          "/NetworkAdapters/" + netName +
+                                          "/NetworkPorts/" +
+                                          str.substr(port_instance + 1)}});
+                                break;
+                            }
+                        }
+                        nlohmann::json& ctrlResp =
+                            asyncResp->res.jsonValue["Controllers"];
+                        ctrlResp.push_back({
+                            {"FirmwarePackageVersion", value},
+                            {"Links",
+                             {{"NetworkPorts", networkPortCollection},
+                              {"NetworkPorts@odata.count",
+                               networkPortCollection.size()}}},
+                        });
+                    }
+                }
+            },
+                "xyz.openbmc_project.ObjectMapper",
+                "/xyz/openbmc_project/object_mapper",
+                "xyz.openbmc_project.ObjectMapper", "GetSubTree", objPath, 0,
+                std::array<const char*, 1>{intfPath.c_str()});
+        }
+    });
+}
+
+inline void requestRoutesChassisNetwork(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Chassis/<str>/NetworkAdapters/<str>/")
+        .privileges(redfish::privileges::getActionInfo)
+        .methods(boost::beast::http::verb::get)(
+            [](const crow::Request&,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& chassisId, const std::string& netName) {
+        asyncResp->res.jsonValue["@odata.type"] =
+            "#NetworkAdapter.v1_4_0.NetworkAdapter";
+        asyncResp->res.jsonValue["@odata.id"] =
+            "/redfish/v1/Chassis/" + chassisId + "/NetworkAdapters/" + netName;
+        asyncResp->res.jsonValue["Id"] = netName;
+        asyncResp->res.jsonValue["Name"] = "Network Adapter View";
+
+        const std::string& path = "/xyz/openbmc_project/" + netName;
+        asyncResp->res.jsonValue["NetworkPorts"] = {
+            {"@odata.id", "/redfish/v1/Chassis/" + chassisId +
+                              "/NetworkAdapters/" + netName + "/NetworkPorts"}};
+        // nlohmann::json& entriesArray =
+        //    asyncResp->res.jsonValue["Controllers"]["Links"]["Ports"];
+        // entriesArray = nlohmann::json::array();
+
+        std::size_t found = netName.find("NicBMC");
+        if (found == std::string::npos)
+        {
+            // getNicPorts(asyncResp, entriesArray, chassisId, netName,
+            //            smbiosObjPath, smbiosInfPath, 0);
+            const std::string& netPath = smbiosObjPath + netName;
+            // getProperty(asyncResp, netPath, smbiosServiceName,
+            //            smbiosInfPath, "FirmwareVersion");
+            fillNetworkAdpResp(asyncResp, chassisId, netName, netPath,
+                               smbiosObjPath, smbiosInfPath, smbiosServiceName);
+        }
+        else
+        {
+            // getNicPorts(asyncResp, entriesArray, chassisId, netName,
+            //            mctpObjPath, mctpInfPath, 0);
+            const std::string& netPath = "/xyz/openbmc_project/" + netName;
+            // getProperty(asyncResp, netPath, mctpServiceName,
+            //            mctpInfPath, "FirmwareVersion");
+            fillNetworkAdpResp(asyncResp, chassisId, netName, netPath,
+                               mctpObjPath, mctpInfPath, mctpServiceName);
+        }
+        auto health = std::make_shared<HealthPopulate>(asyncResp);
+        health->populate();
+    });
+}
+
+inline void getNicPorts(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
+                        nlohmann::json& entriesArray,
+                        const std::string& chassisId,
+                        const std::string& netName, const std::string& obj,
+                        const std::string& inf, const int& val)
+{
+    crow::connections::systemBus->async_method_call(
+        [asyncResp, &entriesArray, chassisId, netName, obj, val](
+            const boost::system::error_code ec,
+            const std::vector<std::pair<
+                std::string,
+                std::vector<std::pair<std::string, std::vector<std::string>>>>>&
+                subtree) {
+        if (ec)
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+
+        for (const auto& object : subtree)
+        {
+            const std::vector<std::pair<std::string, std::vector<std::string>>>&
+                connectionNames = object.second;
+            const std::string& objectPath = object.first;
+            std::size_t found = objectPath.find(netName);
+            if (found != std::string::npos)
+            {
+                if (connectionNames.size() != 1)
+                {
+                    messages::internalError(asyncResp->res);
+                    return;
+                }
+
+                const std::vector<std::string>& interfaces3 =
+                    connectionNames[0].second;
+                for (auto i = interfaces3.begin(); i != interfaces3.end(); ++i)
+                {
+                    if (*i != "xyz.openbmc_project.NicInf" &&
+                        !boost::starts_with(*i, "org."))
+                    {
+                        std::string str = *i;
+                        std::size_t port_instance = str.rfind(".");
+                        entriesArray.push_back(
+                            {{"@odata.id", "/redfish/v1/Chassis/" + chassisId +
+                                               "/NetworkAdapters/" + netName +
+                                               "/NetworkPorts/" +
+                                               str.substr(port_instance + 1)}});
+                    }
+                }
+                if (val == 1)
+                    asyncResp->res.jsonValue["Members@odata.count"] =
+                        entriesArray.size();
+                return;
+            }
+        }
+    },
+        "xyz.openbmc_project.ObjectMapper",
+        "/xyz/openbmc_project/object_mapper",
+        "xyz.openbmc_project.ObjectMapper", "GetSubTree", obj, 0,
+        std::array<const char*, 1>{inf.c_str()});
+}
+
+inline void getProperty(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
+                        const std::string& netPath,
+                        const std::string& serviceName,
+                        const std::string& infName,
+                        const std::string& propertyName)
+{
+    sdbusplus::asio::getProperty<std::string>(
+        *crow::connections::systemBus, serviceName, netPath, infName,
+        propertyName,
+        [asyncResp, propertyName](const boost::system::error_code error_code,
+                                  const std::string& value) {
+        if (error_code)
+        {
+            // messages::internalError(asyncResp->res);
+            return;
+        }
+
+        if (propertyName == "DeviceId")
+        {
+            asyncResp->res.jsonValue["Oem"]["OpenBmc"][propertyName] = value;
+        }
+        else if (propertyName == "CurrentTemperature")
+        {
+            asyncResp->res.jsonValue["Oem"]["OpenBmc"][propertyName] = value;
+        }
+        else if (propertyName == "FirmwareName")
+        {
+            asyncResp->res.jsonValue["Oem"]["OpenBmc"][propertyName] = value;
+        }
+        else if (propertyName == "FirmwareVersion")
+        {
+            asyncResp->res.jsonValue["Oem"]["OpenBmc"][propertyName] = value;
+        }
+        else if (propertyName == "MCTP_over_PCIE_EID")
+        {
+            asyncResp->res.jsonValue["Oem"]["OpenBmc"][propertyName] = value;
+        }
+        else if (propertyName == "MCTP_over_SMBUS_EID")
+        {
+            asyncResp->res.jsonValue["Oem"]["OpenBmc"][propertyName] = value;
+        }
+        else if (propertyName == "ManufacturerId")
+        {
+            asyncResp->res.jsonValue["Oem"]["OpenBmc"][propertyName] = value;
+        }
+        else if (propertyName == "NCSIVersion")
+        {
+            asyncResp->res.jsonValue["Oem"]["OpenBmc"][propertyName] = value;
+        }
+        else if (propertyName == "OEM_Mac_Address")
+        {
+            asyncResp->res.jsonValue["Oem"]["OpenBmc"][propertyName] = value;
+        }
+        else if (propertyName == "SSId")
+        {
+            asyncResp->res.jsonValue["Oem"]["OpenBmc"][propertyName] = value;
+        }
+        else if (propertyName == "SVId")
+        {
+            asyncResp->res.jsonValue["Oem"]["OpenBmc"][propertyName] = value;
+        }
+        else if (propertyName == "UUID")
+        {
+            asyncResp->res.jsonValue["Oem"]["OpenBmc"][propertyName] = value;
+        }
+        else if (propertyName == "GetNCCapabilitiesAndSettings")
+        {
+            asyncResp->res.jsonValue["Oem"]["OpenBmc"][propertyName] = value;
+        }
+        else if (propertyName == "GetBootConfigProperties")
+        {
+            asyncResp->res.jsonValue["Oem"]["OpenBmc"][propertyName] = value;
+        }
+        else if (propertyName == "GetPFAssignmentProperties")
+        {
+            asyncResp->res.jsonValue["Oem"]["OpenBmc"][propertyName] = value;
+        }
+        else if (propertyName == "GetPackageStatus")
+        {
+            asyncResp->res.jsonValue["Oem"]["OpenBmc"][propertyName] = value;
+        }
+        else if (propertyName == "GetPartitionProperties")
+        {
+            asyncResp->res.jsonValue["Oem"]["OpenBmc"][propertyName] = value;
+        }
+        else if (propertyName == "GetPartitionStatisticsProperties")
+        {
+            asyncResp->res.jsonValue["Oem"]["OpenBmc"][propertyName] = value;
+        }
+        else if (propertyName == "GetPortConfigurationProperties")
+        {
+            asyncResp->res.jsonValue["Oem"]["OpenBmc"][propertyName] = value;
+        }
+        else
+        {
+            asyncResp->res.jsonValue[propertyName] = value;
+        }
+    });
+}
+
+inline void requestRoutesChassisNetworkPortsCollection(App& app)
+{
+    BMCWEB_ROUTE(
+        app, "/redfish/v1/Chassis/<str>/NetworkAdapters/<str>/NetworkPorts/")
+        .privileges(redfish::privileges::getActionInfo)
+        .methods(boost::beast::http::verb::get)(
+            [](const crow::Request&,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& chassisId, const std::string& netName) {
+        const std::string& path = "/xyz/openbmc_project/" + netName;
+        asyncResp->res.jsonValue["@odata.type"] =
+            "#NetworkPortCollection.NetworkPortCollection";
+        asyncResp->res.jsonValue["@odata.id"] =
+            "/redfish/v1/Chassis/" + chassisId + "/NetworkAdapters/" + netName +
+            "/NetworkPorts";
+
+        asyncResp->res.jsonValue["Name"] = "Network Ports Collection";
+
+        asyncResp->res.jsonValue["Description"] =
+            "The Collection Network Ports";
+        nlohmann::json& entriesArray = asyncResp->res.jsonValue["Members"];
+        entriesArray = nlohmann::json::array();
+
+        std::size_t found = netName.find("NicBMC");
+        if (found == std::string::npos)
+            getNicPorts(asyncResp, entriesArray, chassisId, netName,
+                        smbiosObjPath, smbiosInfPath, 1);
+        else
+            getNicPorts(asyncResp, entriesArray, chassisId, netName,
+                        mctpObjPath, mctpInfPath, 1);
+    });
+}
+
+inline void requestRoutesChassisNetworkPorts(App& app)
+{
+    BMCWEB_ROUTE(
+        app,
+        "/redfish/v1/Chassis/<str>/NetworkAdapters/<str>/NetworkPorts/<str>/")
+        .privileges(redfish::privileges::getActionInfo)
+        .methods(boost::beast::http::verb::get)(
+            [](const crow::Request&,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& chassisId, const std::string& netName,
+               const std::string& portName) {
+        asyncResp->res.jsonValue["@odata.type"] =
+            "#NetworkPort.v1_2_5.NetworkPort";
+        asyncResp->res.jsonValue["@odata.id"] =
+            "/redfish/v1/Chassis/" + chassisId + "/NetworkAdapters/" + netName +
+            "/NetworkPorts/" + portName;
+
+        asyncResp->res.jsonValue["Id"] = portName;
+        asyncResp->res.jsonValue["PhysicalPortNumber"] = portName;
+        asyncResp->res.jsonValue["Name"] = "Network Port View";
+        asyncResp->res.jsonValue["FlowControlConfiguration"] = "None";
+
+        auto health = std::make_shared<HealthPopulate>(asyncResp);
+        health->populate();
+        asyncResp->res.jsonValue["Status"]["State"] = "Enabled";
+
+        const std::string objPath = "/xyz/openbmc_project/" + netName;
+        const std::string infPath = "xyz.openbmc_project." + portName;
+
+        const std::string dbusInfPath = "xyz.openbmc_project.Inventory.Item." +
+                                        portName;
+        const std::string dbusObjPath =
+            "/xyz/openbmc_project/inventory/system/chassis/motherboard/" +
+            netName;
+
+        asyncResp->res.jsonValue["Oem"]["OpenBmc"]["@odata.type"] =
+            "#OemNetworkPort.v1_0_0.NetworkPort";
+        std::size_t found = netName.find("NicBMC");
+        if (found == std::string::npos)
+        {
+            const std::string& netPath = smbiosObjPath + netName;
+            getProperty(asyncResp, netPath, smbiosServiceName, dbusInfPath,
+                        "VendorId");
+            getProperty(asyncResp, netPath, smbiosServiceName, dbusInfPath,
+                        "DeviceId");
+            getProperty(asyncResp, netPath, smbiosServiceName, dbusInfPath,
+                        "MACAddress");
+            crow::connections::systemBus->async_method_call(
+                [asyncResp, netName, dbusInfPath,
+                 dbusObjPath](const boost::system::error_code ec,
+                              const std::vector<std::string>& storageList) {
+                if (ec)
+                {
+                    messages::internalError(asyncResp->res);
+                    return;
+                }
+
+                for (const std::string& objpath : storageList)
+                {
+                    std::size_t lastPos = objpath.rfind('/');
+                    if (lastPos == std::string::npos ||
+                        (objpath.size() <= lastPos + 1))
+                    {
+                        BMCWEB_LOG_DEBUG("Failed to find '/' in", objpath);
+                        continue;
+                    }
+                    std::string objName = objpath.substr(lastPos + 1);
+
+                    if (objName == netName)
+                    {
+                        crow::connections::systemBus->async_method_call(
+                            [asyncResp](
+                                const boost::system::error_code ec2,
+                                const std::vector<std::pair<
+                                    std::string,
+                                    std::variant<uint16_t, uint32_t, uint8_t>>>&
+                                    propertiesList) {
+                            if (ec2)
+                            {
+                                return;
+                            }
+                            for (const std::pair<
+                                     std::string,
+                                     std::variant<uint16_t, uint32_t, uint8_t>>&
+                                     property : propertiesList)
+                            {
+                                const std::string& propertyName =
+                                    property.first;
+                                if ((propertyName == "PortIndex") ||
+                                    (propertyName == "SlotNumber"))
+                                {
+                                    const uint16_t* value =
+                                        std::get_if<uint16_t>(&property.second);
+                                    if (value != nullptr)
+                                    {
+                                        if (propertyName == "PortIndex")
+                                            asyncResp->res
+                                                .jsonValue["Oem"]["OpenBmc"]
+                                                          ["PortIndex"] =
+                                                *value;
+
+                                        if (propertyName == "SlotNumber")
+                                            asyncResp->res
+                                                .jsonValue["Oem"]["OpenBmc"]
+                                                          ["SlotNumber"] =
+                                                *value;
+                                    }
+                                }
+                                if (propertyName == "PCIClassCode")
+                                {
+                                    const uint8_t* value =
+                                        std::get_if<uint8_t>(&property.second);
+                                    if (value != nullptr)
+                                    {
+                                        asyncResp->res
+                                            .jsonValue["Oem"]["OpenBmc"]
+                                                      ["PCIClassCode"] = *value;
+                                    }
+                                }
+                                if (propertyName == "MediaState")
+                                {
+                                    const uint8_t* value =
+                                        std::get_if<uint8_t>(&property.second);
+                                    if (value != nullptr)
+                                    {
+                                        asyncResp->res
+                                            .jsonValue["Oem"]["OpenBmc"]
+                                                      ["MediaState"] = *value;
+                                    }
+                                }
+
+                                if (propertyName == "CurrentSpeed")
+                                {
+                                    const uint32_t* value =
+                                        std::get_if<uint32_t>(&property.second);
+                                    if (value != nullptr)
+                                    {
+                                        asyncResp->res
+                                            .jsonValue["CurrentLinkSpeedMbp"
+                                                       "s"] = *value;
+                                    }
+                                }
+                            }
+                        },
+                            "xyz.openbmc_project.Smbios.MDR_V2", dbusObjPath,
+                            "org.freedesktop.DBus.Properties", "GetAll",
+                            dbusInfPath);
+                    }
+                }
+            },
+                "xyz.openbmc_project.ObjectMapper",
+                "/xyz/openbmc_project/object_mapper",
+                "xyz.openbmc_project.ObjectMapper", "GetSubTreePaths",
+                "/xyz/openbmc_project/inventory/system/chassis/"
+                "motherboard/",
+                int32_t(0),
+                std::array<const char*, 1>{
+                    "xyz.openbmc_project.Inventory.Item.NICChannel0"});
+        }
+        else
+        {
+            const std::string& netPath = "/xyz/openbmc_project/" + netName;
+            getProperty(asyncResp, netPath, mctpServiceName, mctpInfPath,
+                        "VendorId");
+            getProperty(asyncResp, netPath, mctpServiceName, mctpInfPath,
+                        "DeviceId");
+            getProperty(asyncResp, netPath, mctpServiceName, mctpInfPath,
+                        "CurrentTemperature");
+            getProperty(asyncResp, netPath, mctpServiceName, mctpInfPath,
+                        "FirmwareName");
+            getProperty(asyncResp, netPath, mctpServiceName, mctpInfPath,
+                        "FirmwareVersion");
+            getProperty(asyncResp, netPath, mctpServiceName, mctpInfPath,
+                        "MCTP_over_PCIE_EID");
+            getProperty(asyncResp, netPath, mctpServiceName, mctpInfPath,
+                        "MCTP_over_SMBUS_EID");
+            getProperty(asyncResp, netPath, mctpServiceName, mctpInfPath,
+                        "ManufacturerId");
+            getProperty(asyncResp, netPath, mctpServiceName, mctpInfPath,
+                        "NCSIVersion");
+            getProperty(asyncResp, netPath, mctpServiceName, mctpInfPath,
+                        "OEM_Mac_Address");
+            getProperty(asyncResp, netPath, mctpServiceName, mctpInfPath,
+                        "SSId");
+            getProperty(asyncResp, netPath, mctpServiceName, mctpInfPath,
+                        "SVId");
+            getProperty(asyncResp, netPath, mctpServiceName, mctpInfPath,
+                        "UUID");
+            getProperty(asyncResp, netPath, mctpServiceName, infPath,
+                        "GetNCCapabilitiesAndSettings");
+            getProperty(asyncResp, netPath, mctpServiceName, infPath,
+                        "GetBootConfigProperties");
+            getProperty(asyncResp, netPath, mctpServiceName, infPath,
+                        "GetPFAssignmentProperties");
+            getProperty(asyncResp, netPath, mctpServiceName, infPath,
+                        "GetPackageStatus");
+            getProperty(asyncResp, netPath, mctpServiceName, infPath,
+                        "GetPartitionProperties");
+            getProperty(asyncResp, netPath, mctpServiceName, infPath,
+                        "GetPartitionStatisticsProperties");
+            getProperty(asyncResp, netPath, mctpServiceName, infPath,
+                        "GetPortConfigurationProperties");
+
+            sdbusplus::asio::getProperty<uint8_t>(
+                *crow::connections::systemBus, "xyz.openbmc_project.NICMgt",
+                objPath, infPath, "MACAddressCount",
+                [asyncResp, objPath,
+                 infPath](const boost::system::error_code& ec,
+                          const uint8_t& macAddressCount) {
+                if (ec)
+                {
+                    return;
+                }
+                for (int i = 1; i <= macAddressCount; i++)
+                {
+                    std::string macName = "MACAddress";
+                    macName = macName + std::to_string(i);
+
+                    sdbusplus::asio::getProperty<std::string>(
+                        *crow::connections::systemBus,
+                        "xyz.openbmc_project.NICMgt", objPath, infPath, macName,
+                        [asyncResp,
+                         macName](const boost::system::error_code& ec,
+                                  const std::string& property) {
+                        if (ec)
+                        {
+                            return;
+                        }
+
+                        asyncResp->res.jsonValue["Oem"]["OpenBmc"][macName] =
+                            property;
+                    });
+                }
+                asyncResp->res.jsonValue["Oem"]["OpenBmc"]["MACAddressCount"] =
+                    macAddressCount;
+            });
+
+            sdbusplus::asio::getProperty<uint32_t>(
+                *crow::connections::systemBus, mctpServiceName, objPath,
+                mctpInfPath, "ChannelCount",
+                [asyncResp](const boost::system::error_code& ec,
+                            const uint32_t channelCount) {
+                if (ec)
+                {
+                    return;
+                }
+                asyncResp->res.jsonValue["Oem"]["OpenBmc"]["ChannelCount"] =
+                    channelCount;
+            });
+
+            crow::connections::systemBus->async_method_call(
+                [asyncResp](const boost::system::error_code error_code,
+                            const PropertiesType& dbus_data) {
+                if (error_code)
+                {
+                    // messages::internalError(asyncResp->res);
+                    return;
+                }
+                for (const auto& property : dbus_data)
+                {
+                    std::string res = "";
+                    if (property.first == "LinkStatus")
+                    {
+                        const bool* linkStatus =
+                            std::get_if<bool>(&property.second);
+                        if (linkStatus != nullptr)
+                        {
+                            if (*linkStatus == true)
+                            {
+                                asyncResp->res.jsonValue["LinkStatus"] = "Up";
+                                asyncResp->res.jsonValue["SignalDetected"] =
+                                    true;
+                            }
+                            else
+                            {
+                                asyncResp->res.jsonValue["LinkStatus"] = "Down";
+                                asyncResp->res.jsonValue["SignalDetected"] =
+                                    false;
+                            }
+                        }
+                    }
+                } // property loop end
+            },
+                "xyz.openbmc_project.NICMgt", objPath,
+                "org.freedesktop.DBus.Properties", "GetAll", infPath);
+        }
+    });
+}
 
 } // namespace redfish
diff --git a/redfish-core/lib/systems.hpp b/redfish-core/lib/systems.hpp
index c9e3bd43..a6ffc2d2 100644
--- a/redfish-core/lib/systems.hpp
+++ b/redfish-core/lib/systems.hpp
@@ -3973,8 +3973,6 @@ inline void handleComputerSystemResetActionPost(
     }
 }
 
-
-
 inline void handleComputerSystemHead(
     App& app, const crow::Request& req,
     const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
@@ -4104,6 +4102,8 @@ inline void
     asyncResp->res.jsonValue["Links"]["ManagedBy"] = std::move(managedBy);
     asyncResp->res.jsonValue["Status"]["Health"] = "OK";
     asyncResp->res.jsonValue["Status"]["State"] = "Enabled";
+    asyncResp->res.jsonValue["NetworkInterfaces"] = {
+        {"@odata.id", "/redfish/v1/Systems/system/NetworkInterfaces"}};
 
     // Fill in SerialConsole info
     asyncResp->res.jsonValue["SerialConsole"]["MaxConcurrentSessions"] = 15;
@@ -4522,4 +4522,100 @@ inline void requestRoutesSystems(App& app)
         .methods(boost::beast::http::verb::get)(std::bind_front(
             handleSystemCollectionResetActionGet, std::ref(app)));
 }
+
+inline void requestRoutesSystemNetworkCollection(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/NetworkInterfaces/")
+        .privileges(redfish::privileges::getActionInfo)
+        .methods(boost::beast::http::verb::get)(
+            [](const crow::Request&,
+               const std::shared_ptr<bmcweb::AsyncResp>& aResp) {
+        aResp->res.jsonValue["@odata.type"] =
+            "#NetworkInterfaceCollection.NetworkInterfaceCollection";
+        aResp->res.jsonValue["Name"] = "Network Interface Collection";
+        aResp->res.jsonValue["@odata.id"] =
+            "/redfish/v1/Systems/system/NetworkInterfaces";
+        nlohmann::json& entriesArray = aResp->res.jsonValue["Members"];
+        nlohmann::json& count = aResp->res.jsonValue["Members@odata.count"];
+        entriesArray = nlohmann::json::array();
+        count = 0;
+
+        crow::connections::systemBus->async_method_call(
+            [aResp, &entriesArray, &count](
+                const boost::system::error_code ec,
+                const std::vector<std::pair<
+                    std::string, std::vector<std::pair<
+                                     std::string, std::vector<std::string>>>>>&
+                    subtree) {
+            if (ec)
+            {
+                BMCWEB_LOG_DEBUG("DBUS error: no matched iface", ec);
+                return;
+            }
+
+            for (const auto& netobject : subtree)
+            {
+                std::string net = netobject.first;
+                std::size_t lastPos = net.rfind("/");
+
+                if (lastPos == std::string::npos || lastPos + 1 >= net.size())
+                {
+                    messages::internalError(aResp->res);
+                    return;
+                }
+
+                std::string netName = net.substr(lastPos + 1);
+                entriesArray.push_back(
+                    {{"@odata.id", "/redfish/v1/Systems/system/"
+                                   "NetworkInterfaces/" +
+                                       netName}});
+
+            } // object path loop
+
+            count = entriesArray.size();
+        },
+            "xyz.openbmc_project.ObjectMapper",
+            "/xyz/openbmc_project/object_mapper",
+            "xyz.openbmc_project.ObjectMapper", "GetSubTree",
+            "/xyz/openbmc_project/", 1,
+            std::array<const char*, 1>{"xyz.openbmc_project.NicInf"});
+        /*getSmbiosNicDevices(aResp, count, entriesArray, 0, "");*/
+    });
+}
+
+inline void requestRoutesSystemNetwork(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/NetworkInterfaces/<str>/")
+        .privileges(redfish::privileges::getActionInfo)
+        .methods(boost::beast::http::verb::get)(
+            [](const crow::Request&,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& netName) {
+        asyncResp->res.jsonValue["@odata.type"] =
+            "#NetworkInterface.v1_2_1.NetworkInterface";
+        asyncResp->res.jsonValue["@odata.id"] =
+            "/redfish/v1/Systems/system/NetworkInterfaces/" + netName;
+
+        asyncResp->res.jsonValue["Name"] = "Network Device View";
+        asyncResp->res.jsonValue["Id"] = netName;
+
+        auto health = std::make_shared<HealthPopulate>(asyncResp);
+        health->isManagersHealth = true;
+        health->populate();
+
+        getMainChassisId(
+            asyncResp,
+            [netName](const std::string& chassisId,
+                      const std::shared_ptr<bmcweb::AsyncResp>& aRsp) {
+            aRsp->res.jsonValue["Links"]["NetworkAdapter"] = {
+                {"@odata.id", "/redfish/v1/Chassis/" + chassisId +
+                                  "/NetworkAdapters/" + netName}};
+            aRsp->res.jsonValue["NetworkPorts"] = {
+                {"@odata.id", "/redfish/v1/Chassis/" + chassisId +
+                                  "/NetworkAdapters/" + netName +
+                                  "/NetworkPorts"}};
+        });
+    });
+}
+
 } // namespace redfish
-- 
2.34.1

