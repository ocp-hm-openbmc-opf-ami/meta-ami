From 6c57424b737f122e4650560877cb1ac845fbd13d Mon Sep 17 00:00:00 2001
From: Nibin Chacko <nibinc@ami.com>
Date: Tue, 19 Dec 2023 04:11:11 -0500
Subject: [PATCH 163/163] validate IPv4 address

---
 redfish-core/include/error_messages.hpp       |  10 +
 .../registries/base_message_registry.hpp      |  15 +-
 redfish-core/lib/ethernet.hpp                 | 236 +++++++++++++++---
 redfish-core/src/error_messages.cpp           |  13 +
 4 files changed, 244 insertions(+), 30 deletions(-)

diff --git a/redfish-core/include/error_messages.hpp b/redfish-core/include/error_messages.hpp
index 9837de3a..f1c0849a 100644
--- a/redfish-core/include/error_messages.hpp
+++ b/redfish-core/include/error_messages.hpp
@@ -1096,6 +1096,16 @@ nlohmann::json invalidip(std::string_view arg1, std::string_view arg2);
 void invalidip(crow::Response& res, std::string_view arg1,
                std::string_view arg2);
 
+/**
+ * @brief Formats differentIpSeries message into JSON
+ * Message body: "The values of <arg1> and <arg2> are in different series."
+ *
+ * @returns Message differentIpSeries formatted to JSON*/
+
+nlohmann::json differentIpSeries(std::string_view arg1, std::string_view arg2);
+void differentIpSeries(crow::Response& res, std::string_view arg1,
+                       std::string_view arg2);
+
 /**
  * @brief Formats PasswordResetFailed message into JSON
  * Message body: "Last password cannot be used to reset the redfish account
diff --git a/redfish-core/include/registries/base_message_registry.hpp b/redfish-core/include/registries/base_message_registry.hpp
index c9f778e4..9aaf1f45 100644
--- a/redfish-core/include/registries/base_message_registry.hpp
+++ b/redfish-core/include/registries/base_message_registry.hpp
@@ -1331,7 +1331,19 @@ constexpr std::array registry =
 		{},
 		"Change the password value and resubmit the request",
 	}},
-
+    MessageEntry{
+	    "differentIpSeries",
+	    {
+		"Indicates that the IP addresses are not in the same series",
+		"The values of %1 and %2 are in different series.",
+		"Warning",
+		2,
+		{
+			"string",
+			"string",
+		},
+		"Provide IP in the same series",
+	}},
 };
 
 enum class Index
@@ -1448,5 +1460,6 @@ enum class Index
     unrecognizedRequestBody = 109,
     invalidip=110,
     passwordResetFailed=111,
+    differentIpSeries=112,
 };
 } // namespace redfish::registries::base
diff --git a/redfish-core/lib/ethernet.hpp b/redfish-core/lib/ethernet.hpp
index 251826a2..d24a4115 100644
--- a/redfish-core/lib/ethernet.hpp
+++ b/redfish-core/lib/ethernet.hpp
@@ -50,6 +50,14 @@ enum class LinkType
     Global
 };
 
+enum class Type
+{
+    GATEWAY4_ADDRESS,
+    GATEWAY6_ADDRESS,
+    IP4_ADDRESS,
+    IP6_ADDRESS
+};
+
 /**
  * Structure for keeping IPv4 data required by Redfish
  */
@@ -151,7 +159,7 @@ inline bool translateDhcpEnabledToBool(const std::string& inputDHCP,
              "xyz.openbmc_project.Network.EthernetInterface.DHCPConf.v4") ||
             (inputDHCP ==
              "xyz.openbmc_project.Network.EthernetInterface.DHCPConf.both") ||
-             (inputDHCP ==
+            (inputDHCP ==
              "xyz.openbmc_project.Network.EthernetInterface.DHCPConf.v4v6stateless"));
     }
     return ((inputDHCP ==
@@ -160,15 +168,16 @@ inline bool translateDhcpEnabledToBool(const std::string& inputDHCP,
              "xyz.openbmc_project.Network.EthernetInterface.DHCPConf.both"));
 }
 
-inline std::string getDhcpEnabledEnumeration(bool isIPv4, bool isIPv6, bool ipv6AcceptRA = false)
+inline std::string getDhcpEnabledEnumeration(bool isIPv4, bool isIPv6,
+                                             bool ipv6AcceptRA = false)
 {
     if (isIPv4 && isIPv6) // When both IPv4 and IPv6 is in DHCP Mode
     {
         return "xyz.openbmc_project.Network.EthernetInterface.DHCPConf.both";
     }
-    if (isIPv4) // When IPv4 is in DHCP Mode, IPv6 is in Static Mode
+    if (isIPv4)           // When IPv4 is in DHCP Mode, IPv6 is in Static Mode
     {
-        if(ipv6AcceptRA) // When AcceptRA is true
+        if (ipv6AcceptRA) // When AcceptRA is true
         {
             return "xyz.openbmc_project.Network.EthernetInterface.DHCPConf.v4v6stateless";
         }
@@ -182,7 +191,7 @@ inline std::string getDhcpEnabledEnumeration(bool isIPv4, bool isIPv6, bool ipv6
         return "xyz.openbmc_project.Network.EthernetInterface.DHCPConf.v6";
     }
     // When both IPv4 and IPv6 is in Static Mode
-    if(ipv6AcceptRA) // When AcceptRA is true
+    if (ipv6AcceptRA) // When AcceptRA is true
     {
         return "xyz.openbmc_project.Network.EthernetInterface.DHCPConf.v6stateless";
     }
@@ -1101,7 +1110,8 @@ inline void setDHCPEnabled(const std::string& ifaceId,
                            const bool v6Value, bool ipv6AcceptRA,
                            const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
 {
-    const std::string dhcp = getDhcpEnabledEnumeration(v4Value, v6Value, ipv6AcceptRA);
+    const std::string dhcp = getDhcpEnabledEnumeration(v4Value, v6Value,
+                                                       ipv6AcceptRA);
     sdbusplus::asio::setProperty(
         *crow::connections::systemBus, "xyz.openbmc_project.Network",
         "/xyz/openbmc_project/network/" + ifaceId,
@@ -1176,8 +1186,9 @@ inline void handleSLAACAutoConfigPatch(
 
 inline void triggerDHCPDisable(
     const std::string& ifaceId, const EthernetInterfaceData& ethData,
-    const DHCPParameters& v4dhcpParms, const DHCPParameters& v6dhcpParms, bool ipv6AcceptRA,
-    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp, const bool flag)
+    const DHCPParameters& v4dhcpParms, const DHCPParameters& v6dhcpParms,
+    bool ipv6AcceptRA, const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+    const bool flag)
 {
     bool ipv4Active = translateDhcpEnabledToBool(ethData.dhcpEnabled, true);
     bool ipv6Active = translateDhcpEnabledToBool(ethData.dhcpEnabled, false);
@@ -1208,14 +1219,15 @@ inline void triggerDHCPDisable(
     {
         nextv6DHCPState = ipv6Active;
     }
-    setDHCPEnabled(ifaceId, "DHCPEnabled", nextv4DHCPState, nextv6DHCPState, ipv6AcceptRA,
-                   asyncResp);
+    setDHCPEnabled(ifaceId, "DHCPEnabled", nextv4DHCPState, nextv6DHCPState,
+                   ipv6AcceptRA, asyncResp);
 }
 
 inline void handleDHCPPatch(const std::string& ifaceId,
                             const EthernetInterfaceData& ethData,
                             const DHCPParameters& v4dhcpParms,
-                            const DHCPParameters& v6dhcpParms, bool ipv6AcceptRA,
+                            const DHCPParameters& v6dhcpParms,
+                            bool ipv6AcceptRA,
                             const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
 {
     bool ipv4Active = translateDhcpEnabledToBool(ethData.dhcpEnabled, true);
@@ -1312,8 +1324,8 @@ inline void handleDHCPPatch(const std::string& ifaceId,
     }
 
     BMCWEB_LOG_DEBUG("set DHCPEnabled...");
-    setDHCPEnabled(ifaceId, "DHCPEnabled", nextv4DHCPState, nextv6DHCPState, ipv6AcceptRA,
-                   asyncResp);
+    setDHCPEnabled(ifaceId, "DHCPEnabled", nextv4DHCPState, nextv6DHCPState,
+                   ipv6AcceptRA, asyncResp);
     BMCWEB_LOG_DEBUG("set DNSEnabled...");
     setDHCPv4Config("DNSEnabled", nextDNS, asyncResp);
     BMCWEB_LOG_DEBUG("set NTPEnabled...");
@@ -1340,6 +1352,152 @@ inline std::vector<IPv6AddressData>::const_iterator getNextStaticIpEntry(
     });
 }
 
+inline bool isSameSeries(std::string ipStr, std::string gwStr,
+                         uint8_t prefixLength)
+{
+    uint32_t ip = 0;
+    if (inet_pton(AF_INET, ipStr.c_str(), &ip) !=
+        1) // converting to numerical representation
+    {
+        return false;
+    }
+    uint32_t gw = 0;
+    if (inet_pton(AF_INET, gwStr.c_str(), &gw) !=
+        1) // converting to numerical representation
+    {
+        return false;
+    }
+    // Calculate netmask
+    uint32_t netmask = htonl(~UINT32_C(0) << (32 - prefixLength));
+
+    if ((ip & netmask) != (gw & netmask))
+    {
+        return false;
+    }
+
+    return true;
+}
+
+inline bool isValidIPv4Addr(const std::string& addr, Type type)
+{
+    uint8_t ip[4];
+    uint32_t tmp =
+        ntohl(inet_addr(addr.c_str())); // Convert std::string to const char*
+    for (int i = 0; i < 4; i++)         // Extracting Octets
+    {
+        ip[i] = (tmp >> (8 * (3 - i))) & 0xFF; // spliting into 4 octects.
+    }
+
+    if (type == Type::GATEWAY4_ADDRESS)
+    {
+        if (ip[0] == 0) // checks first octet is zero
+        {
+            return false;
+        }
+    }
+    else if (type == Type::IP4_ADDRESS)
+    {
+        if (ip[0] == 0 && ip[1] == 0 && ip[2] == 0 &&
+            ip[3] == 0) // checks if all four octets are zero
+        {
+            return false;
+        }
+    }
+    return true;
+}
+
+inline bool
+    validateIPv4Json(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                     const nlohmann::json::array_t& input)
+{
+    if (input.empty())
+    {
+        messages::propertyValueTypeError(asyncResp->res, input,
+                                         "IPv4StaticAddresses");
+        return false;
+    }
+    unsigned entryIdx = 1;
+    for (const nlohmann::json& thisJson : input)
+    {
+        std::string pathString = "IPv4StaticAddresses/" +
+                                 std::to_string(entryIdx);
+        if (!thisJson.is_null() && !thisJson.empty())
+        {
+            std::optional<std::string> address;
+            std::optional<std::string> gateway;
+            std::optional<std::string> subnetMask;
+            nlohmann::json thisJsonCopy = thisJson;
+            if (!json_util::readJson(thisJsonCopy, asyncResp->res, "Address",
+                                     address, "SubnetMask", subnetMask,
+                                     "Gateway", gateway))
+            {
+                messages::propertyValueFormatError(asyncResp->res, thisJson,
+                                                   pathString);
+                return false;
+            }
+            if (address && gateway && subnetMask)
+            {
+                const std::string& ipAddress = *address;
+                const std::string& ipGateway = *gateway;
+
+                std::bitset<32> maskBinary(0);
+                if (subnetMask.has_value())
+                {
+                    size_t pos = 0;
+                    for (size_t i = 0; i < 4;
+                         ++i) // converting subnetMask to binary
+                    {
+                        pos = subnetMask->find('.', pos);
+                        if (pos == std::string::npos)
+                        {
+                            break;
+                        }
+                        maskBinary <<= 8;
+                        maskBinary |= std::stoul(subnetMask->substr(pos - 3, 3),
+                                                 nullptr, 0);
+                        ++pos;
+                    }
+                }
+                uint8_t prefixLength = maskBinary.size();
+                for (uint8_t i = 0; i < maskBinary.size();
+                     ++i) // Determine the Prefix Length
+                {
+                    if (maskBinary[i] == 0)
+                    {
+                        prefixLength = i;
+                        break;
+                    }
+                }
+                if (!isSameSeries(
+                        ipAddress, ipGateway,
+                        prefixLength)) // function call for cheching the IPs are
+                                       // in the same series
+                {
+                    messages::differentIpSeries(asyncResp->res, "Address",
+                                                "Gateway");
+                    return false;
+                }
+                if (!isValidIPv4Addr(
+                        ipAddress,
+                        Type::IP4_ADDRESS)) // checking the IPv4 Address
+                {
+                    messages::invalidip(asyncResp->res, "Address", ipAddress);
+                    return false;
+                }
+                if (!isValidIPv4Addr(
+                        ipGateway, Type::GATEWAY4_ADDRESS)) // checking the IPv4
+                                                            // gateway Address
+                {
+                    messages::invalidip(asyncResp->res, "Gateway", ipGateway);
+                    return false;
+                }
+            }
+        }
+        entryIdx++;
+    }
+    return true;
+}
+
 inline void handleIPv4StaticPatch(
     const std::string& ifaceId, nlohmann::json::array_t& input,
     const std::vector<IPv4AddressData>& ipv4Data,
@@ -1528,8 +1686,8 @@ inline void handleIPv4StaticPatch(
     if (!v4dhcpParms.dhcpv4Enabled) // Invoke triggerDHCPDisable when DHCPv4 ->
                                     // DHCPEnabled not present
     {
-        triggerDHCPDisable(ifaceId, ethData, v4dhcpParms, v6dhcpParms, ipv6AcceptRA,
-                           asyncResp, true);
+        triggerDHCPDisable(ifaceId, ethData, v4dhcpParms, v6dhcpParms,
+                           ipv6AcceptRA, asyncResp, true);
     }
 }
 
@@ -1543,11 +1701,12 @@ inline void handleStaticNameServersPatch(
         "/xyz/openbmc_project/network/" + ifaceId,
         "xyz.openbmc_project.Network.EthernetInterface", "StaticNameServers",
         updatedStaticNameServers,
-        [asyncResp, updatedStaticNameServers](const boost::system::error_code& ec) {
+        [asyncResp,
+         updatedStaticNameServers](const boost::system::error_code& ec) {
         if (ec)
         {
-            messages::propertyValueTypeError(asyncResp->res,
-                                         updatedStaticNameServers, "StaticNameServers");
+            messages::propertyValueTypeError(
+                asyncResp->res, updatedStaticNameServers, "StaticNameServers");
             return;
         }
     });
@@ -1733,10 +1892,11 @@ inline void handleIPv6StaticAddressesPatch(
                                          asyncResp);
                 nicIpEntry = getNextStaticIpEntry(++nicIpEntry,
                                                   ipv6Data.cend());*/
-		while (nicIpEntry != ipv6Data.cend()) {
+                while (nicIpEntry != ipv6Data.cend())
+                {
                     deleteIPAddress(ifaceId, nicIpEntry->id, asyncResp);
                     nicIpEntry = getNextStaticIpEntry(++nicIpEntry,
-                                                ipv6Data.cend());
+                                                      ipv6Data.cend());
                 }
                 createIPv6(ifaceId, prefix, *addr, asyncResp);
             }
@@ -2075,24 +2235,26 @@ inline void afterVlanCreate(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
     asyncResp->res.addHeader("Location", vlanInterfaceUri.buffer());
 }
 
-inline void handleEthernetInterfaceInstanceGet(App& app, const crow::Request& req, const std::shared_ptr<bmcweb::AsyncResp>& asyncResp, const std::string& ifaceId)
+inline void handleEthernetInterfaceInstanceGet(
+    App& app, const crow::Request& req,
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+    const std::string& ifaceId)
 {
     if (!redfish::setUpRedfishRoute(app, req, asyncResp))
     {
         return;
     }
     getEthernetIfaceData(
-        ifaceId,
-        [asyncResp, ifaceId](const bool& success,
-                                const EthernetInterfaceData& ethData,
-                                const std::vector<IPv4AddressData>& ipv4Data,
-                                const std::vector<IPv6AddressData>& ipv6Data) {
+        ifaceId, [asyncResp, ifaceId](
+                     const bool& success, const EthernetInterfaceData& ethData,
+                     const std::vector<IPv4AddressData>& ipv4Data,
+                     const std::vector<IPv6AddressData>& ipv6Data) {
         if (!success)
         {
             // TODO(Pawel)consider distinguish between non
             // existing object, and other errors
             messages::resourceNotFound(asyncResp->res, "EthernetInterface",
-                                        ifaceId);
+                                       ifaceId);
             return;
         }
 
@@ -2106,7 +2268,10 @@ inline void handleEthernetInterfaceInstanceGet(App& app, const crow::Request& re
     });
 }
 
-inline void handleEthernetInterfaceInstancePatch(App& app, const crow::Request& req, const std::shared_ptr<bmcweb::AsyncResp>& asyncResp, const std::string& ifaceId)
+inline void handleEthernetInterfaceInstancePatch(
+    App& app, const crow::Request& req,
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+    const std::string& ifaceId)
 {
     if (!redfish::setUpRedfishRoute(app, req, asyncResp))
     {
@@ -2201,6 +2366,16 @@ inline void handleEthernetInterfaceInstancePatch(App& app, const crow::Request&
                                         ifaceId);
             return;
         }
+        
+        bool ipv4AddressValid = true;
+        if(ipv4StaticAddresses)  // IPv4StaticAddresses attribute is present
+            {
+                if(!validateIPv4Json(asyncResp,*ipv4StaticAddresses))
+                {
+                    //Invalid IPv4 address provided
+                    ipv4AddressValid =  false;
+                }
+            }
 
         bool ipv6AddressValid = true;
         if(ipv6StaticAddresses) // IPv6StaticAddresses attribute is present
@@ -2252,8 +2427,11 @@ inline void handleEthernetInterfaceInstancePatch(App& app, const crow::Request&
                         messages::propertyValueConflict(asyncResp->res, "DHCPv4.DHCPEnabled","IPv4StaticAddresses");
                         return;
                     }
+                    if(ipv4AddressValid)
+                    {
                     handleDHCPPatch(ifaceId, ethData, v4dhcpParms, v6dhcpParms, ipv6AcceptRA,
                             asyncResp);
+                    }
                 }
             }
 
@@ -2305,7 +2483,7 @@ inline void handleEthernetInterfaceInstancePatch(App& app, const crow::Request&
             handleMACAddressPatch(ifaceId, *macAddress, asyncResp);
         }
 
-        if (ipv4StaticAddresses)
+        if (ipv4StaticAddresses && ipv4AddressValid)
         {
             // TODO(ed) for some reason the capture of
             // ipv4Addresses above is returning a const value,
diff --git a/redfish-core/src/error_messages.cpp b/redfish-core/src/error_messages.cpp
index 8afcbf96..d7eea345 100644
--- a/redfish-core/src/error_messages.cpp
+++ b/redfish-core/src/error_messages.cpp
@@ -1894,6 +1894,19 @@ void invalidip(crow::Response& res, std::string_view arg1,
     addMessageToErrorJson(res.jsonValue, invalidip(arg1, arg2));
 }
 
+nlohmann::json differentIpSeries(std::string_view arg1, std::string_view arg2)
+{
+    return getLog(redfish::registries::base::Index::differentIpSeries,
+                  std::to_array({arg1, arg2}));
+}
+
+void differentIpSeries(crow::Response& res, std::string_view arg1,
+                       std::string_view arg2)
+{
+    res.result(boost::beast::http::status::bad_request);
+    addMessageToErrorJson(res.jsonValue, differentIpSeries(arg1, arg2));
+}
+
 /**
  * @internal
  * @brief Formats passwordResetFailed message into JSON
-- 
2.34.1

