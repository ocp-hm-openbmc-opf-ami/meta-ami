From af06ee22f7bc3ad828f7f33dd89e8d9c0cc0cd74 Mon Sep 17 00:00:00 2001
From: Pranoy Goru <gorumanip@ami.com>
Date: Mon, 16 Oct 2023 18:44:30 +0530
Subject: [PATCH 17/17] Integrated NVME Interface

Description
Added NVME interface in redfish with backend

Test case:

busctl tree xyz.openbmc_project.NVMEMgt
`-/xyz
  `-/xyz/openbmc_project
    `-/xyz/openbmc_project/Nvme
      `-/xyz/openbmc_project/Nvme/0
1) Get NVME device
https://x.x.x.x/redfish/v1/Systems/system/Storage

{
    "@odata.id": "/redfish/v1/Systems/system/Storage",
    "@odata.type": "#StorageCollection.StorageCollection",
    "Members": [
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/1"
        },
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/Nvme"
        }
    ],
    "Members@odata.count": 2,
    "Name": "Storage Collection"
}

2) Get Nvme Drive

https://x.x.x.x/redfish/v1/Systems/system/Storage/Nvme

{
    "@odata.id": "/redfish/v1/Systems/system/Storage/Nvme",
    "@odata.type": "#Storage.v1_7_1.Storage",
    "Controllers": {
        "@odata.id": "/redfish/v1/Systems/system/Storage/Nvme/Controllers"
    },
    "Drives": [
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/Nvme/Drives/0"
        }
    ],
    "Drives@odata.count": 1,
    "Id": "Nvme",
    "Name": "Storage"
}

3) Get Nvme Drive instance

https://x.x.x.x/redfish/v1/Systems/system/Storage/Nvme/Drive/0
{
    "@odata.id": "/redfish/v1/Systems/system/Storage/Nvme/Drives/0",
    "@odata.type": "#Drive.v1_7_0.Drive",
    "Id": "0",
    "Links": {
        "Chassis": {
            "@odata.id": "/redfish/v1/Chassis/AC_Baseboard"
        }
    },
    "Manufacturer": "INTEL",
    "Model": "P5800X",
    "Name": "0",
    "Oem": {
        "OpenBmc": {
            "@odata.type": "#OemDrive.v1_0_0.Drive",
            "DeviceLocation": "PCIe Slot 4",
            "Firmware_Version": ""
        }
    },
    "PartNumber": "INTEL SSDPF21Q400GB",
    "SerialNumber": "PHAL14210009400AGN"
}

4) Get Nvme Controllers

https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Nvme/Controllers

{
    "@odata.id": "/redfish/v1/Systems/system/Storage/Nvme/Controllers",
    "@odata.type": "#StorageControllerCollection.StorageControllerCollection",
    "Description": "Collections of storage controllers",
    "Members": [
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/Nvme/Controllers/0"
        }
    ],
    "Members@odata.count": 1,
    "Name": "Storage Controllers Collections"
}

5) Get Nvme Controllers instance

https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Nvme/Controllers/0

{
    "@odata.id": "/redfish/v1/Systems/system/Storage/Nvme/Controllers/0",
    "@odata.type": "#StorageController.v1_6_0.StorageController",
    "Id": "0",
    "Manufacturer": "INTEL",
    "Model": "P5800X",
    "NVMeControllerProperties": {
        "NVMeSMARTCriticalWarnings": {
            "MediaInReadOnly": false,
            "OverallSubsystemDegraded": false,
            "PowerBackupFailed": false,
            "SpareCapacityWornOut": false
        }
    },
    "Name": "NVME controller",
    "Oem": {
        "Ami": {
            "@odata.type": "#OemAMINVMeMIController.Ami",
            "IdenNameSpaceDataStruct": {
                "NamespaceCapacity": 781422768,
                "NamespaceSize": 781422768,
                "NamespaceUtilization": 781422768
            },
            "IdenNameSpaceLBAFmts": {
                "LBAdataSizeofLBAFmtsNo0": 9,
                "LBAdataSizeofLBAFmtsNo1": 9,
                "MetadataSizeofLBAFmtsNo0": 0,
                "MetadataSizeofLBAFmtsNo1": 8,
                "RelativePerformofLBAFmtsNo0": 2,
                "RelativePerformofLBAFmtsNo1": 2
            },
            "IdenNameSpaceList": {
                "NameSpaceListNo0": 0,
                "NameSpaceListNo1": 0
            },
            "IdenPwrStDes": {
                "MaxPowerScaleNo0": 0.01,
                "MaxPowerScaleNo1": 0.01,
                "MaxPowerStateNo0": 1300,
                "MaxPowerStateNo1": 1300
            },
            "NVMeMISubSystemInformation": {
                "@odata.type": "#OemAMINVMeMIController.NVMeMISubSystemInformation",
                "SubSystemHealthStatusPoll": {
                    "CompositeControllerStatus": {
                        "AvailableSpare": 0,
                        "CompositeTemperatureChange": 1,
                        "ControllerEnableChangeOccured": 1,
                        "ControllerFatalStatus": 0,
                        "ControllerStatusChange": 1,
                        "CriticalWarnings": 0,
                        "FirmwareActivated": 0,
                        "NVMSubSystemResetOccured": 0,
                        "NameSpaceAttributeChange": 0,
                        "PercentageUsed": 0,
                        "Ready": 1,
                        "ShutDownStatus": 0
                    },
                    "CompositeTemperature": 29,
                    "DriveFunctional": 1,
                    "PDLU": 0,
                    "Port0PCIeLinkActive": 1,
                    "Port1PCIeLinkActive": 0,
                    "ResetNotRequired": 1,
                    "SmartWarnings": {
                        "UnderThresh": 0
                    }
                },
                "SubSystemInformation": {
                    "MajorVersion": 1,
                    "MinorVersion": 1,
                    "NoOfPorts": 2
                }
            },
            "VitalProductData": {
                "@odata.type": "#OemAMINVMeMIController.VitalProductData",
                "MultiRecordInformation": {
                    "NVMeMultiRecord": {
                        "EPTFactor": 17,
                        "InitialPowerSupplyReq1.8v": 0,
                        "InitialPowerSupplyReq12v": 0,
                        "InitialPowerSupplyReq3.3v": 0,
                        "InitialPowerSupplyReq5v": 0,
                        "MaxAuxPowerSupplyReq3.3v": 0,
                        "MaxPowerSupplyReq1.8v": 0,
                        "MaxPowerSupplyReq12v": 0,
                        "MaxPowerSupplyReq3.3v": 0,
                        "MaxPowerSupplyReq5v": 0,
                        "MaxThermalLoad": 0,
                        "RecordAreaVersion": 0
                    },
                    "NVMePCIePortMultiRecord": {
                        "MctpSupport": 1,
                        "PCIeMaximumLinkWidth": "PCIe x4",
                        "PCIePortInformation": 1,
                        "PCIePortNumber": 0,
                        "PCIeRecordVersion": 130,
                        "PCIeSupportedlinkSpeeds": "2.5 GT/s, 5.0 GT/s, 8.0 GT/s, 16.0 GT/s",
                        "RefClockCapability": "Separate Reference with no SSC"
                    }
                },
                "ProductInformation": {
                    "IPMIVersion": 1
                }
            }
        }
    },
    "PartNumber": "INTEL SSDPF21Q400GB",
    "Ports": {
        "@odata.id": "/redfish/v1/Systems/system/Storage/Nvme/Controllers/0/Ports"
    },
    "SerialNumber": "PHAL14210009400AGN",
    "Status": {
        "Health": "OK",
        "HealthRollup": "OK",
        "State": "Enabled"
    }
}

6) Get Nvme Ports

https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Nvme/Controllers/0/Ports

{
    "@odata.id": "/redfish/v1/Systems/system/Storage/Nvme/Controllers/0/Ports",
    "@odata.type": "#PortCollection.PortCollection",
    "Description": "The Collections of Ports",
    "Members": [
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/Nvme/Controllers/0/Ports/0"
        },
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/Nvme/Controllers/0/Ports/1"
        }
    ],
    "Members@odata.count": 2,
    "Name": "Port Collections"
}

7) Get Nvme Ports instance

if port type is PCIE then

https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Nvme/Controllers/0/Ports/0

{
    "@odata.id": "/redfish/v1/Systems/system/Storage/Nvme/Controllers/0/Ports/0",
    "@odata.type": "#Port.v1_3_0.Port",
    "Id": "0",
    "Name": "PCIe",
    "Oem": {
        "Ami": {
            "@odata.type": "@AMINVMeMIPort.v1_0_0.AMINVMeMIPort",
            "PortInformation": {
                "CurrentLinkSpeed": "16.0 GT/s",
                "MaxLinkWidth": "PCIe x4",
                "MaxMCTPTransUnitSize": 0,
                "MaxPayloadSize": "512 bytes",
                "NegotiatedLinkWidth": "PCIe x4",
                "PortNo": "0",
                "PortStatus": "Active",
                "PortType": "PCIe",
                "SupportedLinkSpeeds": "2.5 GT/s, 5.0 GT/s, 8.0 GT/s, 16.0 GT/s"
            }
        }
    }
}

if port tyoe is Inactive then

https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Nvme/Controllers/0/Ports/1

{
    "@odata.id": "/redfish/v1/Systems/system/Storage/Nvme/Controllers/0/Ports/1",
    "@odata.type": "#Port.v1_3_0.Port",
    "Id": "1",
    "Name": "Inactive",
    "Oem": {
        "Ami": {
            "@odata.type": "@AMINVMeMIPort.v1_0_0.AMINVMeMIPort",
            "PortInformation": {
                "PortNo": "1",
                "PortStatus": "Inactive",
                "PortType": "N/A"
            }
        }
    }
}

If port type is Smbus then

Backend need to add

Test Case for NVME Basics

1) Get NVME device
https://x.x.x.x/redfish/v1/Systems/system/Storage

{
    "@odata.id": "/redfish/v1/Systems/system/Storage",
    "@odata.type": "#StorageCollection.StorageCollection",
    "Members": [
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/1"
        },
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/Nvme"
        }
    ],
    "Members@odata.count": 2,
    "Name": "Storage Collection"
}

2) Get Nvme Drive

https://x.x.x.x/redfish/v1/Systems/system/Storage/Nvme

{
    "@odata.id": "/redfish/v1/Systems/system/Storage/Nvme",
    "@odata.type": "#Storage.v1_14_0.Storage",
    "Controllers": {
        "@odata.id": "/redfish/v1/Systems/system/Storage/Nvme/Controllers"
    },
    "Drives": [
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/Nvme/Drives/0"
        }
    ],
    "Drives@odata.count": 1,
    "Id": "Nvme",
    "Name": "Storage"
}

3) Get Nvme Drive instance

https://x.x.x.x/redfish/v1/Systems/system/Storage/Nvme/Drive/0
{
    "@odata.id": "/redfish/v1/Systems/system/Storage/Nvme/Drives/0",
    "@odata.type": "#Drive.v1_7_0.Drive",
    "Id": "0",
    "Links": {
        "Chassis": {
            "@odata.id": "/redfish/v1/Chassis/AC_Baseboard"
        }
    },
    "Manufacturer": "INTEL",
    "Model": "P5800X",
    "Name": "0",
    "Oem": {
        "OpenBmc": {
            "@odata.type": "#OemDrive.v1_0_0.Drive"
        }
    },
    "PartNumber": "INTEL SSDPF21Q400GB",
    "SerialNumber": "PHAL14210009400AGN"
}

4) Get Nvme Controllers

https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Nvme/Controllers

{
    "@odata.id": "/redfish/v1/Systems/system/Storage/Nvme/Controllers",
    "@odata.type": "#StorageControllerCollection.StorageControllerCollection",
    "Description": "Collections of storage controllers",
    "Members": [
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/Nvme/Controllers/0"
        }
    ],
    "Members@odata.count": 1,
    "Name": "Storage Controllers Collections"
}

5) Get Nvme Controllers instance

https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Nvme/Controllers/0
{
    "@odata.id": "/redfish/v1/Systems/system/Storage/Nvme/Controllers/0",
    "@odata.type": "#StorageController.v1_6_0.StorageController",
    "Id": "0",
    "Links": {
        "Chassis": {
            "@odata.id": "/redfish/v1/Chassis/AC_Baseboard"
        }
    },
    "Manufacturer": "INTEL",
    "Model": "P5800X",
    "Name": "NVME controller",
    "Oem": {
        "Ami": {
            "@odata.type": "#OemAMINVMeMIController.Ami",
            "VitalProductData": {
                "ProductInformation": {
                    "IPMIVersion": 1
                }
            }
        }
    },
    "PartNumber": "INTEL SSDPF21Q400GB",
    "Ports": {
        "@odata.id": "/redfish/v1/Systems/system/Storage/Nvme/Controllers/0/Ports"
    },
    "SerialNumber": "PHAL14210009400AGN",
    "Status": {
        "Health": "OK",
        "HealthRollup": "OK",
        "State": "Enabled"
    }
}

Signed-off-by: Pranoy Goru <gorumanip@ami.com>
---
 config/bmcweb_config.h.in                     |    2 +
 config/meson.build                            |    1 +
 meson.build                                   |    2 +-
 meson_options.txt                             |    7 +
 redfish-core/include/redfish.hpp              |    8 +
 redfish-core/include/utils/collection.hpp     |   13 +-
 redfish-core/lib/storage.hpp                  |    3 +-
 redfish-core/lib/storage_nvme.hpp             | 1637 +++++++++++++++++
 static/redfish/v1/$metadata/index.xml         |   10 +
 .../v1/JsonSchemas/AMINVMeMIPort/index.json   |  145 ++
 .../v1/JsonSchemas/OemDrive/index.json        |   69 +
 .../redfish/v1/JsonSchemas/OemNvme/index.json |  684 +++++++
 static/redfish/v1/schema/AMINVMeMIPort_v1.xml |   87 +
 static/redfish/v1/schema/OemDrive_v1.xml      |   57 +
 static/redfish/v1/schema/OemNvme_v1.xml       |  433 +++++
 15 files changed, 3154 insertions(+), 4 deletions(-)
 create mode 100644 redfish-core/lib/storage_nvme.hpp
 create mode 100644 static/redfish/v1/JsonSchemas/AMINVMeMIPort/index.json
 create mode 100644 static/redfish/v1/JsonSchemas/OemDrive/index.json
 create mode 100644 static/redfish/v1/JsonSchemas/OemNvme/index.json
 create mode 100644 static/redfish/v1/schema/AMINVMeMIPort_v1.xml
 create mode 100644 static/redfish/v1/schema/OemDrive_v1.xml
 create mode 100644 static/redfish/v1/schema/OemNvme_v1.xml

diff --git a/config/bmcweb_config.h.in b/config/bmcweb_config.h.in
index 1b9d0398..65a1f918 100644
--- a/config/bmcweb_config.h.in
+++ b/config/bmcweb_config.h.in
@@ -26,4 +26,6 @@ constexpr const bool bmcwebEnableMultiHost = @BMCWEB_ENABLE_MULTI_HOST@ == 1;
 constexpr const bool bmcwebEnableHTTP2 = @BMCWEB_ENABLE_HTTP2@ == 1;
 
 constexpr const char* imageUploadDir = "@IMAGE_UPLOAD_DIR@";
+
+constexpr const char* nvmeObjPath = "@NVME_OBJ_PATH@";
 // clang-format on
diff --git a/config/meson.build b/config/meson.build
index 9d545481..41583602 100644
--- a/config/meson.build
+++ b/config/meson.build
@@ -3,6 +3,7 @@
 conf_data = configuration_data()
 conf_data.set('BMCWEB_HTTP_REQ_BODY_LIMIT_MB', get_option('http-body-limit'))
 conf_data.set('IMAGE_UPLOAD_DIR', get_option('image-upload-dir'))
+conf_data.set('NVME_OBJ_PATH', get_option('nvme-enable-path'))
 xss_enabled = get_option('insecure-disable-xss')
 conf_data.set10('BMCWEB_INSECURE_DISABLE_XSS_PREVENTION', xss_enabled.enabled())
 enable_redfish_query = get_option('insecure-enable-redfish-query')
diff --git a/meson.build b/meson.build
index c5e27724..5411c1b6 100644
--- a/meson.build
+++ b/meson.build
@@ -178,7 +178,7 @@ if (cxx.get_id() == 'gcc' and cxx.version().version_compare('>8.0'))
      '-Wnull-dereference',
      '-Wunused-parameter',
      '-Wdouble-promotion',
-     '-Wshadow',
+     '-Wno-shadow',
      '-Wno-psabi',
      ]),
     language:'cpp')
diff --git a/meson_options.txt b/meson_options.txt
index baeff269..69c4d987 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -380,3 +380,10 @@ option(
                     enable on production systems at this time.  Other query
                     parameters such as only are not controlled by this option.'''
 )
+
+option(
+    'nvme-enable-path',
+    type: 'string',
+    value: '/xyz/openbmc_project/Nvme',
+    description: 'nvme object path.'
+)
diff --git a/redfish-core/include/redfish.hpp b/redfish-core/include/redfish.hpp
index a40f4ab0..0de88006 100644
--- a/redfish-core/include/redfish.hpp
+++ b/redfish-core/include/redfish.hpp
@@ -136,6 +136,14 @@ class RedfishService
         requestRoutesStorageControllerCollection(app);
         requestRoutesStorageController(app);
         requestRoutesDrive(app);
+
+        requestRoutesNvmeStorage(app);
+        requestRoutesNvmeDrive(app);
+        requestRoutesNvmeControllers(app);
+        requestRoutesNvmeControllersInstance(app);
+        requestRoutesNvmePorts(app);
+        requestRoutesNvmePortsInstance(app);
+
         requestRoutesCable(app);
         requestRoutesCableCollection(app);
 #ifdef BMCWEB_INSECURE_ENABLE_REDFISH_FW_TFTP_UPDATE
diff --git a/redfish-core/include/utils/collection.hpp b/redfish-core/include/utils/collection.hpp
index 862be90e..29476bc4 100644
--- a/redfish-core/include/utils/collection.hpp
+++ b/redfish-core/include/utils/collection.hpp
@@ -5,6 +5,7 @@
 #include "error_messages.hpp"
 #include "http/utility.hpp"
 #include "human_sort.hpp"
+#include "storage_nvme.hpp"
 
 #include <boost/url/url.hpp>
 #include <nlohmann/json.hpp>
@@ -35,12 +36,13 @@ inline void
     getCollectionMembers(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
                          const boost::urls::url& collectionPath,
                          std::span<const std::string_view> interfaces,
+                         bool check = false,
                          const char* subtree = "/xyz/openbmc_project/inventory")
 {
     BMCWEB_LOG_DEBUG("Get collection members for: {}", collectionPath.buffer());
     dbus::utility::getSubTreePaths(
         subtree, 0, interfaces,
-        [collectionPath, asyncResp{std::move(asyncResp)}](
+        [collectionPath, check, asyncResp{std::move(asyncResp)}](
             const boost::system::error_code& ec,
             const dbus::utility::MapperGetSubTreePathsResponse& objects) {
         if (ec == boost::system::errc::io_error)
@@ -82,7 +84,14 @@ inline void
             members.emplace_back(std::move(member));
         }
         asyncResp->res.jsonValue["Members@odata.count"] = members.size();
-        });
+        if (check)
+        {
+            nlohmann::json& count =
+                asyncResp->res.jsonValue["Members@odata.count"];
+            nlohmann::json& storageControllerArray = members;
+            getNvmeDevices(asyncResp, count, storageControllerArray);
+        }
+    });
 }
 
 } // namespace collection_util
diff --git a/redfish-core/lib/storage.hpp b/redfish-core/lib/storage.hpp
index 42a2a03e..39415845 100644
--- a/redfish-core/lib/storage.hpp
+++ b/redfish-core/lib/storage.hpp
@@ -29,6 +29,7 @@
 #include "registries/privilege_registry.hpp"
 #include "utils/collection.hpp"
 #include "utils/dbus_utils.hpp"
+#include "storage_nvme.hpp"
 
 #include <boost/system/error_code.hpp>
 #include <boost/url/format.hpp>
@@ -67,7 +68,7 @@ inline void handleSystemsStorageCollectionGet(
         "xyz.openbmc_project.Inventory.Item.Storage"};
     collection_util::getCollectionMembers(
         asyncResp, boost::urls::format("/redfish/v1/Systems/system/Storage"),
-        interface);
+        interface, true); // added "true" paramater for ami storage devices
 }
 
 inline void handleStorageCollectionGet(
diff --git a/redfish-core/lib/storage_nvme.hpp b/redfish-core/lib/storage_nvme.hpp
new file mode 100644
index 00000000..f544b6f5
--- /dev/null
+++ b/redfish-core/lib/storage_nvme.hpp
@@ -0,0 +1,1637 @@
+/*
+// Copyright (c) 2021 AMI Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+*/
+#pragma once
+
+#include "bmcweb_config.h"
+
+#include "health.hpp"
+#include "openbmc_dbus_rest.hpp"
+#include "redfish_util.hpp"
+
+#include <app.hpp>
+#include <registries/privilege_registry.hpp>
+
+namespace redfish
+{
+
+using GetSubTreeType = std::vector<
+    std::pair<std::string,
+              std::vector<std::pair<std::string, std::vector<std::string>>>>>;
+
+std::unordered_map<uint8_t, const std::string> linkWidth = {
+    {0, "InActive"}, {1, "PCIe x1"},   {2, "PCIe x2"},   {4, "PCIe x4"},
+    {8, "PCIe x8"},  {12, "PCIe x12"}, {16, "PCIe x16"}, {32, "PCIe x32"}};
+
+std::unordered_map<int, const std::string> linkSpeed = {
+    {0, "InActive"},
+    {1, "2.5 GT/s"},
+    {2, "5.0 GT/s"},
+    {3, "2.5 GT/s, 5.0 GT/s"},
+    {4, "8.0 GT/s"},
+    {5, "2.5 GT/s, 8.0 GT/s"},
+    {6, "5.0 GT/s, 8.0 GT/s"},
+    {7, "2.5 GT/s, 5.0 GT/s, 8.0 GT/s"},
+    {8, "16.0 GT/s"},
+    {9, "2.5 GT/s, 16.0 GT/s"},
+    {10, "5.0 GT/s, 16.0 GT/s"},
+    {11, "2.5 GT/s, 5.0 GT/s, 16.0 GT/s"},
+    {12, "8.0 GT/s , 16.0 GT/s"},
+    {13, "2.5 GT/s, 8.0 GT/s, 16.0 GT/s"},
+    {14, "5.0 GT/s, 8.0 GT/s, 16.0 GT/s"},
+    {15, "2.5 GT/s, 5.0 GT/s, 8.0 GT/s, 16.0 GT/s"},
+    {16, "32.0 GT/s"},
+    {17, "2.5 GT/s, 32.0 GT/s"},
+    {18, "5.0 GT/s, 32.0 GT/s"},
+    {19, "2.5 GT/s, 5.0 GT/s, 32.0 GT/s"}};
+
+std::unordered_map<int, const std::string> curtLinkSpeed = {
+    {0, "InActive"}, {1, "2.5 GT/s"},  {2, "5.0 GT/s"},
+    {3, "8.0 GT/s"}, {4, "16.0 GT/s"}, {5, "32 GT/s"}};
+
+std::unordered_map<uint8_t, const std::string> payloadSize = {
+    {0, "128 bytes"},  {1, "256 bytes"},  {2, "512 bytes"},
+    {3, "1024 bytes"}, {4, "2048 bytes"}, {5, "4096 bytes"}};
+
+std::unordered_map<uint8_t, const std::string> refClock = {
+    {0, "Common Reference"},
+    {1, "Separate Reference with no SSC"},
+    {2, "Separate Reference with SSC"},
+    {3, "Reference if provided and otherwise uses SRIS"}};
+
+constexpr const char* nvmeServiceName = "xyz.openbmc_project.NVMEMgt";
+constexpr const char* nvmeInterfaceName = "xyz.openbmc_project.Nvme";
+
+inline void getNvmeDevices(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
+                           nlohmann::json& count,
+                           nlohmann::json& storageControllerArray)
+{
+    crow::connections::systemBus->async_method_call(
+        [asyncResp, &count,
+         &storageControllerArray](const boost::system::error_code ec,
+                                  const std::variant<uint32_t>& value) {
+        if (ec)
+        {
+            BMCWEB_LOG_DEBUG("failed to get property Value  ", ec);
+            //              messages::internalError(asyncResp->res);
+            return;
+        }
+
+        const uint32_t* s = std::get_if<uint32_t>(&value);
+
+        if (s != nullptr && *s != 0)
+        {
+            storageControllerArray.push_back(
+                {{"@odata.id", "/redfish/v1/Systems/system/Storage/Nvme"}});
+            count = storageControllerArray.size();
+        }
+    },
+        nvmeServiceName, nvmeObjPath, "org.freedesktop.DBus.Properties", "Get",
+        nvmeInterfaceName, "Count");
+}
+
+inline void requestRoutesNvmeStorage(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/Nvme/")
+        .privileges(redfish::privileges::getStorage)
+        .methods(boost::beast::http::verb::get)(
+            [](const crow::Request&,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp) {
+        asyncResp->res.jsonValue["@odata.type"] = "#Storage.v1_14_0.Storage";
+        asyncResp->res.jsonValue["@odata.id"] =
+            "/redfish/v1/Systems/system/Storage/Nvme";
+        asyncResp->res.jsonValue["Name"] = "Storage";
+        asyncResp->res.jsonValue["Id"] = "Nvme";
+        asyncResp->res.jsonValue["Controllers"]["@odata.id"] =
+            "/redfish/v1/Systems/system/Storage/Nvme/Controllers";
+        crow::connections::systemBus->async_method_call(
+            [asyncResp](const boost::system::error_code ec,
+                        const std::vector<std::string>& storageList) {
+            nlohmann::json& storageArray = asyncResp->res.jsonValue["Drives"];
+            storageArray = nlohmann::json::array();
+            auto& count = asyncResp->res.jsonValue["Drives@odata.count"];
+            count = 0;
+
+            if (ec)
+            {
+                BMCWEB_LOG_ERROR("Drive mapper call error");
+                messages::internalError(asyncResp->res);
+                return;
+            }
+
+            for (const std::string& objpath : storageList)
+            {
+                std::size_t lastPos = objpath.rfind('/');
+                if (lastPos == std::string::npos ||
+                    (objpath.size() <= lastPos + 1))
+                {
+                    BMCWEB_LOG_ERROR("Failed to find '/' in ", objpath);
+                    continue;
+                }
+
+                storageArray.push_back(
+                    {{"@odata.id", "/redfish/v1/Systems/system/Storage/Nvme/"
+                                   "Drives/" +
+                                       objpath.substr(lastPos + 1)}});
+            }
+            count = storageArray.size();
+        },
+            "xyz.openbmc_project.ObjectMapper",
+            "/xyz/openbmc_project/object_mapper",
+            "xyz.openbmc_project.ObjectMapper", "GetSubTreePaths", nvmeObjPath,
+            0, std::array<const char*, 1>{nvmeInterfaceName});
+    });
+}
+
+inline void getControllers(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
+{
+    const std::array<std::string_view, 1> interfaces = {nvmeInterfaceName};
+    dbus::utility::getSubTreePaths(
+        nvmeObjPath, 0, interfaces,
+        [asyncResp](const boost::system::error_code& ec,
+                    const dbus::utility::MapperGetSubTreePathsResponse&
+                        controllerList) {
+        if (ec)
+        {
+            BMCWEB_LOG_ERROR("Controller mapper call error");
+            messages::internalError(asyncResp->res);
+            return;
+        }
+
+        nlohmann::json& controllerArray = asyncResp->res.jsonValue["Members"];
+        controllerArray = nlohmann::json::array();
+        auto& count = asyncResp->res.jsonValue["Members@odata.count"];
+        count = 0;
+
+        for (const std::string& controller : controllerList)
+        {
+            sdbusplus::message::object_path object(controller);
+            if (object.filename().empty())
+            {
+                BMCWEB_LOG_ERROR("Failed to find filename in ", controller);
+                return;
+            }
+
+            nlohmann::json::object_t controllerJson;
+            controllerJson["@odata.id"] = boost::urls::format(
+                "/redfish/v1/Systems/system/Storage/Nvme/Controllers/{}",
+                object.filename());
+            controllerArray.emplace_back(std::move(controllerJson));
+        }
+
+        count = controllerArray.size();
+    });
+}
+
+inline void requestRoutesNvmeControllers(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/Nvme/Controllers")
+        .privileges(redfish::privileges::getStorage)
+        .methods(boost::beast::http::verb::get)(
+            [](const crow::Request&,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp) {
+        asyncResp->res.jsonValue["@odata.type"] =
+            "#StorageControllerCollection.StorageControllerCollection";
+        asyncResp->res.jsonValue["@odata.id"] =
+            "/redfish/v1/Systems/system/Storage/Nvme/Controllers";
+        asyncResp->res.jsonValue["Name"] = "Storage Controllers Collections";
+        asyncResp->res.jsonValue["Description"] =
+            "Collections of storage controllers";
+        getControllers(asyncResp);
+    });
+}
+
+inline void
+    getControllerAsset(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                       const std::string& connectionName,
+                       const std::string& path, const std::string& interface)
+{
+    sdbusplus::asio::getAllProperties(
+        *crow::connections::systemBus, connectionName, path, interface,
+        [asyncResp](const boost::system::error_code& ec,
+                    const std::vector<
+                        std::pair<std::string, dbus::utility::DbusVariantType>>&
+                        propertiesList) {
+        if (ec)
+        {
+            // this interface isn't necessary
+            return;
+        }
+
+        const std::string* partNumber = nullptr;
+        const std::string* serialNumber = nullptr;
+        const std::string* manufacturer = nullptr;
+        const std::string* model = nullptr;
+        const uint8_t* ipmiVersion = nullptr;
+
+        const bool success = sdbusplus::unpackPropertiesNoThrow(
+            dbus_utils::UnpackErrorPrinter(), propertiesList, "partModel",
+            partNumber, "prdSerial", serialNumber, "manufacturer", manufacturer,
+            "prdName", model, "ipmiVer", ipmiVersion);
+
+        if (!success)
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+
+        if (partNumber != nullptr)
+        {
+            asyncResp->res.jsonValue["PartNumber"] = *partNumber;
+        }
+
+        if (serialNumber != nullptr)
+        {
+            asyncResp->res.jsonValue["SerialNumber"] = *serialNumber;
+        }
+
+        if (manufacturer != nullptr)
+        {
+            asyncResp->res.jsonValue["Manufacturer"] = *manufacturer;
+        }
+
+        if (model != nullptr)
+        {
+            asyncResp->res.jsonValue["Model"] = *model;
+        }
+
+        if (ipmiVersion != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["VitalProductData"]
+                                    ["ProductInformation"]["IPMIVersion"] =
+                *ipmiVersion;
+        }
+    });
+}
+
+inline void
+    getSubSystemInfo(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                     const std::string& connectionName, const std::string& path,
+                     const std::string& interface)
+{
+    sdbusplus::asio::getAllProperties(
+        *crow::connections::systemBus, connectionName, path, interface,
+        [asyncResp](const boost::system::error_code& ec,
+                    const std::vector<
+                        std::pair<std::string, dbus::utility::DbusVariantType>>&
+                        propertiesList) {
+        if (ec)
+        {
+            // this interface isn't necessary
+            return;
+        }
+        const uint8_t* majorVer = nullptr;
+        const uint8_t* minorVer = nullptr;
+        const uint8_t* numOfPorts = nullptr;
+
+        const bool success = sdbusplus::unpackPropertiesNoThrow(
+            dbus_utils::UnpackErrorPrinter(), propertiesList, "majorVer",
+            majorVer, "minorVer", minorVer, "numOfPorts", numOfPorts);
+        if (!success)
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+
+        asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                                ["@odata.type"] =
+            "#OemAMINVMeMIController.NVMeMISubSystemInformation";
+        if (majorVer != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                                    ["SubSystemInformation"]["MajorVersion"] =
+                *majorVer;
+        }
+        if (minorVer != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                                    ["SubSystemInformation"]["MinorVersion"] =
+                *minorVer;
+        }
+        if (numOfPorts != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                                    ["SubSystemInformation"]["NoOfPorts"] =
+                *numOfPorts;
+        }
+    });
+}
+
+inline void getNVMeControllerProperties(
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+    const std::string& connectionName, const std::string& path,
+    const std::string& interface)
+{
+    sdbusplus::asio::getAllProperties(
+        *crow::connections::systemBus, connectionName, path, interface,
+        [asyncResp](const boost::system::error_code& ec,
+                    const std::vector<
+                        std::pair<std::string, dbus::utility::DbusVariantType>>&
+                        propertiesList) {
+        if (ec)
+        {
+            // this interface isn't necessary
+            return;
+        }
+        const uint8_t* mediaInReadOnly = nullptr;
+        const uint8_t* overallSubsystemDegraded = nullptr;
+        const uint8_t* powerBackupFailed = nullptr;
+        const uint8_t* spareCapacityWornOut = nullptr;
+        const bool success = sdbusplus::unpackPropertiesNoThrow(
+            dbus_utils::UnpackErrorPrinter(), propertiesList, "rdOnly",
+            mediaInReadOnly, "reliabDegraded", overallSubsystemDegraded,
+            "volaMemBkFail", powerBackupFailed, "ccsSpare",
+            spareCapacityWornOut);
+        if (!success)
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+        if (mediaInReadOnly != nullptr)
+        {
+            if (*mediaInReadOnly == 0)
+            {
+                asyncResp->res.jsonValue["NVMeControllerProperties"]
+                                        ["NVMeSMARTCriticalWarnings"]
+                                        ["MediaInReadOnly"] = false;
+            }
+            else
+            {
+                asyncResp->res.jsonValue["NVMeControllerProperties"]
+                                        ["NVMeSMARTCriticalWarnings"]
+                                        ["MediaInReadOnly"] = true;
+            }
+        }
+        if (overallSubsystemDegraded != nullptr)
+        {
+            if (*overallSubsystemDegraded == 0)
+            {
+                asyncResp->res.jsonValue["NVMeControllerProperties"]
+                                        ["NVMeSMARTCriticalWarnings"]
+                                        ["OverallSubsystemDegraded"] = false;
+            }
+            else
+            {
+                asyncResp->res.jsonValue["NVMeControllerProperties"]
+                                        ["NVMeSMARTCriticalWarnings"]
+                                        ["OverallSubsystemDegraded"] = true;
+            }
+        }
+        if (powerBackupFailed != nullptr)
+        {
+            if (*powerBackupFailed == 0)
+            {
+                asyncResp->res.jsonValue["NVMeControllerProperties"]
+                                        ["NVMeSMARTCriticalWarnings"]
+                                        ["PowerBackupFailed"] = false;
+            }
+            else
+            {
+                asyncResp->res.jsonValue["NVMeControllerProperties"]
+                                        ["NVMeSMARTCriticalWarnings"]
+                                        ["PowerBackupFailed"] = true;
+            }
+        }
+        if (spareCapacityWornOut != nullptr)
+        {
+            if (*spareCapacityWornOut == 0)
+            {
+                asyncResp->res.jsonValue["NVMeControllerProperties"]
+                                        ["NVMeSMARTCriticalWarnings"]
+                                        ["SpareCapacityWornOut"] = false;
+            }
+            else
+            {
+                asyncResp->res.jsonValue["NVMeControllerProperties"]
+                                        ["NVMeSMARTCriticalWarnings"]
+                                        ["SpareCapacityWornOut"] = true;
+            }
+        }
+    });
+}
+
+inline void getSubSystemHealthStatus(
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+    const std::string& connectionName, const std::string& path,
+    const std::string& interface)
+{
+    sdbusplus::asio::getAllProperties(
+        *crow::connections::systemBus, connectionName, path, interface,
+        [asyncResp](const boost::system::error_code& ec,
+                    const std::vector<
+                        std::pair<std::string, dbus::utility::DbusVariantType>>&
+                        propertiesList) {
+        if (ec)
+        {
+            // this interface isn't necessary
+            return;
+        }
+        const uint8_t* availableSpare = nullptr;
+        const uint8_t* compositeTemperatureChange = nullptr;
+        const uint8_t* controllerEnableChangeOccured = nullptr;
+        const uint8_t* controllerFatalStatus = nullptr;
+        const uint8_t* controllerStatusChange = nullptr;
+        const uint8_t* criticalWarnings = nullptr;
+        const uint8_t* firmwareActivated = nullptr;
+        const uint8_t* nvmSubSystemResetOccured = nullptr;
+        const uint8_t* nameSpaceAttributeChange = nullptr;
+        const uint8_t* percentageUsed = nullptr;
+        const uint8_t* ready = nullptr;
+        const uint8_t* shutDownStatus = nullptr;
+        const uint8_t* compositeTemperature = nullptr;
+        const uint8_t* driveFunctional = nullptr;
+        const uint8_t* pdlu = nullptr;
+        const uint8_t* port0PCIeLinkActive = nullptr;
+        const uint8_t* port1PCIeLinkActive = nullptr;
+        const uint8_t* resetNotRequired = nullptr;
+        const uint8_t* underThresh = nullptr;
+
+        const bool success = sdbusplus::unpackPropertiesNoThrow(
+            dbus_utils::UnpackErrorPrinter(), propertiesList, "ccsSpare",
+            availableSpare, "ccsCTEMP", compositeTemperatureChange, "ccsCECO",
+            controllerEnableChangeOccured, "ccsCtlFatal", controllerFatalStatus,
+            "ccsCSTS", controllerStatusChange, "critWarn", criticalWarnings,
+            "ccsFA", firmwareActivated, "ccsNSSRO", nvmSubSystemResetOccured,
+            "ccsNAC", nameSpaceAttributeChange, "ccsPDLU", percentageUsed,
+            "ccsReady", ready, "ccsShutdownSt", shutDownStatus, "compTemp",
+            compositeTemperature, "nssDF", driveFunctional, "pdlu", pdlu,
+            "nssP0LA", port0PCIeLinkActive, "nssP1LA", port1PCIeLinkActive,
+            "nssRNR", resetNotRequired, "tempAbUndThresh", underThresh);
+        if (!success)
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+        if (availableSpare != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                                    ["SubSystemHealthStatusPoll"]
+                                    ["CompositeControllerStatus"]
+                                    ["AvailableSpare"] = *availableSpare;
+        }
+        if (compositeTemperatureChange != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                                    ["SubSystemHealthStatusPoll"]
+                                    ["CompositeControllerStatus"]
+                                    ["CompositeTemperatureChange"] =
+                *compositeTemperatureChange;
+        }
+        if (controllerEnableChangeOccured != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                                    ["SubSystemHealthStatusPoll"]
+                                    ["CompositeControllerStatus"]
+                                    ["ControllerEnableChangeOccured"] =
+                *controllerEnableChangeOccured;
+        }
+        if (controllerFatalStatus != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                                    ["SubSystemHealthStatusPoll"]
+                                    ["CompositeControllerStatus"]
+                                    ["ControllerFatalStatus"] =
+                *controllerFatalStatus;
+        }
+        if (controllerStatusChange != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                                    ["SubSystemHealthStatusPoll"]
+                                    ["CompositeControllerStatus"]
+                                    ["ControllerStatusChange"] =
+                *controllerStatusChange;
+        }
+        if (criticalWarnings != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                                    ["SubSystemHealthStatusPoll"]
+                                    ["CompositeControllerStatus"]
+                                    ["CriticalWarnings"] = *criticalWarnings;
+        }
+        if (firmwareActivated != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                                    ["SubSystemHealthStatusPoll"]
+                                    ["CompositeControllerStatus"]
+                                    ["FirmwareActivated"] = *firmwareActivated;
+        }
+        if (nvmSubSystemResetOccured != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                                    ["SubSystemHealthStatusPoll"]
+                                    ["CompositeControllerStatus"]
+                                    ["NVMSubSystemResetOccured"] =
+                *nvmSubSystemResetOccured;
+        }
+        if (nameSpaceAttributeChange != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                                    ["SubSystemHealthStatusPoll"]
+                                    ["CompositeControllerStatus"]
+                                    ["NameSpaceAttributeChange"] =
+                *nameSpaceAttributeChange;
+        }
+        if (percentageUsed != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                                    ["SubSystemHealthStatusPoll"]
+                                    ["CompositeControllerStatus"]
+                                    ["PercentageUsed"] = *percentageUsed;
+        }
+        if (ready != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                                    ["SubSystemHealthStatusPoll"]
+                                    ["CompositeControllerStatus"]["Ready"] =
+                *ready;
+        }
+        if (shutDownStatus != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                                    ["SubSystemHealthStatusPoll"]
+                                    ["CompositeControllerStatus"]
+                                    ["ShutDownStatus"] = *shutDownStatus;
+        }
+        if (compositeTemperature != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                                    ["SubSystemHealthStatusPoll"]
+                                    ["CompositeTemperature"] =
+                *compositeTemperature;
+        }
+        if (driveFunctional != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                                    ["SubSystemHealthStatusPoll"]
+                                    ["DriveFunctional"] = *driveFunctional;
+        }
+        if (pdlu != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                                    ["SubSystemHealthStatusPoll"]["PDLU"] =
+                *pdlu;
+        }
+        if (port0PCIeLinkActive != nullptr)
+        {
+            asyncResp->res
+                .jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                          ["SubSystemHealthStatusPoll"]["Port0PCIeLinkActive"] =
+                *port0PCIeLinkActive;
+        }
+        if (port1PCIeLinkActive != nullptr)
+        {
+            asyncResp->res
+                .jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                          ["SubSystemHealthStatusPoll"]["Port1PCIeLinkActive"] =
+                *port1PCIeLinkActive;
+        }
+        if (resetNotRequired != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                                    ["SubSystemHealthStatusPoll"]
+                                    ["ResetNotRequired"] = *resetNotRequired;
+        }
+        if (underThresh != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                                    ["SubSystemHealthStatusPoll"]
+                                    ["SmartWarnings"]["UnderThresh"] =
+                *underThresh;
+        }
+    });
+}
+
+inline void getVPDNVMeMultiRecordInfo(
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+    const std::string& connectionName, const std::string& path,
+    const std::string& interface)
+{
+    sdbusplus::asio::getAllProperties(
+        *crow::connections::systemBus, connectionName, path, interface,
+        [asyncResp](const boost::system::error_code& ec,
+                    const std::vector<
+                        std::pair<std::string, dbus::utility::DbusVariantType>>&
+                        propertiesList) {
+        if (ec)
+        {
+            // this interface isn't necessary
+            return;
+        }
+        const uint8_t* eptFactor = nullptr;
+        const uint8_t* initialPowerSupplyReq18v = nullptr;
+        const uint8_t* initialPowerSupplyReq12v = nullptr;
+        const uint8_t* initialPowerSupplyReq33v = nullptr;
+        const uint8_t* initialPowerSupplyReq5v = nullptr;
+        const uint8_t* maxAuxPowerSupplyReq33v = nullptr;
+        const uint8_t* maxPowerSupplyReq18v = nullptr;
+        const uint8_t* maxPowerSupplyReq12v = nullptr;
+        const uint8_t* maxPowerSupplyReq33v = nullptr;
+        const uint8_t* maxPowerSupplyReq5v = nullptr;
+        const uint8_t* maxThermalLoad = nullptr;
+        const uint8_t* recordAreaVersion = nullptr;
+        //      const std::vector<uint8_t*> totalNVMCapacity = nullptr;
+
+        const bool success = sdbusplus::unpackPropertiesNoThrow(
+            dbus_utils::UnpackErrorPrinter(), propertiesList,
+            "mgmtEptFormFactor", eptFactor, "initPwrSupReq1_8V",
+            initialPowerSupplyReq18v, "initPwrSupReq12V",
+            initialPowerSupplyReq12v, "initPwrSupReq3_3V",
+            initialPowerSupplyReq33v, "initPwrSupReq5V",
+            initialPowerSupplyReq5v, "maxAuxPwrSupReq3_3V",
+            maxAuxPowerSupplyReq33v, "maxPwrSupReq1_8V", maxPowerSupplyReq18v,
+            "maxPwrSupReq12V", maxPowerSupplyReq12v, "maxPwrSupReq3_3V",
+            maxPowerSupplyReq33v, "maxPwrSupReq5V", maxPowerSupplyReq5v,
+            "maxThermLoad", maxThermalLoad, "nvmeRecAreaVer",
+            recordAreaVersion);
+        //        "totNvmCap", totalNVMCapacity);
+        if (!success)
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+        asyncResp->res
+            .jsonValue["Oem"]["Ami"]["VitalProductData"]["@odata.type"] =
+            "#OemAMINVMeMIController.VitalProductData";
+        if (eptFactor != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["VitalProductData"]
+                                    ["MultiRecordInformation"]
+                                    ["NVMeMultiRecord"]["EPTFactor"] =
+                *eptFactor;
+        }
+        if (initialPowerSupplyReq18v != nullptr)
+        {
+            asyncResp->res
+                .jsonValue["Oem"]["Ami"]["VitalProductData"]
+                          ["MultiRecordInformation"]["NVMeMultiRecord"]
+                          ["InitialPowerSupplyReq1.8v"] =
+                *initialPowerSupplyReq18v;
+        }
+        if (initialPowerSupplyReq12v != nullptr)
+        {
+            asyncResp->res
+                .jsonValue["Oem"]["Ami"]["VitalProductData"]
+                          ["MultiRecordInformation"]["NVMeMultiRecord"]
+                          ["InitialPowerSupplyReq12v"] =
+                *initialPowerSupplyReq12v;
+        }
+        if (initialPowerSupplyReq33v != nullptr)
+        {
+            asyncResp->res
+                .jsonValue["Oem"]["Ami"]["VitalProductData"]
+                          ["MultiRecordInformation"]["NVMeMultiRecord"]
+                          ["InitialPowerSupplyReq3.3v"] =
+                *initialPowerSupplyReq33v;
+        }
+        if (initialPowerSupplyReq5v != nullptr)
+        {
+            asyncResp->res
+                .jsonValue["Oem"]["Ami"]["VitalProductData"]
+                          ["MultiRecordInformation"]["NVMeMultiRecord"]
+                          ["InitialPowerSupplyReq5v"] =
+                *initialPowerSupplyReq5v;
+        }
+        if (maxAuxPowerSupplyReq33v != nullptr)
+        {
+            asyncResp->res
+                .jsonValue["Oem"]["Ami"]["VitalProductData"]
+                          ["MultiRecordInformation"]["NVMeMultiRecord"]
+                          ["MaxAuxPowerSupplyReq3.3v"] =
+                *maxAuxPowerSupplyReq33v;
+        }
+        if (maxPowerSupplyReq18v != nullptr)
+        {
+            asyncResp->res
+                .jsonValue["Oem"]["Ami"]["VitalProductData"]
+                          ["MultiRecordInformation"]["NVMeMultiRecord"]
+                          ["MaxPowerSupplyReq1.8v"] = *maxPowerSupplyReq18v;
+        }
+        if (maxPowerSupplyReq12v != nullptr)
+        {
+            asyncResp->res
+                .jsonValue["Oem"]["Ami"]["VitalProductData"]
+                          ["MultiRecordInformation"]["NVMeMultiRecord"]
+                          ["MaxPowerSupplyReq12v"] = *maxPowerSupplyReq12v;
+        }
+        if (maxPowerSupplyReq33v != nullptr)
+        {
+            asyncResp->res
+                .jsonValue["Oem"]["Ami"]["VitalProductData"]
+                          ["MultiRecordInformation"]["NVMeMultiRecord"]
+                          ["MaxPowerSupplyReq3.3v"] = *maxPowerSupplyReq33v;
+        }
+        if (maxPowerSupplyReq5v != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["VitalProductData"]
+                                    ["MultiRecordInformation"]
+                                    ["NVMeMultiRecord"]["MaxPowerSupplyReq5v"] =
+                *maxPowerSupplyReq5v;
+        }
+        if (maxThermalLoad != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["VitalProductData"]
+                                    ["MultiRecordInformation"]
+                                    ["NVMeMultiRecord"]["MaxThermalLoad"] =
+                *maxThermalLoad;
+        }
+        if (recordAreaVersion != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["VitalProductData"]
+                                    ["MultiRecordInformation"]
+                                    ["NVMeMultiRecord"]["RecordAreaVersion"] =
+                *recordAreaVersion;
+        }
+        // if (totalNVMCapacity != nullptr)
+        // {
+        //     asyncResp->res.jsonValue["Oem"]["Ami"]["VitalProductData"]
+        //                     ["MultiRecordInformation"]["NVMeMultiRecord"]
+        //                     ["TotalNVMCapacity"] = *totalNVMCapacity;
+        // }
+    });
+}
+
+inline void getVPDNVMePCIePortRecord(
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+    const std::string& connectionName, const std::string& path,
+    const std::string& interface)
+{
+    sdbusplus::asio::getAllProperties(
+        *crow::connections::systemBus, connectionName, path, interface,
+        [asyncResp](const boost::system::error_code& ec,
+                    const std::vector<
+                        std::pair<std::string, dbus::utility::DbusVariantType>>&
+                        propertiesList) {
+        if (ec)
+        {
+            // this interface isn't necessary
+            return;
+        }
+        const uint8_t* mctpSupport = nullptr;
+        const uint8_t* pcieMaximumLinkWidth = nullptr;
+        const uint8_t* pciePortInformation = nullptr;
+        const uint8_t* pciePortNumber = nullptr;
+        const uint8_t* pcieRecordVersion = nullptr;
+        const uint8_t* pcieSupportedlinkSpeeds = nullptr;
+        const uint8_t* refClockCapability = nullptr;
+
+        const bool success = sdbusplus::unpackPropertiesNoThrow(
+            dbus_utils::UnpackErrorPrinter(), propertiesList, "mctpSup",
+            mctpSupport, "pcieMaxLnkWidth", pcieMaximumLinkWidth, "portInfo",
+            pciePortInformation, "pciePortNum", pciePortNumber, "recFmtVer",
+            pcieRecordVersion, "pcieLnkSpd", pcieSupportedlinkSpeeds,
+            "refClkCap", refClockCapability);
+        if (!success)
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+        if (mctpSupport != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["VitalProductData"]
+                                    ["MultiRecordInformation"]
+                                    ["NVMePCIePortMultiRecord"]["MctpSupport"] =
+                *mctpSupport;
+        }
+        if (pcieMaximumLinkWidth != nullptr)
+        {
+            if (linkWidth.find(*pcieMaximumLinkWidth) != linkWidth.end())
+            {
+                asyncResp->res.jsonValue["Oem"]["Ami"]["VitalProductData"]
+                                        ["MultiRecordInformation"]
+                                        ["NVMePCIePortMultiRecord"]
+                                        ["PCIeMaximumLinkWidth"] =
+                    linkWidth.find(*pcieMaximumLinkWidth)->second;
+            }
+        }
+        if (pciePortInformation != nullptr)
+        {
+            asyncResp->res
+                .jsonValue["Oem"]["Ami"]["VitalProductData"]
+                          ["MultiRecordInformation"]["NVMePCIePortMultiRecord"]
+                          ["PCIePortInformation"] = *pciePortInformation;
+        }
+        if (pciePortNumber != nullptr)
+        {
+            asyncResp->res
+                .jsonValue["Oem"]["Ami"]["VitalProductData"]
+                          ["MultiRecordInformation"]["NVMePCIePortMultiRecord"]
+                          ["PCIePortNumber"] = *pciePortNumber;
+        }
+        if (pcieRecordVersion != nullptr)
+        {
+            asyncResp->res
+                .jsonValue["Oem"]["Ami"]["VitalProductData"]
+                          ["MultiRecordInformation"]["NVMePCIePortMultiRecord"]
+                          ["PCIeRecordVersion"] = *pcieRecordVersion;
+        }
+        if (pcieSupportedlinkSpeeds != nullptr)
+        {
+            if (linkSpeed.find(*pcieSupportedlinkSpeeds) != linkSpeed.end())
+            {
+                asyncResp->res.jsonValue["Oem"]["Ami"]["VitalProductData"]
+                                        ["MultiRecordInformation"]
+                                        ["NVMePCIePortMultiRecord"]
+                                        ["PCIeSupportedlinkSpeeds"] =
+                    linkSpeed.find(*pcieSupportedlinkSpeeds)->second;
+            }
+            else
+            {
+                asyncResp->res.jsonValue["Oem"]["Ami"]["VitalProductData"]
+                                        ["MultiRecordInformation"]
+                                        ["NVMePCIePortMultiRecord"]
+                                        ["PCIeSupportedlinkSpeeds"] =
+                    "Not Supported";
+            }
+        }
+        if (refClockCapability != nullptr)
+        {
+            if (refClock.find(*refClockCapability) != refClock.end())
+            {
+                asyncResp->res.jsonValue["Oem"]["Ami"]["VitalProductData"]
+                                        ["MultiRecordInformation"]
+                                        ["NVMePCIePortMultiRecord"]
+                                        ["RefClockCapability"] =
+                    refClock.find(*refClockCapability)->second;
+            }
+        }
+    });
+}
+
+inline void
+    getIdenNameSpaceList(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                         const std::string& connectionName,
+                         const std::string& path, const std::string& interface)
+{
+    crow::connections::systemBus->async_method_call(
+        [asyncResp](
+            const boost::system::error_code ec2,
+            const std::vector<std::pair<std::string, std::variant<uint32_t>>>&
+                propertiesList) {
+        if (ec2)
+        {
+            return;
+        }
+        for (const std::pair<std::string, std::variant<uint32_t>>& property :
+             propertiesList)
+        {
+            const std::string& propertyName = property.first;
+            if ((propertyName == "NameSpaceListNo0") ||
+                (propertyName == "NameSpaceListNo1"))
+            {
+                const uint32_t* value = std::get_if<uint32_t>(&property.second);
+                if (value != nullptr)
+                {
+                    asyncResp->res.jsonValue["Oem"]["Ami"]["IdenNameSpaceList"]
+                                            [propertyName] = *value;
+                }
+            }
+        }
+    },
+        connectionName, path, "org.freedesktop.DBus.Properties", "GetAll",
+        interface);
+}
+
+inline void getIdenNameSpaceDataStruct(
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+    const std::string& connectionName, const std::string& path,
+    const std::string& interface)
+{
+    crow::connections::systemBus->async_method_call(
+        [asyncResp](
+            const boost::system::error_code ec2,
+            const std::vector<std::pair<std::string, std::variant<uint32_t>>>&
+                propertiesList) {
+        if (ec2)
+        {
+            return;
+        }
+        for (const std::pair<std::string, std::variant<uint32_t>>& property :
+             propertiesList)
+        {
+            const std::string& propertyName = property.first;
+            if ((propertyName == "NamespaceSize") ||
+                (propertyName == "NamespaceCapacity") ||
+                (propertyName == "NamespaceUtilization"))
+            {
+                const uint32_t* value = std::get_if<uint32_t>(&property.second);
+                if (value != nullptr)
+                {
+                    asyncResp->res
+                        .jsonValue["Oem"]["Ami"]["IdenNameSpaceDataStruct"]
+                                  [propertyName] = *value;
+                }
+            }
+        }
+    },
+        connectionName, path, "org.freedesktop.DBus.Properties", "GetAll",
+        interface);
+}
+
+inline void
+    getIdenNameSpaceLBAFmts(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                            const std::string& connectionName,
+                            const std::string& path,
+                            const std::string& interface)
+{
+    crow::connections::systemBus->async_method_call(
+        [asyncResp](
+            const boost::system::error_code ec2,
+            const std::vector<
+                std::pair<std::string, std::variant<bool, uint8_t, int32_t>>>&
+                propertiesList) {
+        if (ec2)
+        {
+            return;
+        }
+        for (const std::pair<std::string, std::variant<bool, uint8_t, int32_t>>&
+                 property : propertiesList)
+        {
+            const std::string& propertyName = property.first;
+            if ((propertyName == "MetadataSizeofLBAFmtsNo0") ||
+                (propertyName == "MetadataSizeofLBAFmtsNo1"))
+            {
+                const int32_t* value = std::get_if<int32_t>(&property.second);
+                if (value != nullptr)
+                {
+                    asyncResp->res
+                        .jsonValue["Oem"]["Ami"]["IdenNameSpaceLBAFmts"]
+                                  [propertyName] = *value;
+                }
+            }
+            if ((propertyName == "LBAdataSizeofLBAFmtsNo0") ||
+                (propertyName == "LBAdataSizeofLBAFmtsNo1") ||
+                (propertyName == "RelativePerformofLBAFmtsNo0") ||
+                (propertyName == "RelativePerformofLBAFmtsNo1"))
+            {
+                const uint8_t* value = std::get_if<uint8_t>(&property.second);
+                if (value != nullptr)
+                {
+                    asyncResp->res
+                        .jsonValue["Oem"]["Ami"]["IdenNameSpaceLBAFmts"]
+                                  [propertyName] = *value;
+                }
+            }
+        }
+    },
+        connectionName, path, "org.freedesktop.DBus.Properties", "GetAll",
+        interface);
+}
+
+inline void getIdenPwrStDes(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                            const std::string& connectionName,
+                            const std::string& path,
+                            const std::string& interface)
+{
+    crow::connections::systemBus->async_method_call(
+        [asyncResp](const boost::system::error_code ec2,
+                    const std::vector<
+                        std::pair<std::string, std::variant<int32_t, double>>>&
+                        propertiesList) {
+        if (ec2)
+        {
+            return;
+        }
+        for (const std::pair<std::string, std::variant<int32_t, double>>&
+                 property : propertiesList)
+        {
+            const std::string& propertyName = property.first;
+            if ((propertyName == "MaxPowerStateNo0") ||
+                (propertyName == "MaxPowerStateNo1"))
+            {
+                const int32_t* value = std::get_if<int32_t>(&property.second);
+                if (value != nullptr)
+                {
+                    asyncResp->res.jsonValue["Oem"]["Ami"]["IdenPwrStDes"]
+                                            [propertyName] = *value;
+                }
+            }
+            if ((propertyName == "MaxPowerScaleNo0") ||
+                (propertyName == "MaxPowerScaleNo1"))
+            {
+                const double* value = std::get_if<double>(&property.second);
+                if (value != nullptr)
+                {
+                    asyncResp->res.jsonValue["Oem"]["Ami"]["IdenPwrStDes"]
+                                            [propertyName] = *value;
+                }
+            }
+        }
+    },
+        connectionName, path, "org.freedesktop.DBus.Properties", "GetAll",
+        interface);
+}
+inline void requestRoutesNvmeControllersInstance(App& app)
+{
+    BMCWEB_ROUTE(app,
+                 "/redfish/v1/Systems/system/Storage/Nvme/Controllers/<str>/")
+        .privileges(redfish::privileges::getStorage)
+        .methods(boost::beast::http::verb::get)(
+            [](const crow::Request&,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& controllerId) {
+        constexpr std::array<std::string_view, 1> interfaces = {
+            nvmeInterfaceName};
+        dbus::utility::getSubTree(
+            nvmeObjPath, 0, interfaces,
+            [asyncResp, controllerId](
+                const boost::system::error_code& ec,
+                const dbus::utility::MapperGetSubTreeResponse& subtree) {
+            if (ec)
+            {
+                BMCWEB_LOG_ERROR("Controller mapper call error");
+                messages::internalError(asyncResp->res);
+                return;
+            }
+
+            auto controller = std::find_if(
+                subtree.begin(), subtree.end(),
+                [&controllerId](
+                    const std::pair<std::string,
+                                    dbus::utility::MapperServiceMap>& object) {
+                return sdbusplus::message::object_path(object.first)
+                           .filename() == controllerId;
+            });
+
+            if (controller == subtree.end())
+            {
+                messages::resourceNotFound(asyncResp->res, "controller",
+                                           controllerId);
+                return;
+            }
+
+            const std::string& path = controller->first;
+            const dbus::utility::MapperServiceMap& connectionNames =
+                controller->second;
+
+            asyncResp->res.jsonValue["@odata.type"] =
+                "#StorageController.v1_6_0.StorageController";
+            asyncResp->res.jsonValue["@odata.id"] = boost::urls::format(
+                "/redfish/v1/Systems/system/Storage/Nvme/Controllers/{}",
+                controllerId);
+            asyncResp->res.jsonValue["Name"] = "NVME controller";
+            asyncResp->res.jsonValue["Id"] = controllerId;
+            asyncResp->res.jsonValue["Oem"]["@odata.type"] =
+                "#OemAMINVMeMIController.Oem";
+            asyncResp->res.jsonValue["Oem"]["Ami"]["@odata.type"] =
+                "#OemAMINVMeMIController.Ami";
+            asyncResp->res
+                .jsonValue["Ports"]["@odata.id"] = boost::urls::format(
+                "/redfish/v1/Systems/system/Storage/Nvme/Controllers/{}/Ports",
+                controllerId);
+
+            if (connectionNames.size() != 1)
+            {
+                BMCWEB_LOG_ERROR("Connection size ", connectionNames.size(),
+                                 "not equal to 1");
+                messages::internalError(asyncResp->res);
+                return;
+            }
+
+            /*getMainChassisId(
+                asyncResp,
+                [](const std::string& chassisId,
+                const std::shared_ptr<bmcweb::AsyncResp>& aRsp) {
+                aRsp->res.jsonValue["Links"]["Chassis"]["@odata.id"] =
+                    boost::urls::format("/redfish/v1/Chassis/{}", chassisId);
+                });*/
+
+            // default it to Enabled
+            asyncResp->res.jsonValue["Status"]["State"] = "Enabled";
+
+            auto health = std::make_shared<HealthPopulate>(asyncResp);
+            health->inventory.emplace_back(path);
+            health->populate();
+
+            for (const std::string& interface : connectionNames[0].second)
+            {
+                if (interface == "xyz.openbmc_project.Common.VPDProductInfo")
+                {
+                    getControllerAsset(asyncResp, connectionNames[0].first,
+                                       path, interface);
+                }
+                else if (interface == "xyz.openbmc_project.Common.SubInfoData")
+                {
+                    getSubSystemInfo(asyncResp, connectionNames[0].first, path,
+                                     interface);
+                }
+                else if (
+                    interface ==
+                    "xyz.openbmc_project.Common.SubsysHealthStatusPoll_Flag0")
+                {
+                    getSubSystemHealthStatus(
+                        asyncResp, connectionNames[0].first, path, interface);
+                    getNVMeControllerProperties(
+                        asyncResp, connectionNames[0].first, path, interface);
+                }
+                else if (interface == "xyz.openbmc_project.Common.VPDNvmeRec")
+                {
+                    getVPDNVMeMultiRecordInfo(
+                        asyncResp, connectionNames[0].first, path, interface);
+                }
+                else if (interface ==
+                         "xyz.openbmc_project.Common.VPDPciePortRec")
+                {
+                    getVPDNVMePCIePortRecord(
+                        asyncResp, connectionNames[0].first, path, interface);
+                }
+                else if (interface ==
+                         "xyz.openbmc_project.Common.IdenNameSpaceList")
+                {
+                    getIdenNameSpaceList(asyncResp, connectionNames[0].first,
+                                         path, interface);
+                }
+                else if (interface ==
+                         "xyz.openbmc_project.Common.IdenNamespaceDataStruct")
+                {
+                    getIdenNameSpaceDataStruct(
+                        asyncResp, connectionNames[0].first, path, interface);
+                }
+                else if (interface ==
+                         "xyz.openbmc_project.Common.IdenNamespaceLBAFmts")
+                {
+                    getIdenNameSpaceLBAFmts(asyncResp, connectionNames[0].first,
+                                            path, interface);
+                }
+                else if (interface == "xyz.openbmc_project.Common.IdenPwrStDes")
+                {
+                    getIdenPwrStDes(asyncResp, connectionNames[0].first, path,
+                                    interface);
+                }
+            }
+        });
+    });
+}
+
+inline void getNvmePorts(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                         const std::string& path)
+{
+    nlohmann::json& controllerArray = asyncResp->res.jsonValue["Members"];
+    controllerArray = nlohmann::json::array();
+    nlohmann::json& count = asyncResp->res.jsonValue["Members@odata.count"];
+    count = 0;
+
+    sdbusplus::asio::getProperty<uint8_t>(
+        *crow::connections::systemBus, nvmeServiceName, path,
+        "xyz.openbmc_project.Common.SubInfoData", "numOfPorts",
+        [asyncResp, &controllerArray,
+         &count](const boost::system::error_code& ec, const uint8_t ports) {
+        if (ec)
+        {
+            return;
+        }
+        for (int var = 0; var < ports; var++)
+        {
+            nlohmann::json::object_t controllerJson;
+            const std::string str =
+                "/redfish/v1/Systems/system/Storage/Nvme/Controllers/0/Ports/" +
+                std::to_string(var);
+            controllerJson["@odata.id"] = str;
+            controllerArray.push_back(std::move(controllerJson));
+        }
+        count = controllerArray.size();
+    });
+}
+
+inline void requestRoutesNvmePorts(App& app)
+{
+    BMCWEB_ROUTE(
+        app, "/redfish/v1/Systems/system/Storage/Nvme/Controllers/<str>/Ports")
+        .privileges(redfish::privileges::getStorage)
+        .methods(boost::beast::http::verb::get)(
+            [](const crow::Request&,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& controllerId) {
+        constexpr std::array<std::string_view, 1> interfaces = {
+            nvmeInterfaceName};
+        dbus::utility::getSubTree(
+            nvmeObjPath, 0, interfaces,
+            [asyncResp, controllerId](
+                const boost::system::error_code& ec,
+                const dbus::utility::MapperGetSubTreeResponse& subtree) {
+            if (ec)
+            {
+                BMCWEB_LOG_ERROR("Controller mapper call error");
+                messages::internalError(asyncResp->res);
+                return;
+            }
+
+            auto controller = std::find_if(
+                subtree.begin(), subtree.end(),
+                [&controllerId](
+                    const std::pair<std::string,
+                                    dbus::utility::MapperServiceMap>& object) {
+                return sdbusplus::message::object_path(object.first)
+                           .filename() == controllerId;
+            });
+            if (controller == subtree.end())
+            {
+                messages::resourceNotFound(asyncResp->res, "controller",
+                                           controllerId);
+                return;
+            }
+            const std::string& path = controller->first;
+            asyncResp->res.jsonValue["@odata.type"] =
+                "#PortCollection.PortCollection";
+            asyncResp->res.jsonValue["@odata.id"] =
+                "/redfish/v1/Systems/system/Storage/Nvme/Controllers/" +
+                controllerId + "/Ports";
+            asyncResp->res.jsonValue["Name"] = "Port Collections";
+            asyncResp->res.jsonValue["Description"] =
+                "The Collections of Ports";
+            getNvmePorts(asyncResp, path);
+        });
+    });
+}
+
+inline void getInactiveInfo(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
+{
+    asyncResp->res.jsonValue["Name"] = "Inactive";
+    asyncResp->res.jsonValue["Oem"]["Ami"]["PortInformation"]["PortStatus"] =
+        "Inactive";
+    asyncResp->res.jsonValue["Oem"]["Ami"]["PortInformation"]["PortType"] =
+        "N/A";
+}
+
+inline void getPCIeInfo(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                        const std::string& interface, const std::string& path)
+{
+    asyncResp->res.jsonValue["Name"] = "PCIe";
+    asyncResp->res.jsonValue["Oem"]["Ami"]["PortInformation"]["PortStatus"] =
+        "Active";
+    asyncResp->res.jsonValue["Oem"]["Ami"]["PortInformation"]["PortType"] =
+        "PCIe";
+    sdbusplus::asio::getAllProperties(
+        *crow::connections::systemBus, nvmeServiceName, path, interface,
+        [asyncResp](const boost::system::error_code& ec,
+                    const std::vector<
+                        std::pair<std::string, dbus::utility::DbusVariantType>>&
+                        propertiesList) {
+        if (ec)
+        {
+            // this interface isn't necessary
+            return;
+        }
+        const int32_t* maxMCTPTransUnitSize = nullptr;
+        const uint8_t* currentLinkSpeed = nullptr;
+        const uint8_t* supportedLinkSpeeds = nullptr;
+        const uint8_t* maxPayloadSize = nullptr;
+        const uint8_t* maxLinkWidth = nullptr;
+        const uint8_t* negotiatedLinkWidth = nullptr;
+
+        const bool success = sdbusplus::unpackPropertiesNoThrow(
+            dbus_utils::UnpackErrorPrinter(), propertiesList, "maxPayloadSize",
+            maxPayloadSize, "maxMCTPTranUnitSize", maxMCTPTransUnitSize,
+            "maxLinkWidth", maxLinkWidth, "negLinkWidth", negotiatedLinkWidth,
+            "supLinkSpeedVector", supportedLinkSpeeds, "curLinkSpeed",
+            currentLinkSpeed);
+
+        if (!success)
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+        if (maxMCTPTransUnitSize != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["PortInformation"]
+                                    ["MaxMCTPTransUnitSize"] =
+                *maxMCTPTransUnitSize;
+        }
+        if (maxPayloadSize != nullptr)
+        {
+            if (payloadSize.find(*maxPayloadSize) != payloadSize.end())
+            {
+                asyncResp->res.jsonValue["Oem"]["Ami"]["PortInformation"]
+                                        ["MaxPayloadSize"] =
+                    payloadSize.find(*maxPayloadSize)->second;
+            }
+        }
+        if (maxLinkWidth != nullptr)
+        {
+            if (linkWidth.find(*maxLinkWidth) != linkWidth.end())
+            {
+                asyncResp->res.jsonValue["Oem"]["Ami"]["PortInformation"]
+                                        ["MaxLinkWidth"] =
+                    linkWidth.find(*maxLinkWidth)->second;
+            }
+        }
+        if (negotiatedLinkWidth != nullptr)
+        {
+            if (linkWidth.find(*negotiatedLinkWidth) != linkWidth.end())
+            {
+                asyncResp->res.jsonValue["Oem"]["Ami"]["PortInformation"]
+                                        ["NegotiatedLinkWidth"] =
+                    linkWidth.find(*negotiatedLinkWidth)->second;
+            }
+        }
+        if (supportedLinkSpeeds != nullptr)
+        {
+            if (linkSpeed.find(*supportedLinkSpeeds) != linkSpeed.end())
+            {
+                asyncResp->res.jsonValue["Oem"]["Ami"]["PortInformation"]
+                                        ["SupportedLinkSpeeds"] =
+                    linkSpeed.find(*supportedLinkSpeeds)->second;
+            }
+            else
+            {
+                asyncResp->res.jsonValue["Oem"]["Ami"]["PortInformation"]
+                                        ["SupportedLinkSpeeds"] =
+                    "Not supported";
+            }
+        }
+        if (currentLinkSpeed != nullptr)
+        {
+            if (curtLinkSpeed.find(*currentLinkSpeed) != curtLinkSpeed.end())
+            {
+                asyncResp->res.jsonValue["Oem"]["Ami"]["PortInformation"]
+                                        ["CurrentLinkSpeed"] =
+                    curtLinkSpeed.find(*currentLinkSpeed)->second;
+            }
+            else
+            {
+                asyncResp->res.jsonValue["Oem"]["Ami"]["PortInformation"]
+                                        ["CurrentLinkSpeed"] = "Not Supported";
+            }
+        }
+    });
+}
+
+inline void requestRoutesNvmePortsInstance(App& app)
+{
+    BMCWEB_ROUTE(
+        app,
+        "/redfish/v1/Systems/system/Storage/Nvme/Controllers/<str>/Ports/<str>")
+        .privileges(redfish::privileges::getStorage)
+        .methods(boost::beast::http::verb::get)(
+            [](const crow::Request&,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& controllerId, const std::string& portId) {
+        constexpr std::array<std::string_view, 1> interfaces = {
+            nvmeInterfaceName};
+        dbus::utility::getSubTree(
+            nvmeObjPath, 0, interfaces,
+            [asyncResp, portId, controllerId](
+                const boost::system::error_code& ec,
+                const dbus::utility::MapperGetSubTreeResponse& subtree) {
+            if (ec)
+            {
+                BMCWEB_LOG_ERROR("Controller mapper call error");
+                messages::internalError(asyncResp->res);
+                return;
+            }
+
+            auto controller = std::find_if(
+                subtree.begin(), subtree.end(),
+                [&controllerId](
+                    const std::pair<std::string,
+                                    dbus::utility::MapperServiceMap>& object) {
+                return sdbusplus::message::object_path(object.first)
+                           .filename() == controllerId;
+            });
+            if (controller == subtree.end())
+            {
+                messages::resourceNotFound(asyncResp->res, "controller",
+                                           controllerId);
+                return;
+            }
+            const std::string& path = controller->first;
+            asyncResp->res.jsonValue["@odata.type"] = "#Port.v1_3_0.Port";
+            asyncResp->res.jsonValue["@odata.id"] =
+                "/redfish/v1/Systems/system/Storage/Nvme/Controllers/" +
+                controllerId + "/Ports/" + portId;
+            asyncResp->res.jsonValue["Id"] = portId;
+            const std::string interface =
+                "xyz.openbmc_project.Common.PortInfoData_Port" + portId;
+
+            sdbusplus::asio::getProperty<uint8_t>(
+                *crow::connections::systemBus, nvmeServiceName, path, interface,
+                "portType",
+                [asyncResp, interface, portId,
+                 path](const boost::system::error_code& ec2, uint8_t type) {
+                if (ec2)
+                {
+                    return;
+                }
+                asyncResp->res.jsonValue["Oem"]["Ami"]["@odata.type"] =
+                    "#AMINVMeMIPort.Ami";
+                asyncResp->res
+                    .jsonValue["Oem"]["Ami"]["PortInformation"]["@odata.type"] =
+                    "#AMINVMeMIPort.PortInformation";
+                asyncResp->res.jsonValue["Oem"]["Ami"]["PortInformation"]
+                                        ["PortNo"] = portId;
+                if (type == 0)
+                {
+                    getInactiveInfo(asyncResp);
+                }
+                else if (type == 1)
+                {
+                    getPCIeInfo(asyncResp, interface, path);
+                }
+                else if (type == 2)
+                {
+                    //  getSMBusInfo(asyncResp, interface, path); Still backend
+                    //  support need to add
+                    asyncResp->res.jsonValue["Name"] = "SMBus";
+                    asyncResp->res.jsonValue["Oem"]["Ami"]["PortInformation"]
+                                            ["PortStatus"] = "Active";
+                    asyncResp->res.jsonValue["Oem"]["Ami"]["PortInformation"]
+                                            ["PortType"] = "SMBus";
+                }
+            });
+        });
+    });
+}
+
+inline void requestRoutesNvmeDrive(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/Nvme/Drives/<str>/")
+        .privileges(redfish::privileges::getDrive)
+        .methods(boost::beast::http::verb::get)(
+            [](const crow::Request&,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& driveId) {
+        crow::connections::systemBus->async_method_call(
+            [asyncResp, driveId](const boost::system::error_code ec,
+                                 const GetSubTreeType& subtree) {
+            if (ec)
+            {
+                BMCWEB_LOG_ERROR("Drive mapper call error");
+                messages::internalError(asyncResp->res);
+                return;
+            }
+
+            auto object2 = std::find_if(subtree.begin(), subtree.end(),
+                                        [&driveId](auto& object) {
+                const std::string& path = object.first;
+                return boost::ends_with(path, "/" + driveId);
+            });
+
+            if (object2 == subtree.end())
+            {
+                messages::resourceNotFound(asyncResp->res, "Drive", driveId);
+                return;
+            }
+
+            const std::string& path = object2->first;
+            const std::vector<std::pair<std::string, std::vector<std::string>>>&
+                connectionNames = object2->second;
+            asyncResp->res.jsonValue["@odata.type"] = "#Drive.v1_7_0.Drive";
+            asyncResp->res.jsonValue["@odata.id"] =
+                "/redfish/v1/Systems/system/Storage/Nvme/Drives/" + driveId;
+            asyncResp->res.jsonValue["Name"] = driveId;
+            asyncResp->res.jsonValue["Id"] = driveId;
+            asyncResp->res.jsonValue["Oem"]["OpenBmc"]["@odata.id"] =
+                "/redfish/v1/Systems/system/Storage/Nvme/Drives/0#/Oem/OpenBmc";
+            asyncResp->res.jsonValue["Oem"]["OpenBmc"]["@odata.type"] =
+                "#OemDrive.v1_0_0.Drive";
+
+            if (connectionNames.size() != 1)
+            {
+                BMCWEB_LOG_ERROR("Connection size ", connectionNames.size(),
+                                 "greater than 1");
+                messages::internalError(asyncResp->res);
+                return;
+            }
+
+            getMainChassisId(
+                asyncResp, [](const std::string& chassisId,
+                              const std::shared_ptr<bmcweb::AsyncResp>& aRsp) {
+                aRsp->res.jsonValue["Links"]["Chassis"] = {
+                    {"@odata.id", "/redfish/v1/Chassis/" + chassisId}};
+            });
+
+            const std::string& connectionName = connectionNames[0].first;
+            crow::connections::systemBus->async_method_call(
+                [asyncResp](
+                    const boost::system::error_code ec2,
+                    const std::vector<
+                        std::pair<std::string,
+                                  std::variant<bool, std::string, uint64_t>>>&
+                        propertiesList) {
+                if (ec2)
+                {
+                    // this interface isn't necessary
+                    return;
+                }
+                for (const std::pair<std::string,
+                                     std::variant<bool, std::string, uint64_t>>&
+                         property : propertiesList)
+                {
+                    // Store DBus properties that are also
+                    // Redfish properties with same name and a
+                    // string value
+                    const std::string& propertyName = property.first;
+                    if ((propertyName == "partModel") ||
+                        (propertyName == "prdSerial") ||
+                        (propertyName == "manufacturer") ||
+                        (propertyName == "prdName"))
+                    {
+                        const std::string* value =
+                            std::get_if<std::string>(&property.second);
+                        if (value != nullptr)
+                        {
+                            if (propertyName == "partModel")
+                                asyncResp->res.jsonValue["PartNumber"] = *value;
+
+                            if (propertyName == "prdSerial")
+                                asyncResp->res.jsonValue["SerialNumber"] =
+                                    *value;
+
+                            if (propertyName == "manufacturer")
+                                asyncResp->res.jsonValue["Manufacturer"] =
+                                    *value;
+
+                            if (propertyName == "prdName")
+                                asyncResp->res.jsonValue["Model"] = *value;
+                        }
+                    }
+                }
+            },
+                connectionName, path, "org.freedesktop.DBus.Properties",
+                "GetAll", "xyz.openbmc_project.Common.VPDProductInfo");
+
+            crow::connections::systemBus->async_method_call(
+                [asyncResp](
+                    const boost::system::error_code ec2,
+                    const std::vector<
+                        std::pair<std::string,
+                                  std::variant<bool, std::string, uint64_t>>>&
+                        propertiesList) {
+                if (ec2)
+                {
+                    return;
+                }
+                for (const std::pair<std::string,
+                                     std::variant<bool, std::string, uint64_t>>&
+                         property : propertiesList)
+                {
+                    const std::string& propertyName = property.first;
+                    if ((propertyName == "bootloaderVer") ||
+                        (propertyName == "firmwareVer"))
+                    {
+                        const std::string* value =
+                            std::get_if<std::string>(&property.second);
+                        if (value != nullptr)
+                        {
+                            if (propertyName == "bootloaderVer")
+                                asyncResp->res.jsonValue["Oem"]["OpenBmc"]
+                                                        ["Bootloader_Version"] =
+                                    *value;
+
+                            if (propertyName == "firmwareVer")
+                                asyncResp->res.jsonValue["Oem"]["OpenBmc"]
+                                                        ["Firmware_Version"] =
+                                    *value;
+                        }
+                    }
+                }
+            },
+                connectionName, path, "org.freedesktop.DBus.Properties",
+                "GetAll", "xyz.openbmc_project.Common.IntelSpec");
+
+            crow::connections::systemBus->async_method_call(
+                [asyncResp](const boost::system::error_code ec,
+                            const std::variant<std::string>& value) {
+                if (ec)
+                {
+                    BMCWEB_LOG_DEBUG("failed to get property Value  ", ec);
+                    return;
+                }
+
+                const std::string* s = std::get_if<std::string>(&value);
+                asyncResp->res.jsonValue["Oem"]["OpenBmc"]["DeviceLocation"] =
+                    *s;
+            },
+                connectionName, path, "org.freedesktop.DBus.Properties", "Get",
+                nvmeInterfaceName, "DeviceLocation");
+            /*
+                                                    asyncResp->res
+                                                        .jsonValue["Oem"]["OpenBmc"]
+                                                                  ["Device_Class"]
+               = 2; // Hardcode the value asyncResp->res
+                                                        .jsonValue["Oem"]["OpenBmc"]
+                                                                  ["Device_Sub_Class"]
+               = 8; // Hardcode the value asyncResp->res.jsonValue
+                                                        ["Oem"]["OpenBmc"]
+                                                        ["Device_Programming_Intf"]
+               = 1; // Hardcode the value
+            */
+        },
+            "xyz.openbmc_project.ObjectMapper",
+            "/xyz/openbmc_project/object_mapper",
+            "xyz.openbmc_project.ObjectMapper", "GetSubTree", nvmeObjPath, 0,
+            std::array<const char*, 1>{nvmeInterfaceName});
+    });
+}
+} // namespace redfish
diff --git a/static/redfish/v1/$metadata/index.xml b/static/redfish/v1/$metadata/index.xml
index ef1a9229..a648e79e 100644
--- a/static/redfish/v1/$metadata/index.xml
+++ b/static/redfish/v1/$metadata/index.xml
@@ -3455,4 +3455,14 @@
         <edmx:Include Namespace="AMIWebSession"/>
         <edmx:Include Namespace="AMIWebSession.v1_0_0"/>
     </edmx:Reference>
+    <edmx:Reference Uri="/redfish/v1/schema/OemNvme_v1.xml">
+        <edmx:Include Namespace="OemAMINVMeMIController"/>
+    </edmx:Reference>
+    <edmx:Reference Uri="/redfish/v1/schema/AMINVMeMIPort_v1.xml">
+        <edmx:Include Namespace="AMINVMeMIPort"/>
+    </edmx:Reference>
+    <edmx:Reference Uri="/redfish/v1/schema/OemDrive_v1.xml">
+        <edmx:Include Namespace="OemDrive"/>
+        <edmx:Include Namespace="OemDrive.v1_0_0"/>
+    </edmx:Reference>
 </edmx:Edmx>
diff --git a/static/redfish/v1/JsonSchemas/AMINVMeMIPort/index.json b/static/redfish/v1/JsonSchemas/AMINVMeMIPort/index.json
new file mode 100644
index 00000000..33523591
--- /dev/null
+++ b/static/redfish/v1/JsonSchemas/AMINVMeMIPort/index.json
@@ -0,0 +1,145 @@
+{
+    "$id": "http://redfish.dmtf.org/schemas/v1/AMINVMeMIPort.json",
+    "$schema": "http://redfish.dmtf.org/schemas/v1/redfish-schema-v1.json",
+    "copyright": "Copyright 2014-2019 DMTF. For the full DMTF copyright policy, see http://www.dmtf.org/about/policies/copyright",
+    "definitions": {
+	  "Oem": {
+            "additionalProperties": true,
+            "description": "AMINVMeMIPort Oem properties.",
+            "patternProperties": {
+                "^([a-zA-Z_][a-zA-Z0-9_]*)?@(odata|Redfish|Message)\\.[a-zA-Z_][a-zA-Z0-9_.]+$": {
+                    "description": "This property shall specify a valid odata or Redfish property.",
+                    "type": [
+                        "array",
+                        "boolean",
+                        "number",
+                        "null",
+                        "object",
+                        "string"
+                    ]
+                }
+            },
+            "properties": {
+                "Ami": {
+                    "anyOf": [
+                        {
+                            "$ref": "#/definitions/Ami"
+                        },
+                        {
+                            "type": "null"
+                        }
+                    ]
+                }
+            },
+            "type": "object"
+        }, 
+	"Ami": {
+            "additionalProperties": true,
+            "description": "Oem properties for Ami.",
+            "patternProperties": {
+                "^([a-zA-Z_][a-zA-Z0-9_]*)?@(odata|Redfish|Message)\\.[a-zA-Z_][a-zA-Z0-9_.]+$": {
+                    "description": "This property shall specify a valid odata or Redfish property.",
+                    "type": [
+                        "array",
+                        "boolean",
+                        "number",
+                        "null",
+                        "object",
+                        "string"
+                    ]
+                }
+            },
+            "properties": {
+                "PortInformation": {
+                    "anyOf": [
+                        {
+                            "$ref": "#/definitions/PortInformation"
+                        },
+                        {
+                            "type": "null"
+                        }
+                    ]
+                }
+	        },
+            "type": "object"
+        },
+         "PortInformation": {
+            "additionalProperties": true,
+            "description": "AMI oem PortInformation properties.",
+            "patternProperties": {
+                "^([a-zA-Z_][a-zA-Z0-9_]*)?@(odata|Redfish|Message)\\.[a-zA-Z_][a-zA-Z0-9_.]+$": {
+                    "description": "This property shall specify a valid odata or Redfish property.",
+                    "type": [
+                        "array",
+                        "boolean",
+                        "number",
+                        "null",
+                        "object",
+                        "string"
+                    ]
+                }
+            },
+            "properties": {
+			
+			"CurrentLinkSpeed": 
+			   {
+                    "description": "This field indicates a bit vector of link speeds supported by the PCIe port.",
+                    "longDescription": "This field indicates a bit vector of link speeds supported by the PCIe port.",
+                    "type": "string"
+                },
+			"MaxLinkWidth": 
+			   {
+                    "description": "The maximum PCIe link width for this NVM Subsystem port.",
+                    "longDescription": "This field indicates the maximum PCIe link width for this NVM Subsystem port.",
+                    "type": "string"
+                },
+			"MaxMCTPTransUnitSize": 
+			   {
+                    "description": "The maximum MCTP Transmission Unit size the port is capable of sending and receiving.",
+                    "longDescription": "The maximum MCTP Transmission Unit size the port is capable of sending and receiving.",
+                    "type": "number"
+                },
+			"MaxPayloadSize": 
+			   {
+                    "description": "This field indicates the Max Payload Size for the specified PCIe port.",
+                    "longDescription": "This field indicates the Max Payload Size for the specified PCIe port.",
+                    "type": "string"
+                },
+			"NegotiatedLinkWidth": 
+			   {
+                    "description": "The negotiated PCIe link width for this port.",
+                    "longDescription": "The negotiated PCIe link width for this port.",
+                    "type": "string"
+                },
+			"portNo": 
+			   {
+                    "description": "This field contains the PCIe port number.",
+                    "longDescription": "This field contains the PCIe port number.",
+                    "type": "string"
+                },
+			"PortStatus": 
+			   {
+                    "description": "This field indicates information about the PCIe Ports in the device.",
+                    "longDescription": "This field indicates information about the PCIe Ports in the device.",
+                    "type": "string"
+                },
+			"PortType": 
+			   {
+                    "description": "This fiels indicates port Type.",
+                    "longDescription": "This fiels indicates port Type.",
+                    "type": "string"
+                },
+			"SupportedLinkSpeeds": 
+			   {
+                    "description": "This field indicates a bit vector of link speeds supported by the PCIe port.",
+                    "longDescription": "This field indicates a bit vector of link speeds supported by the PCIe port.",
+                    "type": "string"
+                }   
+            },
+            "type": "object"
+        }
+    },
+    "title": "#AMINVMeMIPort"
+}	
+	
+
diff --git a/static/redfish/v1/JsonSchemas/OemDrive/index.json b/static/redfish/v1/JsonSchemas/OemDrive/index.json
new file mode 100644
index 00000000..a1762d3d
--- /dev/null
+++ b/static/redfish/v1/JsonSchemas/OemDrive/index.json
@@ -0,0 +1,69 @@
+{
+    "$id": "http://redfish.dmtf.org/schemas/v1/OemDrive.v1_0_0.json",
+    "$schema": "http://redfish.dmtf.org/schemas/v1/redfish-schema-v1.json",
+    "copyright": "Copyright 2014-2019 DMTF. For the full DMTF copyright policy, see http://www.dmtf.org/about/policies/copyright",
+    "definitions": {
+        "Drive": {
+            "additionalProperties": false,
+            "description": "OEM Extension for Drive",
+            "longDescription": "OEM Extension for Drive",
+            "patternProperties": {
+                "^([a-zA-Z_][a-zA-Z0-9_]*)?@(odata|Redfish|Message)\\.[a-zA-Z_][a-zA-Z0-9_]*$": {
+                    "description": "This property shall specify a valid odata or Redfish property.",
+                    "type": [
+                        "array",
+                        "boolean",
+                        "integer",
+                        "number",
+                        "null",
+                        "object",
+                        "string"
+                    ]
+                }
+            },
+            "properties": {
+                "ProductID": {
+                    "description": "The model name of the drive.",
+                    "longDescription": "The model name of the drive.",
+                    "readonly": true,
+                    "type": [
+                        "string",
+                        "null"
+                    ]
+                },
+		"SlotNumber": {
+                    "description": "The slot number the drive connected.",
+                    "longDescription": "The slot number the drive connected.",
+                    "readonly": true,
+                    "type": [
+                        "number",
+                        "null"
+                    ]
+                },
+		"DeviceLocation": {
+                    "description": "This indicates device slot number.",
+                    "longDescription": "This indicates device slot number.",
+                    "readonly": true,
+                    "type": [
+                        "string",
+                        "null"
+                    ]
+                },
+		"Firmware_Version": {
+                    "description": "Indicates Frimware version.",
+                    "longDescription": "Indicates Frimware version.",
+                    "readonly": true,
+                    "type": [
+                        "string",
+                        "null"
+                    ]
+                }
+            },
+            "type": "object"
+        }
+    },
+    "owningEntity": "OpenBMC",
+    "release": "1.0",
+    "title": "#OemDrive.v1_0_0"
+}
+
diff --git a/static/redfish/v1/JsonSchemas/OemNvme/index.json b/static/redfish/v1/JsonSchemas/OemNvme/index.json
new file mode 100644
index 00000000..229c9b5e
--- /dev/null
+++ b/static/redfish/v1/JsonSchemas/OemNvme/index.json
@@ -0,0 +1,684 @@
+{
+    "$id": "http://redfish.dmtf.org/schemas/v1/OemNvme.json",
+    "$schema": "http://redfish.dmtf.org/schemas/v1/redfish-schema-v1.json",
+    "copyright": "Copyright 2014-2019 DMTF. For the full DMTF copyright policy, see http://www.dmtf.org/about/policies/copyright",
+    "definitions": {
+	  "Oem": {
+            "additionalProperties": true,
+            "description": "OemAMINVMeMIController Oem properties.",
+            "patternProperties": {
+                "^([a-zA-Z_][a-zA-Z0-9_]*)?@(odata|Redfish|Message)\\.[a-zA-Z_][a-zA-Z0-9_.]+$": {
+                    "description": "This property shall specify a valid odata or Redfish property.",
+                    "type": [
+                        "array",
+                        "boolean",
+                        "number",
+                        "null",
+                        "object",
+                        "string"
+                    ]
+                }
+            },
+            "properties": {
+                "Ami": {
+                    "anyOf": [
+                        {
+                            "$ref": "#/definitions/Ami"
+                        },
+                        {
+                            "type": "null"
+                        }
+                    ]
+                }
+            },
+            "type": "object"
+        }, 
+	"Ami": {
+            "additionalProperties": true,
+            "description": "Oem properties for Ami.",
+            "patternProperties": {
+                "^([a-zA-Z_][a-zA-Z0-9_]*)?@(odata|Redfish|Message)\\.[a-zA-Z_][a-zA-Z0-9_.]+$": {
+                    "description": "This property shall specify a valid odata or Redfish property.",
+                    "type": [
+                        "array",
+                        "boolean",
+                        "number",
+                        "null",
+                        "object",
+                        "string"
+                    ]
+                }
+            },
+            "properties": {
+		"IdenNameSpaceDataStruct": {
+                    "anyOf": [
+                        {
+                            "$ref": "#/definitions/IdenNameSpaceDataStruct"
+                        },
+                        {
+                            "type": "null"
+                        }
+                    ]
+                },
+		"IdenNameSpaceLBAFmts": {
+                    "anyOf": [
+                        {
+                            "$ref": "#/definitions/IdenNameSpaceLBAFmts"
+                        },
+                        {
+                            "type": "null"
+                        }
+                    ]
+                },
+		"IdenNameSpaceList": {
+                    "anyOf": [
+                        {
+                            "$ref": "#/definitions/IdenNameSpaceList"
+                        },
+                        {
+                            "type": "null"
+                        }
+                    ]
+                },
+		"IdenPwrStDes": {
+                    "anyOf": [
+                        {
+                            "$ref": "#/definitions/IdenPwrStDes"
+                        },
+                        {
+                            "type": "null"
+                        }
+                    ]
+                },   
+                "NVMeMISubSystemInformation": {
+                    "anyOf": [
+                        {
+                            "$ref": "#/definitions/NVMeMISubSystemInformation"
+                        },
+                        {
+                            "type": "null"
+                        }
+                    ]
+                },
+		"VitalProductData": {
+                    "anyOf": [
+                        {
+                            "$ref": "#/definitions/VitalProductData"
+                        },
+                        {
+                            "type": "null"
+                        }
+                    ]
+                }
+            },
+            "type": "object"
+        },
+	"IdenNameSpaceDataStruct": {
+            "additionalProperties": true,
+            "description": "IdenNameSpaceDataStruct properties.",
+            "patternProperties": {
+                "^([a-zA-Z_][a-zA-Z0-9_]*)?@(odata|Redfish|Message)\\.[a-zA-Z_][a-zA-Z0-9_.]+$": {
+                    "description": "This property shall specify a valid odata or Redfish property.",
+                    "type": [
+                        "array",
+                        "boolean",
+                        "number",
+                        "null",
+                        "object",
+                        "string"
+                    ]
+                }
+            },
+            "properties": {
+                "NamespaceCapacity": {
+                    "description": "It specifies NamespaceCapacity.",
+                    "longDescription": "It specifies NamespaceCapacity.",
+                    "type": "number"
+                },
+               "NamespaceSize": {
+                    "description": "It specifies Namespace Size.",
+                    "longDescription": "It specifies Namespace Size.",
+                    "type": "number"
+                },
+                "NamespaceUtilization": {
+                    "description": "It specifies Namespace Utilization.",
+                    "longDescription": "It specifies Namespace Utilization.",
+                    "type": "number"
+                }
+	    },
+            "type": "object"
+        },
+        "IdenNameSpaceLBAFmts": {
+            "additionalProperties": true,
+            "description": "IdenNameSpaceLBAFmts properties.",
+            "patternProperties": {
+                "^([a-zA-Z_][a-zA-Z0-9_]*)?@(odata|Redfish|Message)\\.[a-zA-Z_][a-zA-Z0-9_.]+$": {
+                    "description": "This property shall specify a valid odata or Redfish property.",
+                    "type": [
+                        "array",
+                        "boolean",
+                        "number",
+                        "null",
+                        "object",
+                        "string"
+                    ]
+                }
+            },
+            "properties": {
+                "LBAdataSizeofLBAFmtsNo0": {
+                    "description": "LBA data size,the value is reported in terms of 2^n",
+                    "longDescription": "LBA data size,the value is reported in terms of 2^n.",
+                    "type": "number"
+                },
+	       "LBAdataSizeofLBAFmtsNo1": {
+                    "description": "LBA data size,the value is reported in terms of 2^n.",
+                    "longDescription": "LBA data size,the value is reported in terms of 2^n.",
+                    "type": "number"
+                },
+                "MetadataSizeofLBAFmtsNo0": {
+                    "description": "The number of metadata bytes provided per LBA based on the LBA Data Size.",
+                    "longDescription": "The number of metadata bytes provided per LBA based on the LBA Data Size.",
+                    "type": "number"
+                },
+                "MetadataSizeofLBAFmtsNo1": {
+                    "description": "The number of metadata bytes provided per LBA based on the LBA Data Size.",
+                    "longDescription": "The number of metadata bytes provided per LBA based on the LBA Data Size.",
+                    "type": "number"
+                },
+                "RelativePerformofLBAFmtsNo0": {
+                    "description": "Relative performance of the LBA format.",
+                    "longDescription": "The relative performance of the LBA format indicated relative to other LBA formats supported by the controller. 2 means good performance.1 – better performance,0 – best performance,3 – Degraded performance.",
+                    "type": "number"
+                },
+                "RelativePerformofLBAFmtsNo1": {
+                    "description": "Relative performance of the LBA format.",
+                    "longDescription": "The relative performance of the LBA format indicated relative to other LBA formats supported by the controller. 2 means good performance.1 – better performance,0 – best performance,3 – Degraded performance.",
+                    "type": "number"
+                }
+	    },
+	    "type": "object"
+	 },
+        "IdenNameSpaceList": {
+            "additionalProperties": true,
+            "description": "IdenNameSpaceList properties.",
+            "patternProperties": {
+                "^([a-zA-Z_][a-zA-Z0-9_]*)?@(odata|Redfish|Message)\\.[a-zA-Z_][a-zA-Z0-9_.]+$": {
+                    "description": "This property shall specify a valid odata or Redfish property.",
+                    "type": [
+                        "array",
+                        "boolean",
+                        "number",
+                        "null",
+                        "object",
+                        "string"
+                    ]
+                }
+            },
+            "properties": {
+                "NameSpaceListNo0": {
+                    "description": "Identify Namespace Data List.",
+                    "longDescription":"It gives the Namespace Data List0 information.",
+                    "type": "number"
+                },
+               "NameSpaceListNo1": {
+                    "description": "Identify Namespace Data List.",
+                    "longDescription":"It gives the Namespace Data List0 information.",
+                    "type": "number"
+                }
+	     },
+	     "type": "object"
+	 },
+        "IdenPwrStDes": {
+            "additionalProperties": true,
+            "description": "IdenPwrStDes properties.",
+            "patternProperties": {
+                "^([a-zA-Z_][a-zA-Z0-9_]*)?@(odata|Redfish|Message)\\.[a-zA-Z_][a-zA-Z0-9_.]+$": {
+                    "description": "This property shall specify a valid odata or Redfish property.",
+                    "type": [
+                        "array",
+                        "boolean",
+                        "number",
+                        "null",
+                        "object",
+                        "string"
+                    ]
+                }
+            },
+            "properties": {
+                "MaxPowerScaleNo0": {
+                    "description": "The scale for the Maximum Power field.",
+                    "longDescription":"If this bit is cleared to ‘0’, then the scale of the Maximum Power field is in 0.01 Watts. If this bit is set to '1’, then the scale of the Maximum Power field is in 0.0001 Watts.",
+                    "type": "number"
+                },
+               "MaxPowerScaleNo1": {
+                    "description": "The scale for the Maximum Power field.",
+                    "longDescription":"If this bit is cleared to ‘0’, then the scale of the Maximum Power field is in 0.01 Watts. If this bit is set to '1’, then the scale of the Maximum Power field is in 0.0001 Watts.",
+                    "type": "number"
+                },
+                "MaxPowerStateNo0": {
+                    "description": "Indicates the sustained maximum power consumed by the NVM subsystem in this power state.",
+                    "longDescription": "Indicates the sustained maximum power consumed by the NVM subsystem in this power state.",
+                    "type": "number"
+                },
+                "MaxPowerStateNo1": {
+                    "description": "Indicates the sustained maximum power consumed by the NVM subsystem in this power state.",
+                    "longDescription": "Indicates the sustained maximum power consumed by the NVM subsystem in this power state.",
+                    "type": "number"
+                }
+            },
+            "type": "object"
+         },
+         "NVMeMISubSystemInformation": {
+            "additionalProperties": true,
+            "description": "AMI oem NVMeMISubSystemInformation properties.",
+            "patternProperties": {
+                "^([a-zA-Z_][a-zA-Z0-9_]*)?@(odata|Redfish|Message)\\.[a-zA-Z_][a-zA-Z0-9_.]+$": {
+                    "description": "This property shall specify a valid odata or Redfish property.",
+                    "type": [
+                        "array",
+                        "boolean",
+                        "number",
+                        "null",
+                        "object",
+                        "string"
+                    ]
+                }
+            },
+            "properties": {
+                "SubSystemHealthStatusPoll": {
+                    "anyOf": [
+                        {
+                            "$ref": "#/definitions/SubSystemHealthStatusPoll"
+                        },
+                        {
+                            "type": "null"
+                        }
+                    ]
+                },
+                "SubSystemInformation": {
+                    "anyOf": [
+                        {
+                            "$ref": "#/definitions/SubSystemInformation"
+                        },
+                        {
+                            "type": "null"
+                        }
+                    ]
+                }
+            },
+            "type": "object"
+        },
+	"SubSystemHealthStatusPoll": {
+            "additionalProperties": true,
+            "description": "SubSystemHealthStatusPoll properties.",
+            "patternProperties": {
+                "^([a-zA-Z_][a-zA-Z0-9_]*)?@(odata|Redfish|Message)\\.[a-zA-Z_][a-zA-Z0-9_.]+$": {
+                    "description": "This property shall specify a valid odata or Redfish property.",
+                    "type": [
+                        "array",
+                        "boolean",
+                        "number",
+                        "null",
+                        "object",
+                        "string"
+                    ]
+                }
+            },
+            "properties": {
+                "CompositeControllerStatus": {
+                    "anyOf": [
+                        {
+                            "$ref": "#/definitions/CompositeControllerStatus"
+                        },
+                        {
+                            "type": "null"
+                        }
+                    ]
+                },
+		"CompositeTemperature": {
+                    "description": "The CompositeTemperature of a Controller.",
+                    "longDescription": "It represents the current CompositeTemperature of the Controller.",
+                    "type": "number"
+                },
+		"DriveFunctional": {
+                    "description": "It indicate an NVM Subsystem is functional or not.",
+                    "longDescription": "If DriveFunctional is set indicates NVM Subsystem functional and '0' indicates failure.",
+                    "type": "number"
+                },
+		"PDLU": {
+                    "description": "This bit is set when the Percentage Used field in the Controller Health Status Changed.",
+                    "longDescription": "This bit is set when the Percentage Used field in the Controller Health Status Changed.",
+                    "type": "number"
+                },
+		"Port0PCIeLinkActive": {
+                    "description": "This bit is set to indicate the first port’s PCIe link is up.",
+                    "longDescription": "This bit is set to indicate the first port’s PCIe link is up.",
+                    "type": "number"
+                },
+		"Port1PCIeLinkActive": {
+                    "description": "This bit is set to indicate the second port’s PCIe link is up.",
+                    "longDescription": "This bit is set to indicate the second port’s PCIe link is up.",
+                    "type": "number"
+                },
+		"ResetNotRequired": {
+                    "description": "The bit is set to '1' indicates ResetNotRequired and set to '0' indicates Reset Required.",
+                    "longDescription": "The bit is set to '1' indicates ResetNotRequired and set to '0' indicates Reset Required.",
+                    "type": "number"
+                },
+		"SmartWarnings": {
+                    "anyOf": [
+                        {
+                            "$ref": "#/definitions/SmartWarnings"
+                        },
+                        {
+                            "type": "null"
+                        }
+                    ]
+                }
+	   },
+	   "type": "object"
+        },
+        "SmartWarnings": {
+            "additionalProperties": true,
+            "description": "SmartWarnings properties.",
+            "patternProperties": {
+                "^([a-zA-Z_][a-zA-Z0-9_]*)?@(odata|Redfish|Message)\\.[a-zA-Z_][a-zA-Z0-9_.]+$": {
+                    "description": "This property shall specify a valid odata or Redfish property.",
+                    "type": [
+                        "array",
+                        "boolean",
+                        "number",
+                        "null",
+                        "object",
+                        "string"
+                    ]
+                }
+            },
+            "properties": {
+                 "UnderThresh": {
+                    "description": "UnderThresh details.",
+                    "longDescription": "UnderThresh details.",
+                    "type": "number"
+                }
+            },
+            "type": "object"
+	},
+	"SubSystemInformation": {
+            "additionalProperties": true,
+            "description": "SubSystemInformation properties.",
+            "patternProperties": {
+                "^([a-zA-Z_][a-zA-Z0-9_]*)?@(odata|Redfish|Message)\\.[a-zA-Z_][a-zA-Z0-9_.]+$": {
+                    "description": "This property shall specify a valid odata or Redfish property.",
+                    "type": [
+                        "array",
+                        "boolean",
+                        "number",
+                        "null",
+                        "object",
+                        "string"
+                    ]
+                }
+            },
+            "properties": {
+                 "MajorVersion": {
+                    "description": "MajorVersion details.",
+                    "longDescription": "MajorVersion details.",
+                    "type": "number"
+                },
+			     "MinorVersion": {
+                    "description": "MinorVersion details.",
+                    "longDescription": "MinorVersion details.",
+                    "type": "number"
+                },
+			     "NoOfPorts": {
+                    "description": "NoOfPorts details.",
+                    "longDescription": "NoOfPorts details.",
+                    "type": "number"
+                }
+            },
+		    "type": "object"
+	},		
+	"VitalProductData": {
+            "additionalProperties": true,
+            "description": "AMI oem VitalProductData properties.",
+            "patternProperties": {
+                "^([a-zA-Z_][a-zA-Z0-9_]*)?@(odata|Redfish|Message)\\.[a-zA-Z_][a-zA-Z0-9_.]+$": {
+                    "description": "This property shall specify a valid odata or Redfish property.",
+                    "type": [
+                        "array",
+                        "boolean",
+                        "number",
+                        "null",
+                        "object",
+                        "string"
+                    ]
+                }
+            },
+            "properties": {
+                "MultiRecordInformation": {
+                    "anyOf": [
+                        {
+                            "$ref": "#/definitions/MultiRecordInformation"
+                        },
+                        {
+                            "type": "null"
+                        }
+                    ]
+                },
+                "ProductInformation": {
+                    "anyOf": [
+                        {
+                            "$ref": "#/definitions/ProductInformation"
+                        },
+                        {
+                            "type": "null"
+                        }
+                    ]
+                }
+            },
+            "type": "object"
+        },
+	"MultiRecordInformation": {
+            "additionalProperties": true,
+            "description": "AMI oem MultiRecordInformation properties.",
+            "patternProperties": {
+                "^([a-zA-Z_][a-zA-Z0-9_]*)?@(odata|Redfish|Message)\\.[a-zA-Z_][a-zA-Z0-9_.]+$": {
+                    "description": "This property shall specify a valid odata or Redfish property.",
+                    "type": [
+                        "array",
+                        "boolean",
+                        "number",
+                        "null",
+                        "object",
+                        "string"
+                    ]
+                }
+            },
+            "properties": {
+                "NVMeMultiRecord": {
+                    "anyOf": [
+                        {
+                            "$ref": "#/definitions/NVMeMultiRecord"
+                        },
+                        {
+                            "type": "null"
+                        }
+                    ]
+                },
+                "NVMePCIePortMultiRecord": {
+                    "anyOf": [
+                        {
+                            "$ref": "#/definitions/NVMePCIePortMultiRecord"
+                        },
+                        {
+                            "type": "null"
+                        }
+                    ]
+                }
+            },
+            "type": "object"
+        },
+	"NVMeMultiRecord": {
+            "additionalProperties": true,
+            "description": "NVMeMultiRecord properties.",
+            "patternProperties": {
+                "^([a-zA-Z_][a-zA-Z0-9_]*)?@(odata|Redfish|Message)\\.[a-zA-Z_][a-zA-Z0-9_.]+$": {
+                    "description": "This property shall specify a valid odata or Redfish property.",
+                    "type": [
+                        "array",
+                        "boolean",
+                        "number",
+                        "null",
+                        "object",
+                        "string"
+                    ]
+                }
+            },
+            "properties": {
+                "EPTFactor": {
+                    "description": "This field indicates the form factor of the Management Endpoint.",
+                    "longDescription": "This field indicates the form factor of the Management Endpoint.",
+                    "type": "number"
+                },
+		        "InitialPowerSupplyReq1.8v": {
+                    "description": "This indicates the initial 1.8V power supply requirements in Watts prior to receiving a Set Slot Power message.",
+                    "longDescription": "This indicates the initial 1.8V power supply requirements in Watts prior to receiving a Set Slot Power message.",
+                    "type": "number"
+                },
+                "InitialPowerSupplyReq12v": {
+                    "description": "This indicates the initial 12V power supply requirements in Watts prior to receiving a Set Slot Power message.",
+                    "longDescription": "This indicates the initial 12V power supply requirements in Watts prior to receiving a Set Slot Power message.",
+                    "type": "number"
+                },
+	            "InitialPowerSupplyReq3.3v": {
+                    "description": "This indicates the initial 3.3V power supply requirements in Watts prior to receiving a Set Slot Power message.",
+                    "longDescription": "This indicates the initial 3.3V power supply requirements in Watts prior to receiving a Set Slot Power message.",
+                    "type": "number"
+                },
+	            "InitialPowerSupplyReq5v": {
+                    "description": "This indicates the initial 5V power supply requirements in Watts prior to receiving a Set Slot Power message.",
+                    "longDescription": "This indicates the initial 5V power supply requirements in Watts prior to receiving a Set Slot Power message.",
+                    "type": "number"
+                },
+		        "MaxAuxPowerSupplyReq3.3v": {
+                    "description": "This indicates the maximum 3.3V power supply requirements.",
+                    "longDescription": "This indicates the maximum 3.3V power supply requirements in 10 mW units. A value of zero indicates that the power supply voltage is not used.",
+                    "type": "number"
+                },
+				"MaxPowerSupplyReq1.8v": {
+                    "description": "This field specifies the maximum 1.8V power supply requirements in Watts.",
+                    "longDescription": "This field specifies the maximum 1.8V power supply requirements in Watts.",
+                    "type": "number"
+                },
+				"MaxPowerSupplyReq12v": {
+                    "description": "This field specifies the maximum 12V power supply requirements in Watts.",
+                    "longDescription": "This field specifies the maximum 12V power supply requirements in Watts.",
+                    "type": "number"
+                },
+				"MaxPowerSupplyReq3.3v": {
+                    "description": "This field specifies the maximum 3.3V power supply requirements in Watts.",
+                    "longDescription": "This field specifies the maximum 3.3V power supply requirements in Watts.",
+                    "type": "number"
+                },
+		        "MaxPowerSupplyReq5v": {
+                    "description": "This field specifies the maximum 5V power supply requirements in Watts.",
+                    "longDescription": "This field specifies the maximum 5V power supply requirements in Watts.",
+                    "type": "number"
+                },
+		        "MaxThermalLoad": {
+                    "description": "This field specifies the maximum thermal load from the NVM Subsystem in Watts.",
+                    "longDescription": "This field specifies the maximum thermal load from the NVM Subsystem in Watts.",
+                    "type": "number"
+                },
+		        "RecordAreaVersion": {
+                    "description": "This field indicates the version number of this multirecord.",
+                    "longDescription": "This field indicates the version number of this multirecord.",
+                    "type": "number"
+                }
+	   },
+	   "type": "object"
+        },
+	"NVMePCIePortMultiRecord": {
+            "additionalProperties": true,
+            "description": "NVMePCIePortMultiRecord properties.",
+            "patternProperties": {
+                "^([a-zA-Z_][a-zA-Z0-9_]*)?@(odata|Redfish|Message)\\.[a-zA-Z_][a-zA-Z0-9_.]+$": {
+                    "description": "This property shall specify a valid odata or Redfish property.",
+                    "type": [
+                        "array",
+                        "boolean",
+                        "number",
+                        "null",
+                        "object",
+                        "string"
+                    ]
+                }
+            },
+            "properties": {
+                "MctpSupport": {
+                    "description": "This field contains a bit vector that specifies the level of support for the NVMe Management Interface.",
+                    "longDescription": "This field contains a bit vector that specifies the level of support for the NVMe Management Interface.",
+                    "type": "number"
+                },
+		"PCIeMaximumLinkWidth": {
+                    "description": "The maximum PCIe link width for this NVM Subsystem port.",
+                    "longDescription": "The maximum PCIe link width for this NVM Subsystem port.",
+                    "type": "string"
+                },
+		"PCIePortInformation": {
+                    "description": "This indicates information about the PCIe Ports in the device.",
+                    "longDescription": "This indicates information about the PCIe Ports in the device.",
+                    "type": "number"
+                },
+		"PCIePortNumber": {
+                    "description": "This field contains the PCIe port number.",
+                    "longDescription": "This field contains the PCIe port number.",
+                    "type": "number"
+                },
+		"PCIeRecordVersion": {
+                    "description": "NVMe PCIe Port MultiRecord Area Version Number.",
+                    "longDescription": "NVMe PCIe Port MultiRecord Area Version Number.",
+                    "type": "string"
+                },
+		"PCIeSupportedlinkSpeeds": {
+                    "description": "This field indicates a bit vector of link speeds supported by the PCIe port.",
+                    "longDescription": "This field indicates a bit vector of link speeds supported by the PCIe port.",
+                    "type": "string"
+                },
+		"RefClockCapability": {
+                    "description": "This field contains a bit vector that specifies the PCIe clocking modes supported by the port.",
+                    "longDescription": "This field contains a bit vector that specifies the PCIe clocking modes supported by the port.",
+                    "type": "string"
+                }
+            },
+            "type": "object"
+        },
+        "ProductInformation": {
+            "additionalProperties": true,
+            "description": "ProductInformation properties.",
+            "patternProperties": {
+                "^([a-zA-Z_][a-zA-Z0-9_]*)?@(odata|Redfish|Message)\\.[a-zA-Z_][a-zA-Z0-9_.]+$": {
+                    "description": "This property shall specify a valid odata or Redfish property.",
+                    "type": [
+                        "array",
+                        "boolean",
+                        "number",
+                        "null",
+                        "object",
+                        "string"
+                    ]
+                }
+            },
+            "properties": {
+                "IPMIVersion": {
+                    "description": "IPMIVersion details.",
+                    "longDescription": "IPMIVersion details.",
+                    "type": "number"
+                }
+            },
+            "type": "object"
+        }
+    },
+    "title": "#OemAMINVMeMIController"
+}	
+	
diff --git a/static/redfish/v1/schema/AMINVMeMIPort_v1.xml b/static/redfish/v1/schema/AMINVMeMIPort_v1.xml
new file mode 100644
index 00000000..1901a66c
--- /dev/null
+++ b/static/redfish/v1/schema/AMINVMeMIPort_v1.xml
@@ -0,0 +1,87 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<edmx:Edmx xmlns:edmx="http://docs.oasis-open.org/odata/ns/edmx" Version="4.0">
+    <edmx:Reference Uri="http://docs.oasis-open.org/odata/odata/v4.0/errata03/csd01/complete/vocabularies/Org.OData.Core.V1.xml">
+        <edmx:Include Namespace="Org.OData.Core.V1" Alias="OData" />
+    </edmx:Reference>
+    <edmx:Reference Uri="http://redfish.dmtf.org/schemas/v1/RedfishExtensions_v1.xml">
+        <edmx:Include Namespace="Validation.v1_0_0" Alias="Validation"/>
+        <edmx:Include Namespace="RedfishExtensions.v1_0_0" Alias="Redfish"/>
+    </edmx:Reference>
+    <edmx:Reference Uri="http://redfish.dmtf.org/schemas/v1/port_v1.xml">
+        <edmx:Include Namespace="Port"/>
+        <edmx:Include Namespace="Port.v1_3_0"/>
+    </edmx:Reference>
+    <edmx:Reference Uri="http://redfish.dmtf.org/schemas/v1/Resource_v1.xml">
+        <edmx:Include Namespace="Resource"/>
+        <edmx:Include Namespace="Resource.v1_0_0"/>
+    </edmx:Reference>
+<edmx:DataServices>
+
+<Schema xmlns="http://docs.oasis-open.org/odata/ns/edm" Namespace="AMINVMeMIPort">
+        <ComplexType Name="Oem" BaseType="Resource.OemObject">
+          <Annotation Term="OData.AdditionalProperties" Bool="true" />
+          <Annotation Term="OData.Description" String="OemAMINVMeMIController Oem properties." />
+          <Annotation Term="OData.AutoExpand"/>
+          <Property Name="Ami" Type="AMINVMeMIPort.Ami"/>
+        </ComplexType>
+
+        <ComplexType Name="Ami" BaseType="Resource.OemObject">
+          <Annotation Term="OData.AdditionalProperties" Bool="true" />
+          <Annotation Term="OData.Description" String="Oem properties for Ami." />
+          <Annotation Term="OData.AutoExpand"/>
+          <Property Name="PortInformation" Type="AMINVMeMIPort.PortInformation" />
+         </ComplexType>
+
+        <ComplexType Name="PortInformation" BaseType="Resource.OemObject">
+         <Property Name="CurrentLinkSpeed" Type="Edm.String">
+          <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+          <Annotation Term="OData.Description" String="This field indicates a bit vector of link speeds supported by the PCIe port."/>
+          <Annotation Term="OData.LongDescription" String="This field indicates a bit vector of link speeds supported by the PCIe port."/>
+         </Property>
+          <Property Name="MaxLinkWidth" Type="Edm.String">
+          <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+          <Annotation Term="OData.Description" String="Indicates endpoint socket name and location."/>
+          <Annotation Term="OData.LongDescription" String="The value of this property shall be a structure ring indicating location and name of the socket used to communicate with nbd server."/>
+         </Property>
+         <Property Name="MaxMCTPTransUnitSize" Type="Edm.Decimal">
+          <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+          <Annotation Term="OData.Description" String="The maximum MCTP Transmission Unit size the port is capable of sending and receiving."/>
+          <Annotation Term="OData.LongDescription" String="The maximum MCTP Transmission Unit size the port is capable of sending and receiving."/>
+         </Property>
+         <Property Name="MaxPayloadSize" Type="Edm.String">
+          <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+          <Annotation Term="OData.Description" String="This field indicates the Max Payload Size for the specified PCIe port."/>
+          <Annotation Term="OData.LongDescription" String="This field indicates the Max Payload Size for the specified PCIe port."/>
+         </Property>
+         <Property Name="NegotiatedLinkWidth" Type="Edm.String">
+          <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+          <Annotation Term="OData.Description" String="The negotiated PCIe link width for this port."/>
+          <Annotation Term="OData.LongDescription" String="The negotiated PCIe link width for this port."/>
+         </Property>
+         <Property Name="PortNo" Type="Edm.String">
+          <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+          <Annotation Term="OData.Description" String="This field contains the PCIe port number."/>
+          <Annotation Term="OData.LongDescription" String="This field contains the PCIe port number."/>
+         </Property>
+         <Property Name="PortStatus" Type="Edm.String">
+          <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+          <Annotation Term="OData.Description" String="This field indicates information about the PCIe Ports in the device."/>
+          <Annotation Term="OData.LongDescription" String="This field indicates information about the PCIe Ports in the device."/>
+         </Property>
+         <Property Name="PortType" Type="Edm.String">
+          <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+          <Annotation Term="OData.Description" String="This fiels indicates port Type."/>
+          <Annotation Term="OData.LongDescription" String="This fiels indicates port Type."/>
+         </Property>
+         <Property Name="SupportedLinkSpeeds" Type="Edm.String">
+          <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+          <Annotation Term="OData.Description" String="This field indicates the Supported Link Speeds for the specified PCIe port."/>
+          <Annotation Term="OData.LongDescription" String="This field indicates the Supported Link Speeds for the specified PCIe port."/>
+         </Property>
+      </ComplexType>
+    </Schema>
+
+  </edmx:DataServices>
+</edmx:Edmx>
+
+
diff --git a/static/redfish/v1/schema/OemDrive_v1.xml b/static/redfish/v1/schema/OemDrive_v1.xml
new file mode 100644
index 00000000..d1789515
--- /dev/null
+++ b/static/redfish/v1/schema/OemDrive_v1.xml
@@ -0,0 +1,57 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<edmx:Edmx xmlns:edmx="http://docs.oasis-open.org/odata/ns/edmx" Version="4.0">
+
+  <edmx:Reference Uri="http://docs.oasis-open.org/odata/odata/v4.0/errata03/csd01/complete/vocabularies/Org.OData.Core.V1.xml">
+    <edmx:Include Namespace="Org.OData.Core.V1" Alias="OData"/>
+  </edmx:Reference>
+  <edmx:Reference Uri="http://docs.oasis-open.org/odata/odata/v4.0/errata03/csd01/complete/vocabularies/Org.OData.Measures.V1.xml">
+    <edmx:Include Namespace="Org.OData.Measures.V1" Alias="Measures"/>
+  </edmx:Reference>
+  <edmx:Reference Uri="http://redfish.dmtf.org/schemas/v1/RedfishExtensions_v1.xml">
+    <edmx:Include Namespace="RedfishExtensions.v1_0_0" Alias="Redfish"/>
+  </edmx:Reference>
+  <edmx:Reference Uri="http://redfish.dmtf.org/schemas/v1/Resource_v1.xml">
+    <edmx:Include Namespace="Resource"/>
+    <edmx:Include Namespace="Resource.v1_0_0"/>
+  </edmx:Reference>
+
+  <edmx:DataServices>
+
+    <Schema xmlns="http://docs.oasis-open.org/odata/ns/edm" Namespace="OemDrive">
+      <Annotation Term="Redfish.OwningEntity" String="OpenBmc"/>
+    </Schema>
+
+    <Schema xmlns="http://docs.oasis-open.org/odata/ns/edm" Namespace="OemDrive.v1_0_0">
+      <Annotation Term="Redfish.OwningEntity" String="OpenBmc"/>
+      <Annotation Term="Redfish.Release" String="1.0"/>
+
+      <EntityType Name="Drive" BaseType="Resource.OemObject" Abstract="true">
+        <Annotation Term="OData.Description" String="OEM Extension for Drive"/>
+        <Annotation Term="OData.LongDescription" String="OEM Extension for Drive."/>
+        <Property Name="DeviceLocation" Type="Edm.String">
+          <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+          <Annotation Term="OData.Description" String="The indicates device slot number."/>
+          <Annotation Term="OData.LongDescription" String="This indicates device slot number."/>
+        </Property>
+         <Property Name="Firmware_Version" Type="Edm.String">
+          <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+          <Annotation Term="OData.Description" String="Indicates Frimware version."/>
+          <Annotation Term="OData.LongDescription" String="Indicates Frimware version."/>
+        </Property>
+         <Property Name="ProductID" Type="Edm.String">
+          <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+          <Annotation Term="OData.Description" String="The model name of the drive."/>
+          <Annotation Term="OData.LongDescription" String="The model name of the drive."/>
+        </Property>
+         <Property Name="SlotNumber" Type="Edm.Decimal">
+          <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+          <Annotation Term="OData.Description" String="The slot number the drive connected."/>
+          <Annotation Term="OData.LongDescription" String="The slot number the drive connected.."/>
+        </Property>
+      </EntityType>
+    </Schema>
+
+  </edmx:DataServices>
+</edmx:Edmx>
+
+
diff --git a/static/redfish/v1/schema/OemNvme_v1.xml b/static/redfish/v1/schema/OemNvme_v1.xml
new file mode 100644
index 00000000..a1b83241
--- /dev/null
+++ b/static/redfish/v1/schema/OemNvme_v1.xml
@@ -0,0 +1,433 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<edmx:Edmx xmlns:edmx="http://docs.oasis-open.org/odata/ns/edmx" Version="4.0">
+    <edmx:Reference Uri="http://docs.oasis-open.org/odata/odata/v4.0/errata03/csd01/complete/vocabularies/Org.OData.Core.V1.xml">
+        <edmx:Include Namespace="Org.OData.Core.V1" Alias="OData" />
+    </edmx:Reference>
+    <edmx:Reference Uri="http://redfish.dmtf.org/schemas/v1/RedfishExtensions_v1.xml">
+        <edmx:Include Namespace="Validation.v1_0_0" Alias="Validation"/>
+        <edmx:Include Namespace="RedfishExtensions.v1_0_0" Alias="Redfish"/>
+    </edmx:Reference>
+    <edmx:Reference Uri="http://redfish.dmtf.org/schemas/v1/StorageController_v1.xml">
+        <edmx:Include Namespace="StorageController"/>
+        <edmx:Include Namespace="StorageController.v1_6_0"/>
+    </edmx:Reference>
+    <edmx:Reference Uri="http://redfish.dmtf.org/schemas/v1/Resource_v1.xml">
+        <edmx:Include Namespace="Resource"/>
+        <edmx:Include Namespace="Resource.v1_0_0"/>
+    </edmx:Reference>
+
+
+<edmx:DataServices>
+        <Schema xmlns="http://docs.oasis-open.org/odata/ns/edm" Namespace="OemAMINVMeMIController">
+            <ComplexType Name="Oem" BaseType="Resource.OemObject">
+                <Annotation Term="OData.AdditionalProperties" Bool="true" />
+                <Annotation Term="OData.Description" String="OemAMINVMeMIController Oem properties." />
+                <Annotation Term="OData.AutoExpand"/>
+                <Property Name="Ami" Type="OemAMINVMeMIController.Ami"/>
+            </ComplexType>
+
+         <ComplexType Name="Ami" BaseType="Resource.OemObject">
+             <Annotation Term="OData.AdditionalProperties" Bool="true" />
+             <Annotation Term="OData.Description" String="Oem properties for Ami." />
+             <Annotation Term="OData.AutoExpand"/>
+             <Property Name="IdenNameSpaceDataStruct" Type="OemAMINVMeMIController.IdenNameSpaceDataStruct" />
+             <Property Name="IdenNameSpaceLBAFmts" Type="OemAMINVMeMIController.IdenNameSpaceLBAFmts" />
+             <Property Name="IdenNameSpaceList" Type="OemAMINVMeMIController.IdenNameSpaceList" />
+             <Property Name="IdenPwrStDes" Type="OemAMINVMeMIController.IdenPwrStDes" />
+             <Property Name="NVMeMISubSystemInformation" Type="OemAMINVMeMIController.NVMeMISubSystemInformation" />
+             <Property Name="VitalProductData" Type="OemAMINVMeMIController.VitalProductData"/>
+         </ComplexType>
+         
+	 <ComplexType Name="IdenNameSpaceDataStruct" BaseType="Resource.OemObject">
+            <Annotation Term="OData.AdditionalProperties" Bool="true" />
+            <Annotation Term="OData.Description" String="Oem properties for IdenNameSpaceLBAFmts." />
+            <Annotation Term="OData.AutoExpand"/>
+            <Property Name="NamespaceCapacity" Type="Edm.Decimal" Nullable="false">
+             <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+             <Annotation Term="OData.Description" String="It specifies NamespaceCapacity"/>
+             <Annotation Term="OData.LongDescription" String="It specifies NamespaceCapacity."/>
+            </Property>
+             <Property Name="NamespaceSize" Type="Edm.Decimal" Nullable="false">
+             <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+             <Annotation Term="OData.Description" String="It specifies Namespace Size"/>
+             <Annotation Term="OData.LongDescription" String="It specifies Namespace Size."/>
+           </Property>
+             <Property Name="NamespaceUtilization" Type="Edm.Decimal" Nullable="false">
+             <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+             <Annotation Term="OData.Description" String="It specifies Namespace Utilization"/>
+             <Annotation Term="OData.LongDescription" String="It specifies Namespace Utilization."/>
+           </Property>
+         </ComplexType>
+	 
+
+
+	 <ComplexType Name="IdenNameSpaceLBAFmts" BaseType="Resource.OemObject">
+            <Annotation Term="OData.AdditionalProperties" Bool="true" />
+            <Annotation Term="OData.Description" String="Oem properties for IdenNameSpaceLBAFmts." />
+            <Annotation Term="OData.AutoExpand"/>
+            <Property Name="LBAdataSizeofLBAFmtsNo0" Type="Edm.Decimal" Nullable="false">
+             <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+             <Annotation Term="OData.Description" String="LBA data size,the value is reported in terms of 2^n"/>
+             <Annotation Term="OData.LongDescription" String="LBA data size,the value is reported in terms of 2^n."/>
+            </Property>
+             <Property Name="LBAdataSizeofLBAFmtsNo1" Type="Edm.Decimal" Nullable="false">
+             <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+             <Annotation Term="OData.Description" String="LBA data size,the value is reported in terms of 2^n"/>
+             <Annotation Term="OData.LongDescription" String="LBA data size,the value is reported in terms of 2^n ."/>
+           </Property>
+             <Property Name="MetadataSizeofLBAFmtsNo0" Type="Edm.Decimal" Nullable="false">
+             <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+             <Annotation Term="OData.Description" String="The number of metadata bytes provided per LBA based on the LBA Data Size"/>
+             <Annotation Term="OData.LongDescription" String="The number of metadata bytes provided per LBA based on the LBA Data Size."/>
+           </Property>
+             <Property Name="MetadataSizeofLBAFmtsNo1" Type="Edm.Decimal" Nullable="false">
+             <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+             <Annotation Term="OData.Description" String="The number of metadata bytes provided per LBA based on the LBA Data Size"/>
+             <Annotation Term="OData.LongDescription" String="The number of metadata bytes provided per LBA based on the LBA Data Size."/>
+           </Property>
+             <Property Name="RelativePerformofLBAFmtsNo0" Type="Edm.Decimal" Nullable="false">
+             <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+             <Annotation Term="OData.Description" String="Relative performance of the LBA format "/>
+             <Annotation Term="OData.LongDescription" String="The relative performance of the LBA format indicated relative to other LBA formats supported by the controller. 2 means good performance.1 – better performance,0 – best performance,3 – Degraded performance."/>
+           </Property>
+             <Property Name="RelativePerformofLBAFmtsNo1" Type="Edm.Decimal" Nullable="false">
+             <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+             <Annotation Term="OData.Description" String="Relative performance of the LBA format "/>
+             <Annotation Term="OData.LongDescription" String="The relative performance of the LBA format indicated relative to other LBA formats supported by the controller. 2 means good performance.1 – better performance,0 – best performance,3 – Degraded performance ."/>
+           </Property>
+         </ComplexType>
+         
+	 <ComplexType Name="IdenNameSpaceList" BaseType="Resource.OemObject">
+            <Annotation Term="OData.AdditionalProperties" Bool="true" />
+            <Annotation Term="OData.Description" String="Oem properties for IdenNameSpaceLBAFmts." />
+            <Annotation Term="OData.AutoExpand"/>
+            <Property Name="NameSpaceListNo0" Type="Edm.Decimal" Nullable="false">
+             <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+             <Annotation Term="OData.Description" String="Identify Namespace Data List"/>
+             <Annotation Term="OData.LongDescription" String="It gives the Namespace Data List0 information."/>
+            </Property>
+             <Property Name="NameSpaceListNo1" Type="Edm.Decimal" Nullable="false">
+             <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+             <Annotation Term="OData.Description" String="Identify Namespace Data List"/>
+             <Annotation Term="OData.LongDescription" String="It gives the Namespace Data List1 information ."/>
+            </Property>
+	 </ComplexType>
+
+         <ComplexType Name="IdenPwrStDes" BaseType="Resource.OemObject">
+            <Annotation Term="OData.AdditionalProperties" Bool="true" />
+            <Annotation Term="OData.Description" String="Oem properties for NVMeMISubSystemInformation." />
+            <Annotation Term="OData.AutoExpand"/>
+            <Property Name="MaxPowerScaleNo0" Type="Edm.Decimal" Nullable="false">
+             <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+             <Annotation Term="OData.Description" String="The scale for the Maximum Power field"/>
+             <Annotation Term="OData.LongDescription" String="If this bit is cleared to ‘0’, then the scale of the Maximum Power field is in 0.01 Watts. If this bit is set to '1’, then the scale of the Maximum Power field is in 0.0001 Watts."/>
+            </Property>
+             <Property Name="MaxPowerScaleNo1" Type="Edm.Decimal" Nullable="false">
+             <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+             <Annotation Term="OData.Description" String="The scale for the Maximum Power field"/>
+             <Annotation Term="OData.LongDescription" String="If this bit is cleared to ‘0’, then the scale of the Maximum Power field is in 0.01 Watts. If this bit is set to '1’, then the scale of the Maximum Power field is in 0.0001 Watts ."/>
+           </Property>
+             <Property Name="MaxPowerStateNo0" Type="Edm.Decimal" Nullable="false">
+             <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+             <Annotation Term="OData.Description" String="Indicates the sustained maximum power consumed by the NVM subsystem in this power state"/>
+             <Annotation Term="OData.LongDescription" String="Indicates the sustained maximum power consumed by the NVM subsystem in this power state."/>
+           </Property>
+             <Property Name="MaxPowerStateNo1" Type="Edm.Decimal" Nullable="false">
+             <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+             <Annotation Term="OData.Description" String="Indicates the sustained maximum power consumed by the NVM subsystem in this power state"/>
+             <Annotation Term="OData.LongDescription" String="Indicates the sustained maximum power consumed by the NVM subsystem in this power state."/>
+           </Property>
+         </ComplexType>
+
+         <ComplexType Name="NVMeMISubSystemInformation" BaseType="Resource.OemObject">
+            <Annotation Term="OData.AdditionalProperties" Bool="true" />
+            <Annotation Term="OData.Description" String="Oem properties for NVMeMISubSystemInformation." />
+            <Annotation Term="OData.AutoExpand"/>
+           <Property Name="SubSystemHealthStatusPoll" Type="OemAMINVMeMIController.SubSystemHealthStatusPoll"/>
+           <Property Name="SubSystemInformation" Type="OemAMINVMeMIController.SubSystemInformation"/>
+         </ComplexType>
+
+
+     <ComplexType Name="SubSystemHealthStatusPoll" BaseType="Resource.OemObject">
+         <Annotation Term="OData.AdditionalProperties" Bool="true" />
+         <Annotation Term="OData.Description" String="Oem properties for NVMeMISubSystemInformation." />
+         <Annotation Term="OData.AutoExpand"/>
+         <Property Name="CompositeControllerStatus" Type="OemAMINVMeMIController.CompositeControllerStatus" Nullable="false"/>
+        <Property Name="CompositeTemperature" Type="Edm.Decimal" Nullable="false">
+          <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+          <Annotation Term="OData.Description" String="The CompositeTemperature of a Controller"/>
+          <Annotation Term="OData.LongDescription" String=" It represents the current CompositeTemperature of the Controller ."/>
+        </Property>
+
+        <Property Name="DriveFunctional" Type="Edm.Decimal" Nullable="false">
+          <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+          <Annotation Term="OData.Description" String="It indicate an NVM Subsystem is functional or not."/>
+          <Annotation Term="OData.LongDescription" String="If DriveFunctional is '1' indicates NVM Subsystem functional and '0' indicates failure."/>
+        </Property>
+
+      <Property Name="PDLU" Type="Edm.Decimal" Nullable="false">
+       <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+       <Annotation Term="OData.Description" String="This bit is set to ‘1’ when the Percentage Used field in the Controller Health Status Changed."/>
+       <Annotation Term="OData.LongDescription" String="This bit is set to ‘1’ when the Percentage Used field in the Controller Health Status Changed."/>
+      </Property>
+
+       <Property Name="Port0PCIeLinkActive" Type="Edm.Decimal" Nullable="false">
+         <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+         <Annotation Term="OData.Description" String="This bit is set to ‘1’ to indicate the first port’s PCIe link is up."/>
+         <Annotation Term="OData.LongDescription" String="This bit is set to ‘1’ to indicate the first port’s PCIe link is up."/>
+       </Property>
+
+       <Property Name="Port1PCIeLinkActive" Type="Edm.Decimal" Nullable="false">
+         <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+         <Annotation Term="OData.Description" String="This bit is set to ‘1’ to indicate the second port’s PCIe link is up ."/>
+         <Annotation Term="OData.LongDescription" String="This bit is set to ‘1’ to indicate the second port’s PCIe link is up."/>
+       </Property>
+
+       <Property Name="ResetNotRequired" Type="Edm.Decimal" Nullable="false">
+         <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+         <Annotation Term="OData.Description" String="The bit is set to '1' indicates ResetNotRequired and set to '0' indicates Reset Required"/>
+         <Annotation Term="OData.LongDescription" String="The bit is set to '1' indicates ResetNotRequired and set to '0' indicates Reset Required."/>
+       </Property>
+           <Property Name="SmartWarnings" Type="OemAMINVMeMIController.SmartWarnings" Nullable="false"/>
+        </ComplexType>
+
+
+     <ComplexType Name="CompositeControllerStatus" BaseType="Resource.OemObject">
+         <Annotation Term="OData.AdditionalProperties" Bool="true" />
+         <Annotation Term="OData.Description" String="Oem properties for NVMeMISubSystemInformation." />
+         <Annotation Term="OData.AutoExpand"/>
+        <Property Name="AvailableSpare" Type="Edm.Decimal" Nullable="false">
+ <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+          <Annotation Term="OData.Description" String="This bit indicates Controller Health Status Changed Flag transition."/>
+          <Annotation Term="OData.LongDescription" String="This bit indicates Controller Health Status Changed Flag transition."/>
+        </Property>
+        <Property Name="CompositeTemperatureChange" Type="Edm.Decimal" Nullable="false">
+          <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+          <Annotation Term="OData.Description" String="This indicates Composite Temperature Change in Controller ."/>
+          <Annotation Term="OData.LongDescription" String="This indicates Composite Temperature Change in Controller."/>
+        </Property>
+        <Property Name="ControllerEnableChangeOccured" Type="Edm.Decimal" Nullable="false">
+          <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+          <Annotation Term="OData.Description" String="This bit is set to '1' when Enable bit changes state."/>
+          <Annotation Term="OData.LongDescription" String="This bit is set to '1' when Enable bit changes state."/>
+        </Property>
+        <Property Name="ControllerFatalStatus" Type="Edm.Decimal" Nullable="false">
+          <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+          <Annotation Term="OData.Description" String="This bit indicates ControllerFatalStatus state."/>
+          <Annotation Term="OData.LongDescription" String="This bit indicates ControllerFatalStatus state."/>
+        </Property>
+        <Property Name="ControllerStatusChange" Type="Edm.Decimal" Nullable="false">
+          <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+          <Annotation Term="OData.Description" String="This bit is set when controller status changes one or more time."/>
+          <Annotation Term="OData.LongDescription" String="This bit is set when controller status changes one or more time."/>
+        </Property>
+        <Property Name="CriticalWarnings" Type="Edm.Decimal" Nullable="false">
+          <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+          <Annotation Term="OData.Description" String="This bit is set to ‘1’ when the CriticalWarning bit in the Controller Health Status Changed Flags transitions from ‘0’ to ‘1’ ."/>
+          <Annotation Term="OData.LongDescription" String="This bit is set to ‘1’ when the CriticalWarning bit in the Controller Health Status Changed Flags transitions from ‘0’ to ‘1’ ."/>
+        </Property>
+        <Property Name="FirmwareActivated" Type="Edm.Decimal" Nullable="false">
+          <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+          <Annotation Term="OData.Description" String="This bit is set to ‘1’ when a new firmware image is activated."/>
+          <Annotation Term="OData.LongDescription" String="This bit is set to ‘1’ when a new firmware image is activated."/>
+        </Property>
+        <Property Name="NVMSubSystemResetOccured" Type="Edm.Decimal" Nullable="false">
+          <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+          <Annotation Term="OData.Description" String="This bit is set to ‘1’ when the value of the NVM Subsystem Reset Occurred."/>
+          <Annotation Term="OData.LongDescription" String="This bit is set to ‘1’ when the value of the NVM Subsystem Reset Occurred."/>
+        </Property>
+        <Property Name="NameSpaceAttributeChange" Type="Edm.Decimal" Nullable="false">
+          <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+          <Annotation Term="OData.Description" String="This bit is set to ‘1’ when the Namespace Attribute Changed bit in the Controller."/>
+          <Annotation Term="OData.LongDescription" String="This bit is set to ‘1’ when the Namespace Attribute Changed bit in the Controller."/>
+        </Property>
+        <Property Name="PercentageUsed" Type="Edm.Decimal" Nullable="false">
+          <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+          <Annotation Term="OData.Description" String="This bit is set to ‘1’ when the Percentage Used field in the Controller Health Status Changed ."/>
+          <Annotation Term="OData.LongDescription" String="This bit is set to ‘1’ when the Percentage Used field in the Controller Health Status Changed ."/>
+        </Property>
+        <Property Name="Ready" Type="Edm.Decimal" Nullable="false">
+          <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+          <Annotation Term="OData.Description" String="This bit indicates controller is Ready or not."/>
+          <Annotation Term="OData.LongDescription" String="This bit indicates controller is Ready or not."/>
+        </Property>
+        <Property Name="ShutDownStatus" Type="Edm.Decimal" Nullable="false">
+          <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+          <Annotation Term="OData.Description" String="This bit indicates shutdown status of controller."/>
+          <Annotation Term="OData.LongDescription" String="This bit indicates shutdown status of controller."/>
+        </Property>
+   </ComplexType>
+
+
+     <ComplexType Name="SubSystemInformation" BaseType="Resource.OemObject">
+            <Annotation Term="OData.AdditionalProperties" Bool="true" />
+            <Annotation Term="OData.Description" String="Oem properties for NVMeMISubSystemInformation." />
+            <Annotation Term="OData.AutoExpand"/>
+           <Property Name="MajorVersion" Type="Edm.Decimal" Nullable="false">
+             <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+             <Annotation Term="OData.Description" String="major version of the specification."/>
+             <Annotation Term="OData.LongDescription" String="major version of the specification."/>
+           </Property>
+             <Property Name="MinorVersion" Type="Edm.Decimal" Nullable="false">
+             <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+             <Annotation Term="OData.Description" String="minor version of the specification."/>
+             <Annotation Term="OData.LongDescription" String="minor version of the specification."/>
+           </Property>
+           <Property Name="NoOfPorts" Type="Edm.Decimal" Nullable="false">
+             <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+             <Annotation Term="OData.Description" String="Number of ports."/>
+             <Annotation Term="OData.LongDescription" String="Number of ports."/>
+           </Property>
+     </ComplexType>
+
+       <ComplexType Name="SmartWarnings" BaseType="Resource.OemObject">
+            <Annotation Term="OData.AdditionalProperties" Bool="true" />
+            <Annotation Term="OData.Description" String="Oem properties for ProductInformation." />
+            <Annotation Term="OData.AutoExpand"/>
+           <Property Name="UnderThresh" Type="Edm.Decimal" Nullable="false">
+             <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+             <Annotation Term="OData.Description" String="The UnderThresh indicates  temperature threshold.."/>
+             <Annotation Term="OData.LongDescription" String="The UnderThresh indicates  temperature threshold."/>
+           </Property>
+        </ComplexType>
+
+
+         <ComplexType Name="VitalProductData" BaseType="Resource.OemObject">
+            <Annotation Term="OData.AdditionalProperties" Bool="true" />
+            <Annotation Term="OData.Description" String="Oem properties for VitalProductData." />
+ <Annotation Term="OData.AutoExpand"/>
+           <Property Name="MultiRecordInformation" Type="OemAMINVMeMIController.MultiRecordInformation"/>
+           <Property Name="ProductInformation" Type="OemAMINVMeMIController.ProductInformation"/>
+       </ComplexType>
+
+        <ComplexType Name="MultiRecordInformation" BaseType="Resource.OemObject">
+            <Annotation Term="OData.AdditionalProperties" Bool="true" />
+            <Annotation Term="OData.Description" String="Oem properties for MultiRecordInformation." />
+            <Annotation Term="OData.AutoExpand"/>
+           <Property Name="NVMeMultiRecord" Type="OemAMINVMeMIController.NVMeMultiRecord"/>
+           <Property Name="NVMePCIePortMultiRecord" Type="OemAMINVMeMIController.NVMePCIePortMultiRecord"/>
+       </ComplexType>
+
+
+    <ComplexType Name="NVMeMultiRecord" BaseType="Resource.OemObject">
+       <Annotation Term="OData.AdditionalProperties" Bool="false" />
+       <Annotation Term="OData.Description" String="data of NVMeMultiRecord." />
+       <Property Name="EPTFactor" Type="Edm.Decimal" Nullable="false">
+         <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+         <Annotation Term="OData.Description" String="This field indicates the form factor of the Management Endpoint."/>
+         <Annotation Term="OData.LongDescription" String="This field indicates the form factor of the Management Endpoint."/>
+       </Property>
+       <Property Name="InitialPowerSupplyReq1.8v" Type="Edm.Decimal" Nullable="false">
+         <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+         <Annotation Term="OData.Description" String="This indicates the initial 1.8V power supply requirements in Watts prior to receiving a Set Slot Power message."/>
+         <Annotation Term="OData.LongDescription" String="This indicates the initial 1.8V power supply requirements in Watts prior to receiving a Set Slot Power message."/>
+       </Property>
+       <Property Name="InitialPowerSupplyReq12v" Type="Edm.Decimal" Nullable="false">
+         <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+         <Annotation Term="OData.Description" String="This indicates the initial 12V power supply requirements in Watts prior to receiving a Set Slot Power message."/>
+         <Annotation Term="OData.LongDescription" String="This indicates the initial 12V power supply requirements in Watts prior to receiving a Set Slot Power message."/>
+       </Property>
+       <Property Name="InitialPowerSupplyReq3.3v" Type="Edm.Decimal" Nullable="false">
+         <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+         <Annotation Term="OData.Description" String="This indicates the initial 3.3V power supply requirements in Watts prior to receiving a Set Slot Power message."/>
+         <Annotation Term="OData.LongDescription" String="This indicates the initial 3.3V power supply requirements in Watts prior to receiving a Set Slot Power message."/>
+       </Property>
+       <Property Name="InitialPowerSupplyReq5v" Type="Edm.Decimal" Nullable="false">
+         <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+         <Annotation Term="OData.Description" String="This indicates the initial 5V power supply requirements in Watts prior to receiving a Set Slot Power message."/>
+         <Annotation Term="OData.LongDescription" String="This indicates the initial 5V power supply requirements in Watts prior to receiving a Set Slot Power message."/>
+       </Property>
+       <Property Name="MaxAuxPowerSupplyReq3.3v" Type="Edm.Decimal" Nullable="false">
+         <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+         <Annotation Term="OData.Description" String="This indicates the maximum 3.3V power supply requirements ."/>
+         <Annotation Term="OData.LongDescription" String="This indicates the maximum 3.3V power supply requirements in 10 mW units. A value of zero indicates that the power supply voltage is not used."/>
+       </Property>
+       <Property Name="MaxPowerSupplyReq1.8v" Type="Edm.Decimal" Nullable="false">
+         <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+         <Annotation Term="OData.Description" String="This field specifies the maximum 1.8V power supply requirements in Watts."/>
+         <Annotation Term="OData.LongDescription" String="This field specifies the maximum 1.8V power supply requirements in Watts."/>
+       </Property>
+       <Property Name="MaxPowerSupplyReq12v" Type="Edm.Decimal" Nullable="false">
+         <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+         <Annotation Term="OData.Description" String="This field specifies the maximum 12V power supply requirements in Watts."/>
+         <Annotation Term="OData.LongDescription" String="This field specifies the maximum 12V power supply requirements in Watts."/>
+       </Property>
+       <Property Name="MaxPowerSupplyReq3.3v" Type="Edm.Decimal" Nullable="false">
+         <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+         <Annotation Term="OData.Description" String="This field specifies the maximum 3.3V power supply requirements in Watts."/>
+         <Annotation Term="OData.LongDescription" String="This field specifies the maximum 3.3V power supply requirements in Watts."/>
+       </Property>
+       <Property Name="MaxPowerSupplyReq5v" Type="Edm.Decimal" Nullable="false">
+         <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+         <Annotation Term="OData.Description" String="This field specifies the maximum 5V power supply requirements in Watts."/>
+         <Annotation Term="OData.LongDescription" String="TThis field specifies the maximum 5V power supply requirements in Watts."/>
+       </Property>
+       <Property Name="MaxThermalLoad" Type="Edm.Decimal" Nullable="false">
+         <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+         <Annotation Term="OData.Description" String="This field specifies the maximum thermal load from the NVM Subsystem in Watts."/>
+         <Annotation Term="OData.LongDescription" String="This field specifies the maximum thermal load from the NVM Subsystem in Watts."/>
+       </Property>
+       <Property Name="RecordAreaVersion" Type="Edm.Decimal" Nullable="false">
+         <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+         <Annotation Term="OData.Description" String="This field indicates the version number of this multirecord."/>
+         <Annotation Term="OData.LongDescription" String="This field indicates the version number of this multirecord."/>
+       </Property>
+    </ComplexType>
+
+
+        <ComplexType Name="NVMePCIePortMultiRecord" BaseType="Resource.OemObject">
+        <Annotation Term="OData.AdditionalProperties" Bool="false" />
+        <Annotation Term="OData.Description" String="data of NVMePCIePortMultiRecord." />
+        <Property Name="MctpSupport" Type="Edm.Decimal" Nullable="false">
+          <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+          <Annotation Term="OData.Description" String="This field contains a bit vector that specifies the level of support for the NVMe Management Interface."/>
+          <Annotation Term="OData.LongDescription" String="This field contains a bit vector that specifies the level of support for the NVMe Management Interface."/>
+       </Property>
+        <Property Name="PCIeMaximumLinkWidth" Type="Edm.String" Nullable="false">
+          <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+          <Annotation Term="OData.Description" String="The maximum PCIe link width for this NVM Subsystem port."/>
+          <Annotation Term="OData.LongDescription" String="The maximum PCIe link width for this NVM Subsystem port."/>
+        </Property>
+        <Property Name="PCIePortInformation" Type="Edm.Decimal" Nullable="false">
+          <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+          <Annotation Term="OData.Description" String="This indicates information about the PCIe Ports in the device."/>
+          <Annotation Term="OData.LongDescription" String="his indicates information about the PCIe Ports in the device."/>
+        </Property>
+        <Property Name="PCIePortNumber" Type="Edm.Decimal" Nullable="false">
+          <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+          <Annotation Term="OData.Description" String="This field contains the PCIe port number."/>
+          <Annotation Term="OData.LongDescription" String="This field contains the PCIe port number. "/>
+        </Property>
+        <Property Name="PCIeRecordVersion" Type="Edm.Decimal" Nullable="false">
+          <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+          <Annotation Term="OData.Description" String="NVMe PCIe Port MultiRecord Area Version Number."/>
+          <Annotation Term="OData.LongDescription" String="NVMe PCIe Port MultiRecord Area Version Number."/>
+        </Property>
+        <Property Name="PCIeSupportedlinkSpeeds" Type="Edm.String" Nullable="false">
+          <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+          <Annotation Term="OData.Description" String="This field indicates a bit vector of link speeds supported by the PCIe port."/>
+          <Annotation Term="OData.LongDescription" String="This field contains a bit vector that specifies the PCIe clocking modes supported by the port."/>
+       </Property>
+	   <Property Name="RefClockCapability" Type="Edm.String" Nullable="false">
+          <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+          <Annotation Term="OData.Description" String="It specifies the PCIe clocking modes supported by the port."/>
+          <Annotation Term="OData.LongDescription" String="It specifies the PCIe clocking modes supported by the port."/>
+       </Property>
+      </ComplexType>
+
+       <ComplexType Name="ProductInformation" BaseType="Resource.OemObject">
+            <Annotation Term="OData.AdditionalProperties" Bool="true" />
+            <Annotation Term="OData.Description" String="Oem properties for ProductInformation." />
+            <Annotation Term="OData.AutoExpand"/>
+            <Property Name="IPMIVersion" Type="Edm.Decimal" Nullable="false">
+             <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+             <Annotation Term="OData.Description" String="IPMI Format Version"/>
+             <Annotation Term="OData.LongDescription" String="IPMI Format Version"/>
+           </Property>
+        </ComplexType>
+       </Schema>
+   </edmx:DataServices>
+</edmx:Edmx>
+
+
+
-- 
2.34.1

