From 03e05b25bc696c40a5b815b0fdffc77a11de2e77 Mon Sep 17 00:00:00 2001
From: Pranoy Goru <gorumanip@ami.com>
Date: Sun, 13 Aug 2023 21:31:38 +0530
Subject: [PATCH 91/91] Integrated NVME Interface

Description
Added NVME interface in redfish with backend

Test case:

busctl tree xyz.openbmc_project.NVMEMgt
`-/xyz
  `-/xyz/openbmc_project
    `-/xyz/openbmc_project/Nvme
      `-/xyz/openbmc_project/Nvme/0

1) Get NVME device
https://x.x.x.x/redfish/v1/Systems/system/Storage

{
    "@odata.id": "/redfish/v1/Systems/system/Storage",
    "@odata.type": "#StorageCollection.StorageCollection",
    "Members": [
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/1"
        },
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/Nvme"
        }
    ],
    "Members@odata.count": 2,
    "Name": "Storage Collection"
}

2) Get Nvme Drive

https://x.x.x.x/redfish/v1/Systems/system/Storage/Nvme

{
    "@odata.id": "/redfish/v1/Systems/system/Storage/Nvme",
    "@odata.type": "#Storage.v1_7_1.Storage",
    "Controllers": {
        "@odata.id": "/redfish/v1/Systems/system/Storage/Nvme/Controllers"
    },
    "Drives": [
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/Nvme/Drives/0"
        }
    ],
    "Drives@odata.count": 1,
    "Id": "Nvme",
    "Name": "Storage"
}

3) Get Nvme Drive instance

https://x.x.x.x/redfish/v1/Systems/system/Storage/Nvme/Drive/0

{
    "@odata.id": "/redfish/v1/Systems/system/Storage/Nvme/Drives/0",
    "@odata.type": "#Drive.v1_7_0.Drive",
    "Id": "0",
    "Links": {
        "Chassis": {
            "@odata.id": "/redfish/v1/Chassis/AC_Baseboard"
        }
    },
    "Manufacturer": "INTEL",
    "Model": "P5800X",
    "Name": "0",
    "PartNumber": "INTEL SSDPF21Q400GB",
    "SerialNumber": "PHAL14210009400AGN"
}

4) Get Nvme Controllers

https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Nvme/Controllers

{
    "@odata.id": "/redfish/v1/Systems/system/Storage/Nvme/Controllers",
    "@odata.type": "#StorageControllerCollection.StorageControllerCollection",
    "Description": "Collections of storage controllers",
    "Members": [
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/Nvme/Controllers/0"
        }
    ],
    "Members@odata.count": 1,
    "Name": "Storage Controllers Collections"
}

5) Get Nvme Controllers instance

https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Nvme/Controllers/0

{
    "@odata.id": "/redfish/v1/Systems/system/Storage/Nvme/Controllers/0",
    "@odata.type": "#StorageController.v1_0_0.StorageController",
    "Id": "0",
    "Links": {
        "Chassis": {
            "@odata.id": "/redfish/v1/Chassis/AC_Baseboard"
        }
    },
    "Manufacturer": "INTEL",
    "Model": "P5800X",
    "NVMeControllerProperties": {
        "NVMeSMARTCriticalWarnings": {
            "MediaInReadOnly": "false",
            "OverallSubsystemDegraded": "false",
            "PowerBackupFailed": "false",
            "SpareCapacityWornOut": "false"
        }
    },
    "Name": "NVME controller",
    "Oem": {
        "Ami": {
            "@odata.type": "#AMINVMeMIController.v1_0_0.AMINVMeMIController",
            "NVMeMISubSystemInformation": {
                "SubSystemHealthStatusPoll": {
                    "CompositeControllerStatus": {
                        "AvailableSpare": 0,
                        "CompositeTemperatureChange": 1,
                        "ControllerEnableChangeOccured": 1,
                        "ControllerFatalStatus": 0,
                        "ControllerStatusChange": 1,
                        "CriticalWarnings": 0,
                        "FirmwareActivated": 0,
                        "NVMSubSystemResetOccured": 0,
                        "NameSpaceAttributeChange": 0,
                        "PercentageUsed": 0,
                        "Ready": 1,
                        "ShutDownStatus": 0
                    },
                    "CompositeTemperature": 45,
                    "DriveFunctional": 1,
                    "PDLU": 0,
                    "Port0PCIeLinkActive": 1,
                    "Port1PCIeLinkActive": 0,
                    "ResetNotRequired": 1,
                    "SmartWarnings": {
                        "UnderThresh": 0
                    }
                },
                "SubSystemInformation": {
                    "MajorVersion": 1,
                    "MinorVersion": 1,
                    "NoOfPorts": 2
                }
            },
            "VitalProductData": {
                "MultiRecordInformation": {
                    "NVMeMultiRecord": {
                        "EPTFactor": 17,
                        "InitialPowerSupplyReq1.8v": 0,
                        "InitialPowerSupplyReq12v": 0,
                        "InitialPowerSupplyReq3.3v": 0,
                        "InitialPowerSupplyReq5v": 0,
                        "MaxAuxPowerSupplyReq3.3v": 0,
                        "MaxPowerSupplyReq1.8v": 0,
                        "MaxPowerSupplyReq12v": 0,
                        "MaxPowerSupplyReq3.3v": 0,
                        "MaxPowerSupplyReq5v": 0,
                        "MaxThermalLoad": 0,
                        "RecordAreaVersion": 0
                    },
                    "NVMePCIePortMultiRecord": {
                        "MctpSupport": 1,
                        "PCIeMaximumLinkWidth": "PCIe x4",
                        "PCIePortInformation": 1,
                        "PCIePortNumber": 0,
                        "PCIeRecordVersion": 130,
                        "PCIeSupportedlinkSpeeds": "2.5 GT/s, 5.0 GT/s, 8.0 GT/s, 16.0 GT/s",
                        "RefClockCapability": "Separate Reference with no SSC"
                    }
                },
                "ProductInformation": {
                    "IPMIVersion": 1
                }
            }
        }
    },
    "PartNumber": "INTEL SSDPF21Q400GB",
    "Ports": {
        "@odata.id": "/redfish/v1/Systems/system/Storage/Nvme/Controllers/0/Ports"
    },
    "SerialNumber": "PHAL14210009400AGN",
    "Status": {
        "Health": "OK",
        "HealthRollup": "OK",
        "State": "Enabled"
    }
}

6) Get Nvme Ports

https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Nvme/Controllers/0/Ports

{
    "@odata.id": "/redfish/v1/Systems/system/Storage/Nvme/Controllers/0/Ports",
    "@odata.type": "#PortCollection.PortCollection",
    "Description": "The Collections of Ports",
    "Members": [
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/Nvme/Controllers/0/Ports/0"
        },
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/Nvme/Controllers/0/Ports/1"
        }
    ],
    "Members@odata.count": 2,
    "Name": "Port Collections"
}

7) Get Nvme Ports instance

if port type is PCIE then

https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Nvme/Controllers/0/Ports/0

{
    "@odata.id": "/redfish/v1/Systems/system/Storage/Nvme/Controllers/0/Ports/0",
    "@odata.type": "#Port.v1_3_0.Port",
    "Id": "0",
    "Name": "PCIe",
    "Oem": {
        "Ami": {
            "@odata.type": "@AMINVMeMIPort.v1_0_0.AMINVMeMIPort",
            "PortInformation": {
                "CurrentLinkSpeed": "16.0 GT/s",
                "MaxLinkWidth": "PCIe x4",
                "MaxMCTPTransUnitSize": 0,
                "MaxPayloadSize": "512 bytes",
                "NegotiatedLinkWidth": "PCIe x4",
                "PortNo": "0",
                "PortStatus": "Active",
                "PortType": "PCIe",
                "SupportedLinkSpeeds": "2.5 GT/s, 5.0 GT/s, 8.0 GT/s, 16.0 GT/s"
            }
        }
    }
}

if port tyoe is Inactive then

https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Nvme/Controllers/0/Ports/1

{
    "@odata.id": "/redfish/v1/Systems/system/Storage/Nvme/Controllers/0/Ports/1",
    "@odata.type": "#Port.v1_3_0.Port",
    "Id": "1",
    "Name": "Inactive",
    "Oem": {
        "Ami": {
            "@odata.type": "@AMINVMeMIPort.v1_0_0.AMINVMeMIPort",
            "PortInformation": {
                "PortNo": "1",
                "PortStatus": "Inactive",
                "PortType": "N/A"
            }
        }
    }
}

If port type is Smbus then

Backend need to add

Signed-off-by: Pranoy Goru <gorumanip@ami.com>
---
 redfish-core/include/redfish.hpp  |    8 +
 redfish-core/lib/storage.hpp      |   15 +-
 redfish-core/lib/storage_nvme.hpp | 1597 +++++++++++++++++++++++++++++
 3 files changed, 1614 insertions(+), 6 deletions(-)
 create mode 100644 redfish-core/lib/storage_nvme.hpp

diff --git a/redfish-core/include/redfish.hpp b/redfish-core/include/redfish.hpp
index 41144465..570346a7 100644
--- a/redfish-core/include/redfish.hpp
+++ b/redfish-core/include/redfish.hpp
@@ -113,6 +113,14 @@ class RedfishService
         requestRoutesStorageCollection(app);
         requestRoutesStorage(app);
         requestRoutesDrive(app);
+
+        requestRoutesNvmeStorage(app);
+        requestRoutesNvmeDrive(app);
+        requestRoutesNvmeControllers(app);
+        requestRoutesNvmeControllersInstance(app);
+        requestRoutesNvmePorts(app);
+        requestRoutesNvmePortsInstance(app);
+
         requestRoutesCable(app);
         requestRoutesCableCollection(app);
 #ifdef BMCWEB_INSECURE_ENABLE_REDFISH_FW_TFTP_UPDATE
diff --git a/redfish-core/lib/storage.hpp b/redfish-core/lib/storage.hpp
index 3bc8419b..0639886c 100644
--- a/redfish-core/lib/storage.hpp
+++ b/redfish-core/lib/storage.hpp
@@ -25,6 +25,7 @@
 #include "redfish_util.hpp"
 #include "registries/privilege_registry.hpp"
 #include "utils/dbus_utils.hpp"
+#include "storage_nvme.hpp"
 
 #include <boost/system/error_code.hpp>
 #include <boost/url/format.hpp>
@@ -60,12 +61,14 @@ inline void requestRoutesStorageCollection(App& app)
         asyncResp->res.jsonValue["@odata.id"] =
             "/redfish/v1/Systems/system/Storage";
         asyncResp->res.jsonValue["Name"] = "Storage Collection";
-        nlohmann::json::array_t members;
-        nlohmann::json::object_t member;
-        member["@odata.id"] = "/redfish/v1/Systems/system/Storage/1";
-        members.emplace_back(member);
-        asyncResp->res.jsonValue["Members"] = std::move(members);
-        asyncResp->res.jsonValue["Members@odata.count"] = 1;
+       nlohmann::json& storageControllerArray =
+               asyncResp->res.jsonValue["Members"];
+       storageControllerArray.push_back(
+               {{"@odata.id", "/redfish/v1/Systems/system/Storage/1"}});
+       nlohmann::json& count =
+               asyncResp->res.jsonValue["Members@odata.count"];
+       count = 1;
+       getNvmeDevices(asyncResp, count, storageControllerArray);
         });
 }
 
diff --git a/redfish-core/lib/storage_nvme.hpp b/redfish-core/lib/storage_nvme.hpp
new file mode 100644
index 00000000..a5f05627
--- /dev/null
+++ b/redfish-core/lib/storage_nvme.hpp
@@ -0,0 +1,1597 @@
+/*
+// Copyright (c) 2021 AMI Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+*/
+#pragma once
+
+#include "openbmc_dbus_rest.hpp"
+
+#include <app.hpp>
+#include <registries/privilege_registry.hpp>
+
+namespace redfish
+{
+
+using GetSubTreeType = std::vector<std::pair<
+        std::string,
+        std::vector<std::pair<std::string, std::vector<std::string>>>>>;
+
+std::unordered_map<uint8_t, const std::string> linkWidth = {
+    {0, "InActive"}, {1, "PCIe x1"},   {2, "PCIe x2"},   {4, "PCIe x4"},
+    {8, "PCIe x8"},  {12, "PCIe x12"}, {16, "PCIe x16"}, {32, "PCIe x32"}};
+
+std::unordered_map<int, const std::string> linkSpeed = {
+    {0, "InActive"}, {1, "2.5 GT/s"}, {2, "5.0 GT/s"}, {3, "2.5 GT/s, 5.0 GT/s"},
+    {4, "8.0 GT/s"}, {5, "2.5 GT/s, 8.0 GT/s"}, {6, "5.0 GT/s, 8.0 GT/s"},
+    {7, "2.5 GT/s, 5.0 GT/s, 8.0 GT/s"}, {8, "16.0 GT/s"}, 
+    {9, "2.5 GT/s, 16.0 GT/s"}, {10, "5.0 GT/s, 16.0 GT/s"}, {11, "2.5 GT/s, 5.0 GT/s, 16.0 GT/s"},
+    {12, "8.0 GT/s , 16.0 GT/s"}, {13, "2.5 GT/s, 8.0 GT/s, 16.0 GT/s"}, {14, "5.0 GT/s, 8.0 GT/s, 16.0 GT/s"},
+    {15, "2.5 GT/s, 5.0 GT/s, 8.0 GT/s, 16.0 GT/s"}, {16, "32.0 GT/s"},
+    {17, "2.5 GT/s, 32.0 GT/s"}, {18, "5.0 GT/s, 32.0 GT/s"}, {19, "2.5 GT/s, 5.0 GT/s, 32.0 GT/s"}};
+
+std::unordered_map<int, const std::string> curtLinkSpeed = {
+    {0, "InActive"},   {1, "2.5 GT/s"}, {2, "5.0 GT/s"}, {3, "8.0 GT/s"},
+    {4, "16.0 GT/s"}, {5, "32 GT/s"}};
+
+std::unordered_map<uint8_t, const std::string> payloadSize = {
+    {0, "128 bytes"}, {1, "256 bytes"},   {2, "512 bytes"},   {3, "1024 bytes"},
+    {4, "2048 bytes"},  {5, "4096 bytes"}};
+
+std::unordered_map<uint8_t, const std::string> refClock = {
+    {0, "Common Reference"}, {1, "Separate Reference with no SSC"}, 
+    {2, "Separate Reference with SSC"}, {3, "Reference if provided and otherwise uses SRIS"}};
+
+inline void getNvmeDevices(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
+                           nlohmann::json& count,
+                           nlohmann::json& storageControllerArray)
+{
+    crow::connections::systemBus->async_method_call(
+        [asyncResp, &count,
+         &storageControllerArray](const boost::system::error_code ec,
+                                  const std::variant<uint32_t>& value) {
+            if (ec)
+            {
+                BMCWEB_LOG_DEBUG << "failed to get property Value  " << ec;
+//              messages::internalError(asyncResp->res);
+                return;
+            }
+	    
+            const uint32_t* s = std::get_if<uint32_t>(&value);
+
+            if (s != nullptr && *s != 0)
+            {
+                storageControllerArray.push_back(
+                    {{"@odata.id", "/redfish/v1/Systems/system/Storage/Nvme"}});
+                count = storageControllerArray.size();
+            }
+        },
+        "xyz.openbmc_project.NVMEMgt", "/xyz/openbmc_project/Nvme",
+        "org.freedesktop.DBus.Properties", "Get", "xyz.openbmc_project.Nvme",
+        "Count");
+}
+
+inline void requestRoutesNvmeStorage(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/Nvme/")
+        .privileges(redfish::privileges::getStorage)
+        .methods(boost::beast::http::verb::get)(
+            [](const crow::Request&,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp) {
+                asyncResp->res.jsonValue["@odata.type"] =
+                    "#Storage.v1_7_1.Storage";
+                asyncResp->res.jsonValue["@odata.id"] =
+                    "/redfish/v1/Systems/system/Storage/Nvme";
+                asyncResp->res.jsonValue["Name"] = "Storage";
+                asyncResp->res.jsonValue["Id"] = "Nvme";
+                asyncResp->res.jsonValue["Controllers"]["@odata.id"] =
+                    "/redfish/v1/Systems/system/Storage/Nvme/Controllers";
+                crow::connections::systemBus->async_method_call(
+                    [asyncResp](const boost::system::error_code ec,
+                                const std::vector<std::string>& storageList) {
+                        nlohmann::json& storageArray =
+                            asyncResp->res.jsonValue["Drives"];
+                        storageArray = nlohmann::json::array();
+                        auto& count =
+                            asyncResp->res.jsonValue["Drives@odata.count"];
+                        count = 0;
+
+                        if (ec)
+                        {
+                            BMCWEB_LOG_ERROR << "Drive mapper call error";
+                            messages::internalError(asyncResp->res);
+                            return;
+                        }
+
+                        for (const std::string& objpath : storageList)
+                        {
+                            std::size_t lastPos = objpath.rfind('/');
+                            if (lastPos == std::string::npos ||
+                                (objpath.size() <= lastPos + 1))
+                            {
+                                BMCWEB_LOG_ERROR << "Failed to find '/' in "
+                                                 << objpath;
+                                continue;
+                            }
+
+                            storageArray.push_back(
+                                {{"@odata.id",
+                                  "/redfish/v1/Systems/system/Storage/Nvme/"
+                                  "Drives/" +
+                                      objpath.substr(lastPos + 1)}});
+                        }
+                        count = storageArray.size();
+                    },
+                    "xyz.openbmc_project.ObjectMapper",
+                    "/xyz/openbmc_project/object_mapper",
+                    "xyz.openbmc_project.ObjectMapper", "GetSubTreePaths",
+                    "/xyz/openbmc_project/Nvme", 0,
+                    std::array<const char*, 1>{"xyz.openbmc_project.Nvme"});
+            });
+}
+
+inline void getControllers (const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
+{
+    const std::array<std::string_view, 1> interfaces = {
+        "xyz.openbmc_project.Nvme"};
+    dbus::utility::getSubTreePaths(
+        "/xyz/openbmc_project/Nvme", 0, interfaces,
+        [asyncResp ](
+            const boost::system::error_code& ec,
+            const dbus::utility::MapperGetSubTreePathsResponse& controllerList) {
+        if (ec)
+        {
+            BMCWEB_LOG_ERROR << "Controller mapper call error";
+            messages::internalError(asyncResp->res);
+            return;
+        }
+
+        nlohmann::json& controllerArray = asyncResp->res.jsonValue["Members"];
+        controllerArray = nlohmann::json::array();
+        auto& count = asyncResp->res.jsonValue["Members@odata.count"];
+        count = 0;
+
+        for (const std::string& controller : controllerList)
+        {
+            sdbusplus::message::object_path object(controller);
+            if (object.filename().empty())
+            {
+                BMCWEB_LOG_ERROR << "Failed to find filename in " << controller;
+                return;
+            }
+
+            nlohmann::json::object_t controllerJson;
+            controllerJson["@odata.id"] = boost::urls::format(
+                "/redfish/v1/Systems/system/Storage/Nvme/Controllers/{}",
+                object.filename());
+            controllerArray.emplace_back(std::move(controllerJson));
+        }
+
+        count = controllerArray.size();
+        });
+}
+
+inline void requestRoutesNvmeControllers(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/Nvme/Controllers")
+        .privileges(redfish::privileges::getStorage)
+        .methods(boost::beast::http::verb::get)(
+            [](const crow::Request&,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp) {
+                asyncResp->res.jsonValue["@odata.type"] =
+                    "#StorageControllerCollection.StorageControllerCollection";
+                asyncResp->res.jsonValue["@odata.id"] =
+                    "/redfish/v1/Systems/system/Storage/Nvme/Controllers";
+                asyncResp->res.jsonValue["Name"] = "Storage Controllers Collections";
+                asyncResp->res.jsonValue["Description"] = "Collections of storage controllers";
+                getControllers(asyncResp);           
+            });
+}
+
+inline void getControllerAsset(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                          const std::string& connectionName,
+                          const std::string& path,
+                          const std::string& interface)
+{
+    sdbusplus::asio::getAllProperties(
+        *crow::connections::systemBus, connectionName, path, interface,
+        [asyncResp](const boost::system::error_code& ec,
+                    const std::vector<
+                        std::pair<std::string, dbus::utility::DbusVariantType>>&
+                        propertiesList) {
+        if (ec)
+        {
+            // this interface isn't necessary
+            return;
+        }
+
+        const std::string* partNumber = nullptr;
+        const std::string* serialNumber = nullptr;
+        const std::string* manufacturer = nullptr;
+        const std::string* model = nullptr;
+        const uint8_t* ipmiVersion = nullptr;
+
+        const bool success = sdbusplus::unpackPropertiesNoThrow(
+            dbus_utils::UnpackErrorPrinter(), propertiesList, "partModel",
+            partNumber, "prdSerial", serialNumber, "manufacturer",
+            manufacturer, "prdName", model,
+            "ipmiVer", ipmiVersion);
+
+        if (!success)
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+
+        if (partNumber != nullptr)
+        {
+            asyncResp->res.jsonValue["PartNumber"] = *partNumber;
+        }
+
+        if (serialNumber != nullptr)
+        {
+            asyncResp->res.jsonValue["SerialNumber"] = *serialNumber;
+        }
+
+        if (manufacturer != nullptr)
+        {
+            asyncResp->res.jsonValue["Manufacturer"] = *manufacturer;
+        }
+
+        if (model != nullptr)
+        {
+            asyncResp->res.jsonValue["Model"] = *model;
+        }
+
+        if (ipmiVersion != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["VitalProductData"]
+                            ["ProductInformation"]["IPMIVersion"] 
+                                = *ipmiVersion;
+        }
+        });
+}
+
+inline void getSubSystemInfo(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                          const std::string& connectionName,
+                          const std::string& path,
+                          const std::string& interface)
+{
+    sdbusplus::asio::getAllProperties(
+        *crow::connections::systemBus, connectionName, path, interface,
+        [asyncResp](const boost::system::error_code& ec,
+                    const std::vector<
+                        std::pair<std::string, dbus::utility::DbusVariantType>>&
+                        propertiesList) {
+        if (ec)
+        {
+            // this interface isn't necessary
+            return;
+        }
+        const uint8_t* majorVer = nullptr;
+        const uint8_t* minorVer = nullptr;
+        const uint8_t* numOfPorts = nullptr;
+
+        const bool success = sdbusplus::unpackPropertiesNoThrow(
+            dbus_utils::UnpackErrorPrinter(), propertiesList, "majorVer",
+            majorVer, "minorVer", minorVer, "numOfPorts",
+            numOfPorts);
+        if (!success)
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+
+        if (majorVer != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                            ["SubSystemInformation"]["MajorVersion"] = *majorVer;
+        }
+        if (minorVer != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                            ["SubSystemInformation"]["MinorVersion"] = *minorVer;
+        }
+        if (numOfPorts != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                            ["SubSystemInformation"]["NoOfPorts"] = *numOfPorts;
+        }
+        });
+}
+
+inline void getNVMeControllerProperties(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                          const std::string& connectionName,
+                          const std::string& path,
+                          const std::string& interface)
+{
+    sdbusplus::asio::getAllProperties(
+        *crow::connections::systemBus, connectionName, path, interface,
+        [asyncResp](const boost::system::error_code& ec,
+                    const std::vector<
+                        std::pair<std::string, dbus::utility::DbusVariantType>>&
+                        propertiesList) {
+        if (ec)
+        {
+            // this interface isn't necessary
+            return;
+        }
+        const uint8_t* mediaInReadOnly= nullptr;
+        const uint8_t* overallSubsystemDegraded = nullptr;
+        const uint8_t* powerBackupFailed = nullptr;
+        const uint8_t* spareCapacityWornOut = nullptr;
+        const bool success = sdbusplus::unpackPropertiesNoThrow(
+            dbus_utils::UnpackErrorPrinter(), propertiesList, "rdOnly",
+            mediaInReadOnly, "reliabDegraded", overallSubsystemDegraded,
+            "volaMemBkFail", powerBackupFailed, "ccsSpare", spareCapacityWornOut);
+        if (!success)
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+        if(mediaInReadOnly != nullptr)
+        {
+            if (*mediaInReadOnly == 0)
+            {
+                asyncResp->res.jsonValue["NVMeControllerProperties"]
+                            ["NVMeSMARTCriticalWarnings"] ["MediaInReadOnly"] 
+                                = "false";
+            } else
+            {
+                asyncResp->res.jsonValue["NVMeControllerProperties"]
+                            ["NVMeSMARTCriticalWarnings"] ["MediaInReadOnly"]
+                                = "true";
+            }
+        }
+        if(overallSubsystemDegraded != nullptr)
+        {
+            if (*overallSubsystemDegraded == 0)
+            {
+                asyncResp->res.jsonValue["NVMeControllerProperties"]
+                            ["NVMeSMARTCriticalWarnings"] ["OverallSubsystemDegraded"] 
+                                = "false";
+            } else
+            {
+                asyncResp->res.jsonValue["NVMeControllerProperties"]
+                            ["NVMeSMARTCriticalWarnings"] ["OverallSubsystemDegraded"]
+                                = "true";
+            }
+        }
+        if(powerBackupFailed != nullptr)
+        {
+            if (*powerBackupFailed == 0)
+            {
+                asyncResp->res.jsonValue["NVMeControllerProperties"]
+                            ["NVMeSMARTCriticalWarnings"] ["PowerBackupFailed"] 
+                                = "false";
+            } else
+            {
+                asyncResp->res.jsonValue["NVMeControllerProperties"]
+                            ["NVMeSMARTCriticalWarnings"] ["PowerBackupFailed"]
+                                = "true";
+            }
+        }
+        if(spareCapacityWornOut != nullptr)
+        {
+            if (*spareCapacityWornOut == 0)
+            {
+                asyncResp->res.jsonValue["NVMeControllerProperties"]
+                            ["NVMeSMARTCriticalWarnings"] ["SpareCapacityWornOut"] 
+                                = "false";
+            } else
+            {
+                asyncResp->res.jsonValue["NVMeControllerProperties"]
+                            ["NVMeSMARTCriticalWarnings"] ["SpareCapacityWornOut"]
+                                = "true";
+            }
+        }          
+        });
+}
+
+inline void getSubSystemHealthStatus(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                          const std::string& connectionName,
+                          const std::string& path,
+                          const std::string& interface)
+{
+    sdbusplus::asio::getAllProperties(
+        *crow::connections::systemBus, connectionName, path, interface,
+        [asyncResp](const boost::system::error_code& ec,
+                    const std::vector<
+                        std::pair<std::string, dbus::utility::DbusVariantType>>&
+                        propertiesList) {
+        if (ec)
+        {
+            // this interface isn't necessary
+            return;
+        }
+        const uint8_t* availableSpare = nullptr;
+        const uint8_t* compositeTemperatureChange = nullptr;
+        const uint8_t* controllerEnableChangeOccured = nullptr;
+        const uint8_t* controllerFatalStatus = nullptr;
+        const uint8_t* controllerStatusChange = nullptr;
+        const uint8_t* criticalWarnings = nullptr;
+        const uint8_t* firmwareActivated = nullptr;
+        const uint8_t* nvmSubSystemResetOccured = nullptr;
+        const uint8_t* nameSpaceAttributeChange = nullptr;
+        const uint8_t* percentageUsed = nullptr;
+        const uint8_t* ready = nullptr;
+        const uint8_t* shutDownStatus = nullptr;
+        const uint8_t* compositeTemperature = nullptr;
+        const uint8_t* driveFunctional = nullptr;
+        const uint8_t* pdlu = nullptr;
+        const uint8_t* port0PCIeLinkActive= nullptr;
+        const uint8_t* port1PCIeLinkActive= nullptr;
+        const uint8_t* resetNotRequired= nullptr;
+        const uint8_t* underThresh= nullptr;
+
+        const bool success = sdbusplus::unpackPropertiesNoThrow(
+            dbus_utils::UnpackErrorPrinter(), propertiesList, "ccsSpare",
+            availableSpare, "ccsCTEMP", compositeTemperatureChange, 
+            "ccsCECO", controllerEnableChangeOccured,
+            "ccsCtlFatal", controllerFatalStatus,
+            "ccsCSTS", controllerStatusChange,
+            "critWarn", criticalWarnings,"ccsFA", firmwareActivated, 
+            "ccsNSSRO", nvmSubSystemResetOccured ,
+            "ccsNAC", nameSpaceAttributeChange, "ccsPDLU", percentageUsed,
+            "ccsReady", ready, "ccsShutdownSt", shutDownStatus,
+            "compTemp", compositeTemperature, "nssDF", driveFunctional,
+            "pdlu", pdlu, "nssP0LA", port0PCIeLinkActive,
+            "nssP1LA", port1PCIeLinkActive, "nssRNR", resetNotRequired,
+            "tempAbUndThresh", underThresh);
+        if (!success)
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+        if (availableSpare != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                            ["SubSystemHealthStatusPoll"]["CompositeControllerStatus"]
+                            ["AvailableSpare"] = *availableSpare;
+        }
+        if (compositeTemperatureChange != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                            ["SubSystemHealthStatusPoll"]["CompositeControllerStatus"]
+                            ["CompositeTemperatureChange"] = *compositeTemperatureChange;
+        }
+        if (controllerEnableChangeOccured != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                            ["SubSystemHealthStatusPoll"]["CompositeControllerStatus"]
+                            ["ControllerEnableChangeOccured"] = *controllerEnableChangeOccured;
+        }
+        if (controllerFatalStatus != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                            ["SubSystemHealthStatusPoll"]["CompositeControllerStatus"]
+                            ["ControllerFatalStatus"] = *controllerFatalStatus;
+        }
+        if (controllerStatusChange != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                            ["SubSystemHealthStatusPoll"]["CompositeControllerStatus"]
+                            ["ControllerStatusChange"] = *controllerStatusChange;
+        }
+        if (criticalWarnings != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                            ["SubSystemHealthStatusPoll"]["CompositeControllerStatus"]
+                            ["CriticalWarnings"] = *criticalWarnings;
+        }
+        if (firmwareActivated != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                            ["SubSystemHealthStatusPoll"]["CompositeControllerStatus"]
+                            ["FirmwareActivated"] = *firmwareActivated;
+        }
+        if (nvmSubSystemResetOccured != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                            ["SubSystemHealthStatusPoll"]["CompositeControllerStatus"]
+                            ["NVMSubSystemResetOccured"] = *nvmSubSystemResetOccured;
+        }
+        if (nameSpaceAttributeChange != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                            ["SubSystemHealthStatusPoll"]["CompositeControllerStatus"]
+                            ["NameSpaceAttributeChange"] = *nameSpaceAttributeChange;
+        }
+        if (percentageUsed != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                            ["SubSystemHealthStatusPoll"]["CompositeControllerStatus"]
+                            ["PercentageUsed"] = *percentageUsed;
+        }
+        if (ready != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                            ["SubSystemHealthStatusPoll"]["CompositeControllerStatus"]
+                            ["Ready"] = *ready;
+        }
+        if (shutDownStatus != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                            ["SubSystemHealthStatusPoll"]["CompositeControllerStatus"]
+                            ["ShutDownStatus"] = *shutDownStatus;
+        }
+        if (compositeTemperature != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                            ["SubSystemHealthStatusPoll"]["CompositeTemperature"]
+                             = *compositeTemperature;
+        }
+        if (driveFunctional != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                            ["SubSystemHealthStatusPoll"]["DriveFunctional"]
+                             = *driveFunctional;
+        }
+        if (pdlu != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                            ["SubSystemHealthStatusPoll"]["PDLU"]
+                             = *pdlu;
+        }
+        if (port0PCIeLinkActive != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                            ["SubSystemHealthStatusPoll"]["Port0PCIeLinkActive"]
+                             = *port0PCIeLinkActive;
+        }
+        if (port1PCIeLinkActive != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                            ["SubSystemHealthStatusPoll"]["Port1PCIeLinkActive"]
+                             = *port1PCIeLinkActive;
+        }
+        if (resetNotRequired != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                            ["SubSystemHealthStatusPoll"]["ResetNotRequired"]
+                             = *resetNotRequired;
+        }
+        if (underThresh != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["NVMeMISubSystemInformation"]
+                            ["SubSystemHealthStatusPoll"]["SmartWarnings"]
+                            ["UnderThresh"] = *underThresh;
+        }       
+        });
+}
+
+inline void getVPDNVMeMultiRecordInfo(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                          const std::string& connectionName,
+                          const std::string& path,
+                          const std::string& interface)
+{
+    sdbusplus::asio::getAllProperties(
+        *crow::connections::systemBus, connectionName, path, interface,
+        [asyncResp](const boost::system::error_code& ec,
+                    const std::vector<
+                        std::pair<std::string, dbus::utility::DbusVariantType>>&
+                        propertiesList) {
+        if (ec)
+        {
+            // this interface isn't necessary
+            return;
+        }
+        const uint8_t* eptFactor = nullptr;
+        const uint8_t* initialPowerSupplyReq18v = nullptr;
+        const uint8_t* initialPowerSupplyReq12v = nullptr;
+        const uint8_t* initialPowerSupplyReq33v = nullptr;
+        const uint8_t* initialPowerSupplyReq5v = nullptr;
+        const uint8_t* maxAuxPowerSupplyReq33v = nullptr;
+        const uint8_t* maxPowerSupplyReq18v = nullptr;
+        const uint8_t* maxPowerSupplyReq12v = nullptr;
+        const uint8_t* maxPowerSupplyReq33v = nullptr;
+        const uint8_t* maxPowerSupplyReq5v = nullptr;
+        const uint8_t* maxThermalLoad = nullptr;
+        const uint8_t* recordAreaVersion = nullptr;
+//        const std::vector<uint8_t*> totalNVMCapacity = nullptr;
+
+        const bool success = sdbusplus::unpackPropertiesNoThrow(
+            dbus_utils::UnpackErrorPrinter(), propertiesList, 
+            "mgmtEptFormFactor",eptFactor, "initPwrSupReq1_8V", initialPowerSupplyReq18v,
+            "initPwrSupReq12V", initialPowerSupplyReq12v, 
+            "initPwrSupReq3_3V", initialPowerSupplyReq33v,
+            "initPwrSupReq5V", initialPowerSupplyReq5v,
+            "maxAuxPwrSupReq3_3V", maxAuxPowerSupplyReq33v,
+            "maxPwrSupReq1_8V", maxPowerSupplyReq18v,
+            "maxPwrSupReq12V", maxPowerSupplyReq12v,
+            "maxPwrSupReq3_3V", maxPowerSupplyReq33v,
+            "maxPwrSupReq5V", maxPowerSupplyReq5v,
+            "maxThermLoad", maxThermalLoad,
+            "nvmeRecAreaVer", recordAreaVersion);
+  //          "totNvmCap", totalNVMCapacity);
+        if (!success)
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+        if (eptFactor != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["VitalProductData"]
+                            ["MultiRecordInformation"]["NVMeMultiRecord"]
+                            ["EPTFactor"] = *eptFactor;
+        }
+        if (initialPowerSupplyReq18v != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["VitalProductData"]
+                            ["MultiRecordInformation"]["NVMeMultiRecord"]
+                            ["InitialPowerSupplyReq1.8v"] = *initialPowerSupplyReq18v;
+        }
+        if (initialPowerSupplyReq12v != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["VitalProductData"]
+                            ["MultiRecordInformation"]["NVMeMultiRecord"]
+                            ["InitialPowerSupplyReq12v"] = *initialPowerSupplyReq12v;
+        }
+        if (initialPowerSupplyReq33v != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["VitalProductData"]
+                            ["MultiRecordInformation"]["NVMeMultiRecord"]
+                            ["InitialPowerSupplyReq3.3v"] = *initialPowerSupplyReq33v;
+        }        
+        if (initialPowerSupplyReq5v != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["VitalProductData"]
+                            ["MultiRecordInformation"]["NVMeMultiRecord"]
+                            ["InitialPowerSupplyReq5v"] = *initialPowerSupplyReq5v;
+        }
+        if (maxAuxPowerSupplyReq33v != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["VitalProductData"]
+                            ["MultiRecordInformation"]["NVMeMultiRecord"]
+                            ["MaxAuxPowerSupplyReq3.3v"] = *maxAuxPowerSupplyReq33v;
+        }        
+        if (maxPowerSupplyReq18v != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["VitalProductData"]
+                            ["MultiRecordInformation"]["NVMeMultiRecord"]
+                            ["MaxPowerSupplyReq1.8v"] = *maxPowerSupplyReq18v;
+        }
+        if (maxPowerSupplyReq12v != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["VitalProductData"]
+                            ["MultiRecordInformation"]["NVMeMultiRecord"]
+                            ["MaxPowerSupplyReq12v"] = *maxPowerSupplyReq12v;
+        }
+        if (maxPowerSupplyReq33v != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["VitalProductData"]
+                            ["MultiRecordInformation"]["NVMeMultiRecord"]
+                            ["MaxPowerSupplyReq3.3v"] = *maxPowerSupplyReq33v;
+        }
+        if (maxPowerSupplyReq5v != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["VitalProductData"]
+                            ["MultiRecordInformation"]["NVMeMultiRecord"]
+                            ["MaxPowerSupplyReq5v"] = *maxPowerSupplyReq5v;
+        }        
+        if (maxThermalLoad != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["VitalProductData"]
+                            ["MultiRecordInformation"]["NVMeMultiRecord"]
+                            ["MaxThermalLoad"] = *maxThermalLoad;
+        }
+        if (recordAreaVersion != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["VitalProductData"]
+                            ["MultiRecordInformation"]["NVMeMultiRecord"]
+                            ["RecordAreaVersion"] = *recordAreaVersion;
+        }
+        // if (totalNVMCapacity != nullptr)
+        // {
+        //     asyncResp->res.jsonValue["Oem"]["Ami"]["VitalProductData"]
+        //                     ["MultiRecordInformation"]["NVMeMultiRecord"]
+        //                     ["TotalNVMCapacity"] = *totalNVMCapacity;
+        // }          
+        });
+}
+
+inline void getVPDNVMePCIePortRecord(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                          const std::string& connectionName,
+                          const std::string& path,
+                          const std::string& interface)
+{
+    sdbusplus::asio::getAllProperties(
+        *crow::connections::systemBus, connectionName, path, interface,
+        [asyncResp](const boost::system::error_code& ec,
+                    const std::vector<
+                        std::pair<std::string, dbus::utility::DbusVariantType>>&
+                        propertiesList) {
+        if (ec)
+        {
+            // this interface isn't necessary
+            return;
+        }
+        const uint8_t* mctpSupport = nullptr;
+        const uint8_t* pcieMaximumLinkWidth = nullptr;
+        const uint8_t* pciePortInformation = nullptr;
+        const uint8_t* pciePortNumber = nullptr;
+        const uint8_t* pcieRecordVersion = nullptr;
+        const uint8_t* pcieSupportedlinkSpeeds = nullptr;
+        const uint8_t* refClockCapability = nullptr;
+
+        const bool success = sdbusplus::unpackPropertiesNoThrow(
+            dbus_utils::UnpackErrorPrinter(), propertiesList, 
+            "mctpSup", mctpSupport, "pcieMaxLnkWidth", pcieMaximumLinkWidth,
+            "portInfo", pciePortInformation, "pciePortNum", pciePortNumber,
+            "recFmtVer", pcieRecordVersion, "pcieLnkSpd", pcieSupportedlinkSpeeds,
+            "refClkCap", refClockCapability);
+        if (!success)
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+        if (mctpSupport != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["VitalProductData"]
+                            ["MultiRecordInformation"]["NVMePCIePortMultiRecord"]
+                            ["MctpSupport"] = *mctpSupport;
+        }
+        if (pcieMaximumLinkWidth != nullptr)
+        {
+            if (linkWidth.find(*pcieMaximumLinkWidth) != linkWidth.end())
+            {
+                asyncResp->res.jsonValue["Oem"]["Ami"]["VitalProductData"]
+                            ["MultiRecordInformation"]["NVMePCIePortMultiRecord"] 
+                            ["PCIeMaximumLinkWidth"] = linkWidth.find(*pcieMaximumLinkWidth)->second;
+            }
+        }
+        if (pciePortInformation != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["VitalProductData"]
+                            ["MultiRecordInformation"]["NVMePCIePortMultiRecord"]
+                            ["PCIePortInformation"] = *pciePortInformation;
+        }
+        if (pciePortNumber != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["VitalProductData"]
+                            ["MultiRecordInformation"]["NVMePCIePortMultiRecord"]
+                            ["PCIePortNumber"] = *pciePortNumber;
+        }
+        if (pcieRecordVersion != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]["VitalProductData"]
+                            ["MultiRecordInformation"]["NVMePCIePortMultiRecord"]
+                            ["PCIeRecordVersion"] = *pcieRecordVersion;
+        }
+        if (pcieSupportedlinkSpeeds != nullptr)
+        {
+            if (linkSpeed.find(*pcieSupportedlinkSpeeds) != linkSpeed.end())
+            {
+                asyncResp->res.jsonValue["Oem"]["Ami"]["VitalProductData"]
+                            ["MultiRecordInformation"]["NVMePCIePortMultiRecord"]
+                            ["PCIeSupportedlinkSpeeds"] = linkSpeed.find(*pcieSupportedlinkSpeeds)->second;
+            }
+            else
+            {
+                asyncResp->res.jsonValue["Oem"]["Ami"]["VitalProductData"]
+                            ["MultiRecordInformation"]["NVMePCIePortMultiRecord"]
+                            ["PCIeSupportedlinkSpeeds"] = "Not Supported";            
+            }
+        }
+        if (refClockCapability != nullptr)
+        {
+            if (refClock.find(*refClockCapability) != refClock.end())
+            {
+                asyncResp->res.jsonValue["Oem"]["Ami"]["VitalProductData"]
+                            ["MultiRecordInformation"]["NVMePCIePortMultiRecord"]
+                            ["RefClockCapability"] = refClock.find(*refClockCapability)->second;
+            }
+        }    
+        });
+}
+
+inline void requestRoutesNvmeControllersInstance(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/Nvme/Controllers/<str>/")
+        .privileges(redfish::privileges::getStorage)
+        .methods(
+            boost::beast::http::verb::get)([](const crow::Request&,
+                                              const std::shared_ptr<
+                                                  bmcweb::AsyncResp>& asyncResp,
+                                              const std::string& controllerId) {
+            constexpr std::array<std::string_view, 1> interfaces = {
+                "xyz.openbmc_project.Nvme"};
+            dbus::utility::getSubTree(
+                "/xyz/openbmc_project/Nvme", 0, interfaces,
+                [asyncResp,
+                 controllerId](const boost::system::error_code& ec,
+                          const dbus::utility::MapperGetSubTreeResponse& subtree) {
+                if (ec)
+                {
+                    BMCWEB_LOG_ERROR << "Controller mapper call error";
+                    messages::internalError(asyncResp->res);
+                    return;
+                }
+
+                auto controller = std::find_if(
+                    subtree.begin(), subtree.end(),
+                    [&controllerId](
+                        const std::pair<std::string,
+                                        dbus::utility::MapperServiceMap>& object) {
+                    return sdbusplus::message::object_path(object.first)
+                               .filename() == controllerId;
+                    });
+
+                if (controller == subtree.end())
+                {
+                    messages::resourceNotFound(asyncResp->res, "controller", controllerId);
+                    return;
+                }
+
+                const std::string& path = controller->first;
+                const dbus::utility::MapperServiceMap& connectionNames =
+                    controller->second;
+
+                asyncResp->res.jsonValue["@odata.type"] = "#StorageController.v1_0_0.StorageController";
+                asyncResp->res.jsonValue["@odata.id"] = boost::urls::format(
+                    "/redfish/v1/Systems/system/Storage/Nvme/Controllers/{}", controllerId);
+                asyncResp->res.jsonValue["Name"] = "NVME controller";
+                asyncResp->res.jsonValue["Id"] = controllerId;
+                asyncResp->res.jsonValue["Oem"]["Ami"]["@odata.type"] = 
+                    "#AMINVMeMIController.v1_0_0.AMINVMeMIController";
+                asyncResp->res.jsonValue["Ports"]["@odata.id"] = boost::urls::format(
+                    "/redfish/v1/Systems/system/Storage/Nvme/Controllers/{}/Ports", controllerId);
+
+                if (connectionNames.size() != 1)
+                {
+                    BMCWEB_LOG_ERROR << "Connection size " << connectionNames.size()
+                                     << ", not equal to 1";
+                    messages::internalError(asyncResp->res);
+                    return;
+                }
+
+                getMainChassisId(
+                    asyncResp,
+                    [](const std::string& chassisId,
+                    const std::shared_ptr<bmcweb::AsyncResp>& aRsp) {
+                    aRsp->res.jsonValue["Links"]["Chassis"]["@odata.id"] =
+                        boost::urls::format("/redfish/v1/Chassis/{}", chassisId);
+                    });
+
+                // default it to Enabled
+                asyncResp->res.jsonValue["Status"]["State"] = "Enabled";
+
+                auto health = std::make_shared<HealthPopulate>(asyncResp);
+                health->inventory.emplace_back(path);
+                health->populate();
+
+                for (const std::string& interface : connectionNames[0].second)
+                {
+                    if (interface == "xyz.openbmc_project.Common.VPDProductInfo")
+                    {
+                        getControllerAsset(asyncResp, connectionNames[0].first, path, 
+                                    interface);
+                    }
+                    else if (interface == "xyz.openbmc_project.Common.SubInfoData")
+                    {
+                        getSubSystemInfo(asyncResp, connectionNames[0].first, path,
+                                    interface);
+                    }
+                    else if (interface == "xyz.openbmc_project.Common.SubsysHealthStatusPoll_Flag0")
+                    {
+                        getSubSystemHealthStatus(asyncResp, connectionNames[0].first, path,
+                                    interface);
+                        getNVMeControllerProperties(asyncResp, connectionNames[0].first, path,
+                                    interface);
+                    }
+                    else if (interface == "xyz.openbmc_project.Common.VPDNvmeRec")
+                    {
+                        getVPDNVMeMultiRecordInfo(asyncResp, connectionNames[0].first, path,
+                                    interface);
+                    }
+                    else if (interface == "xyz.openbmc_project.Common.VPDPciePortRec")
+                    {
+                        getVPDNVMePCIePortRecord(asyncResp, connectionNames[0].first, path,
+                                    interface);
+                    }
+                }
+                });
+               
+                });
+}
+
+inline void getNvmePorts (const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
+{
+
+    nlohmann::json& controllerArray =
+           asyncResp->res.jsonValue["Members"];
+    nlohmann::json& count = asyncResp->res.jsonValue["Members@odata.count"];
+    count = 0;
+
+    sdbusplus::asio::getProperty<uint8_t>(
+        *crow::connections::systemBus, "xyz.openbmc_project.NVMEMgt", 
+        "/xyz/openbmc_project/Nvme/0", "xyz.openbmc_project.Common.SubInfoData", 
+        "numOfPorts",[asyncResp, &controllerArray, &count]
+            (const boost::system::error_code& ec,
+                          const uint8_t ports) {
+        if (ec)
+        {
+            return;
+        }
+        for(int var = 0; var < ports; var++)
+        {
+            nlohmann::json::object_t controllerJson;
+            const std::string str = "/redfish/v1/Systems/system/Storage/Nvme/Controllers/0/Ports/" + to_string(var);
+            controllerJson["@odata.id"] = str;
+            controllerArray.push_back(std::move(controllerJson));
+        }
+        count = controllerArray.size();
+        });
+
+}
+
+inline void requestRoutesNvmePorts(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/Nvme/Controllers/<str>/Ports")
+        .privileges(redfish::privileges::getStorage)
+        .methods(boost::beast::http::verb::get)(
+            [](const crow::Request&,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& controllerId) {
+                asyncResp->res.jsonValue["@odata.type"] =
+                    "#PortCollection.PortCollection";
+                asyncResp->res.jsonValue["@odata.id"] =
+                    "/redfish/v1/Systems/system/Storage/Nvme/Controllers/" + controllerId + "/Ports";
+                asyncResp->res.jsonValue["Name"] = "Port Collections";
+                asyncResp->res.jsonValue["Description"] = "The Collections of Ports";
+                getNvmePorts(asyncResp);           
+            });
+}
+
+inline void getInactiveInfo(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
+{
+    asyncResp->res.jsonValue["Name"] = "Inactive";
+    asyncResp->res.jsonValue["Oem"]["Ami"]
+            ["@odata.type"] = "@AMINVMeMIPort.v1_0_0.AMINVMeMIPort";
+    asyncResp->res.jsonValue["Oem"]["Ami"]
+            ["PortInformation"] ["PortStatus"] = "Inactive";
+    asyncResp->res.jsonValue["Oem"]["Ami"]
+            ["PortInformation"] ["PortType"] = "N/A";
+}
+
+inline void getPCIeInfo(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                          const std::string& )
+{
+    asyncResp->res.jsonValue["Name"] = "PCIe";
+    asyncResp->res.jsonValue["Oem"]["Ami"]
+            ["@odata.type"] = "@AMINVMeMIPort.v1_0_0.AMINVMeMIPort";
+    asyncResp->res.jsonValue["Oem"]["Ami"]
+            ["PortInformation"] ["PortStatus"] = "Active";
+    asyncResp->res.jsonValue["Oem"]["Ami"]
+            ["PortInformation"] ["PortType"] = "PCIe";
+    sdbusplus::asio::getAllProperties(
+        *crow::connections::systemBus, "xyz.openbmc_project.NVMEMgt", 
+        "/xyz/openbmc_project/Nvme/0", "xyz.openbmc_project.Common.PortInfoData_Port0",
+        [asyncResp](const boost::system::error_code& ec,
+                    const std::vector<
+                        std::pair<std::string, dbus::utility::DbusVariantType>>&
+                        propertiesList) {
+        if (ec)
+        {
+            // this interface isn't necessary
+            return;
+        }
+        const int32_t* maxMCTPTransUnitSize = nullptr;
+        const uint8_t* currentLinkSpeed = nullptr;
+        const uint8_t* supportedLinkSpeeds = nullptr;
+        const uint8_t* maxPayloadSize = nullptr;
+        const uint8_t* maxLinkWidth = nullptr;
+        const uint8_t* negotiatedLinkWidth = nullptr;
+
+        const bool success = sdbusplus::unpackPropertiesNoThrow(
+            dbus_utils::UnpackErrorPrinter(), propertiesList, 
+            "maxPayloadSize", maxPayloadSize, "maxMCTPTranUnitSize", maxMCTPTransUnitSize,
+             "maxLinkWidth", maxLinkWidth, "negLinkWidth", negotiatedLinkWidth, 
+             "supLinkSpeedVector", supportedLinkSpeeds, "curLinkSpeed", currentLinkSpeed);
+            
+        if (!success)
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+        if (maxMCTPTransUnitSize != nullptr)
+        {
+            asyncResp->res.jsonValue["Oem"]["Ami"]
+                    ["PortInformation"] ["MaxMCTPTransUnitSize"] = *maxMCTPTransUnitSize;
+        }
+        if (maxPayloadSize != nullptr)
+        {
+            if (payloadSize.find(*maxPayloadSize) != payloadSize.end())
+            {
+                asyncResp->res.jsonValue["Oem"]["Ami"]
+                    ["PortInformation"] ["MaxPayloadSize"] = 
+                                payloadSize.find(*maxPayloadSize)->second;
+            }
+        }
+        if(maxLinkWidth != nullptr)
+        {
+            if (linkWidth.find(*maxLinkWidth) != linkWidth.end())
+            {
+                asyncResp->res.jsonValue["Oem"]["Ami"]
+                    ["PortInformation"] ["MaxLinkWidth"] = 
+                                linkWidth.find(*maxLinkWidth)->second;
+            }
+        }
+        if(negotiatedLinkWidth != nullptr)
+        {
+            if (linkWidth.find(*negotiatedLinkWidth) != linkWidth.end())
+            {
+                asyncResp->res.jsonValue["Oem"]["Ami"]
+                    ["PortInformation"] ["NegotiatedLinkWidth"] = 
+                                linkWidth.find(*negotiatedLinkWidth)->second;
+            }
+        }
+        if(supportedLinkSpeeds != nullptr)
+        {
+            if (linkSpeed.find(*supportedLinkSpeeds) != linkSpeed.end())
+            {
+                asyncResp->res.jsonValue["Oem"]["Ami"]
+                    ["PortInformation"] ["SupportedLinkSpeeds"] = 
+                                linkSpeed.find(*supportedLinkSpeeds)->second;
+            }
+            else
+            {
+                asyncResp->res.jsonValue["Oem"]["Ami"]
+                    ["PortInformation"] ["SupportedLinkSpeeds"] = 
+                                "Not supported";
+            }
+        }
+        if(currentLinkSpeed != nullptr)
+        {
+            if (curtLinkSpeed.find(*currentLinkSpeed) != curtLinkSpeed.end())
+            {
+                asyncResp->res.jsonValue["Oem"]["Ami"]
+                    ["PortInformation"] ["CurrentLinkSpeed"] = 
+                                curtLinkSpeed.find(*currentLinkSpeed)->second;
+            }
+            else
+            {
+                asyncResp->res.jsonValue["Oem"]["Ami"]
+                    ["PortInformation"] ["CurrentLinkSpeed"] = 
+                                "Not Supported";
+            }
+        }
+        });   
+}
+
+
+inline void requestRoutesNvmePortsInstance(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/Nvme/Controllers/<str>/Ports/<str>")
+        .privileges(redfish::privileges::getStorage)
+        .methods(
+            boost::beast::http::verb::get)([](const crow::Request&,
+                                              const std::shared_ptr<
+                                                  bmcweb::AsyncResp>& asyncResp,
+                                              const std::string& controllerId,
+                                              const std::string& portId) {
+                asyncResp->res.jsonValue["@odata.type"] =
+                    "#Port.v1_3_0.Port";
+                asyncResp->res.jsonValue["@odata.id"] =
+                    "/redfish/v1/Systems/system/Storage/Nvme/Controllers/" + controllerId +
+                         "/Ports/" + portId ;
+                asyncResp->res.jsonValue["Id"] = portId;
+                const std::string interface = "xyz.openbmc_project.Common.PortInfoData_Port" + portId; 
+
+                sdbusplus::asio::getProperty<uint8_t>(
+                    *crow::connections::systemBus, "xyz.openbmc_project.NVMEMgt", 
+                    "/xyz/openbmc_project/Nvme/0", interface, "portType",
+                    [asyncResp, interface, portId ](const boost::system::error_code& ec2,
+                                       uint8_t type) {
+                    if (ec2)
+                    {
+                        return;
+                    }
+                    asyncResp->res.jsonValue["Oem"]["Ami"]
+                            ["PortInformation"] ["PortNo"] = portId;
+                    if (type == 0)
+                    {
+                        getInactiveInfo(asyncResp);
+                    }
+                    else if (type == 1)
+                    {
+                        getPCIeInfo(asyncResp, interface);
+                    }
+                    else if (type == 2)
+                    {
+                      //  getSMBusInfo(asyncResp, interface); Still backend support need to add
+                        asyncResp->res.jsonValue["Name"] = "SMBus";
+                        asyncResp->res.jsonValue["Oem"]["Ami"]
+                                                ["@odata.type"] = "@AMINVMeMIPort.v1_0_0.AMINVMeMIPort";
+                        asyncResp->res.jsonValue["Oem"]["Ami"]
+                                                ["PortInformation"] ["PortStatus"] = "Active";
+                        asyncResp->res.jsonValue["Oem"]["Ami"]
+                                                ["PortInformation"] ["PortType"] = "SMBus";
+                    }
+                    });
+            
+          });
+}
+
+inline void requestRoutesNvmeDrive(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/Nvme/Drives/<str>/")
+        .privileges(redfish::privileges::getDrive)
+        .methods(
+            boost::beast::http::verb::get)([](const crow::Request&,
+                                              const std::shared_ptr<
+                                                  bmcweb::AsyncResp>& asyncResp,
+                                              const std::string& driveId) {
+            crow::connections::systemBus->async_method_call(
+                [asyncResp,
+                 driveId](const boost::system::error_code ec,
+                          const GetSubTreeType& subtree) {
+                    if (ec)
+                    {
+                        BMCWEB_LOG_ERROR << "Drive mapper call error";
+                        messages::internalError(asyncResp->res);
+                        return;
+                    }
+
+                    auto object2 = std::find_if(
+                        subtree.begin(), subtree.end(),
+                        [&driveId](auto& object) {
+                            const std::string& path = object.first;
+                            return boost::ends_with(path, "/" + driveId);
+                        });
+
+                    if (object2 == subtree.end())
+                    {
+                        messages::resourceNotFound(asyncResp->res, "Drive",
+                                                   driveId);
+                        return;
+                    }
+
+                    const std::string& path = object2->first;
+                    const std::vector<
+                        std::pair<std::string, std::vector<std::string>>>&
+                        connectionNames = object2->second;
+                    asyncResp->res.jsonValue["@odata.type"] =
+                        "#Drive.v1_7_0.Drive";
+                    asyncResp->res.jsonValue["@odata.id"] =
+                        "/redfish/v1/Systems/system/Storage/Nvme/Drives/" +
+                        driveId;
+                    asyncResp->res.jsonValue["Name"] = driveId;
+                    asyncResp->res.jsonValue["Id"] = driveId;
+
+                    if (connectionNames.size() != 1)
+                    {
+                        BMCWEB_LOG_ERROR << "Connection size "
+                                         << connectionNames.size()
+                                         << ", greater than 1";
+                        messages::internalError(asyncResp->res);
+                        return;
+                    }
+
+                    getMainChassisId(
+                        asyncResp,
+                        [](const std::string& chassisId,
+                           const std::shared_ptr<bmcweb::AsyncResp>& aRsp) {
+                            aRsp->res.jsonValue["Links"]["Chassis"] = {
+                                {"@odata.id",
+                                 "/redfish/v1/Chassis/" + chassisId}};
+                        });
+
+                    const std::string& connectionName =
+                        connectionNames[0].first;
+                    crow::connections::systemBus->async_method_call(
+                        [asyncResp](
+                            const boost::system::error_code ec2,
+                            const std::vector<std::pair<
+                                std::string,
+                                std::variant<bool, std::string, uint64_t>>>&
+                                propertiesList) {
+                            if (ec2)
+                            {
+                                // this interface isn't necessary
+                                return;
+                            }
+                            for (const std::pair<
+                                     std::string,
+                                     std::variant<bool, std::string, uint64_t>>&
+                                     property : propertiesList)
+                            {
+                                // Store DBus properties that are also
+                                // Redfish properties with same name and a
+                                // string value
+                                const std::string& propertyName =
+                                    property.first;
+                                if ((propertyName == "partModel") ||
+                                    (propertyName == "prdSerial") ||
+                                    (propertyName == "manufacturer") ||
+                                    (propertyName == "prdName"))
+                                {
+                                    const std::string* value =
+                                        std::get_if<std::string>(
+                                            &property.second);
+                                    if (value != nullptr)
+                                    {
+                                        if (propertyName == "partModel")
+                                            asyncResp->res
+                                                .jsonValue["PartNumber"] =
+                                                *value;
+
+                                        if (propertyName == "prdSerial")
+                                            asyncResp->res
+                                                .jsonValue["SerialNumber"] =
+                                                *value;
+
+                                        if (propertyName == "manufacturer")
+                                            asyncResp->res
+                                                .jsonValue["Manufacturer"] =
+                                                *value;
+
+                                        if (propertyName == "prdName")
+                                            asyncResp->res.jsonValue["Model"] =
+                                                *value;
+                                    }
+                                }
+                            }
+                        },
+                        connectionName, path, "org.freedesktop.DBus.Properties",
+                        "GetAll", "xyz.openbmc_project.Common.VPDProductInfo");
+/*
+                    crow::connections::systemBus->async_method_call(
+                        [asyncResp](
+                            const boost::system::error_code ec2,
+                            const std::vector<std::pair<
+                                std::string, std::variant<uint32_t, uint8_t>>>&
+                                propertiesList) {
+                            if (ec2)
+                            {
+                                return;
+                            }
+                            for (const std::pair<
+                                     std::string,
+                                     std::variant<uint32_t, uint8_t>>&
+                                     property : propertiesList)
+                            {
+                                const std::string& propertyName =
+                                    property.first;
+                                if ((propertyName == "curLinkSpeed") ||
+                                    (propertyName == "maxLinkWidth"))
+                                {
+                                    const uint8_t* value =
+                                        std::get_if<uint8_t>(&property.second);
+                                    if (value != nullptr)
+                                    {
+
+                                        if (propertyName == "curLinkSpeed")
+                                        {
+                                            if (linkSpeedToRedfishProperty.find(
+                                                    *value) ==
+                                                linkSpeedToRedfishProperty
+                                                    .end())
+                                            {
+                                                asyncResp->res.jsonValue
+                                                    ["Oem"]["OpenBmc"]
+                                                    ["PCIe_0_Link_Speed"] =
+                                                    "Unknown";
+                                            }
+                                            else
+                                            {
+                                                asyncResp->res.jsonValue
+                                                    ["Oem"]["OpenBmc"]
+                                                    ["PCIe_0_Link_Speed"] =
+                                                    linkSpeedToRedfishProperty
+                                                        .find(*value)
+                                                        ->second;
+                                            }
+                                        }
+
+                                        if (propertyName == "maxLinkWidth")
+                                        {
+                                            if (linkWidthToRedfishProperty.find(
+                                                    *value) ==
+                                                linkWidthToRedfishProperty
+                                                    .end())
+                                            {
+                                                asyncResp->res.jsonValue
+                                                    ["Oem"]["OpenBmc"]
+                                                    ["PCIe_0_Link_Width"] =
+                                                    "Unknown";
+                                            }
+                                            else
+                                            {
+                                                asyncResp->res.jsonValue
+                                                    ["Oem"]["OpenBmc"]
+                                                    ["PCIe_0_Link_Width"] =
+                                                    linkWidthToRedfishProperty
+                                                        .find(*value)
+                                                        ->second;
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                        connectionName, path, "org.freedesktop.DBus.Properties",
+                        "GetAll",
+                        "xyz.openbmc_project.Common.PortInfoData_Port0");
+
+                    crow::connections::systemBus->async_method_call(
+                        [asyncResp](
+                            const boost::system::error_code ec2,
+                            const std::vector<std::pair<
+                                std::string, std::variant<uint32_t, uint8_t>>>&
+                                propertiesList) {
+                            if (ec2)
+                            {
+                                return;
+                            }
+
+                            for (const std::pair<
+                                     std::string,
+                                     std::variant<uint32_t, uint8_t>>&
+                                     property : propertiesList)
+                            {
+                                const std::string& propertyName =
+                                    property.first;
+                                if ((propertyName == "curLinkSpeed") ||
+                                    (propertyName == "maxLinkWidth"))
+                                {
+                                    const uint8_t* value =
+                                        std::get_if<uint8_t>(&property.second);
+                                    if (value != nullptr)
+                                    {
+
+                                        if (propertyName == "curLinkSpeed")
+                                        {
+                                            if (linkSpeedToRedfishProperty.find(
+                                                    *value) ==
+                                                linkSpeedToRedfishProperty
+                                                    .end())
+                                            {
+                                                asyncResp->res.jsonValue
+                                                    ["Oem"]["OpenBmc"]
+                                                    ["PCIe_1_Link_Speed"] =
+                                                    "Unknown";
+                                            }
+                                            else
+                                            {
+                                                asyncResp->res.jsonValue
+                                                    ["Oem"]["OpenBmc"]
+                                                    ["PCIe_1_Link_Speed"] =
+                                                    linkSpeedToRedfishProperty
+                                                        .find(*value)
+                                                        ->second;
+                                            }
+                                        }
+
+                                        if (propertyName == "maxLinkWidth")
+                                        {
+                                            if (linkWidthToRedfishProperty.find(
+                                                    *value) ==
+                                                linkWidthToRedfishProperty
+                                                    .end())
+                                            {
+                                                asyncResp->res.jsonValue
+                                                    ["Oem"]["OpenBmc"]
+                                                    ["PCIe_1_Link_Width"] =
+                                                    "Unknown";
+                                            }
+                                            else
+                                            {
+                                                asyncResp->res.jsonValue
+                                                    ["Oem"]["OpenBmc"]
+                                                    ["PCIe_1_Link_Width"] =
+                                                    linkWidthToRedfishProperty
+                                                        .find(*value)
+                                                        ->second;
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                        connectionName, path, "org.freedesktop.DBus.Properties",
+                        "GetAll",
+                        "xyz.openbmc_project.Common.PortInfoData_Port1");
+
+                    crow::connections::systemBus->async_method_call(
+                        [asyncResp](
+                            const boost::system::error_code ec2,
+                            const std::vector<std::pair<
+                                std::string,
+                                std::variant<bool, std::string, uint64_t>>>&
+                                propertiesList) {
+                            if (ec2)
+                            {
+                                return;
+                            }
+                            for (const std::pair<
+                                     std::string,
+                                     std::variant<bool, std::string, uint64_t>>&
+                                     property : propertiesList)
+                            {
+                                const std::string& propertyName =
+                                    property.first;
+                                if ((propertyName == "bootloaderVer") ||
+                                    (propertyName == "firmwareVer"))
+                                {
+                                    const std::string* value =
+                                        std::get_if<std::string>(
+                                            &property.second);
+                                    if (value != nullptr)
+                                    {
+                                        if (propertyName == "bootloaderVer")
+                                            asyncResp->res.jsonValue
+                                                ["Oem"]["OpenBmc"]
+                                                ["Bootloader_Version"] = *value;
+
+                                        if (propertyName == "firmwareVer")
+                                            asyncResp->res
+                                                .jsonValue["Oem"]["OpenBmc"]
+                                                          ["Firmware_Version"] =
+                                                *value;
+                                    }
+                                }
+                            }
+                        },
+                        connectionName, path, "org.freedesktop.DBus.Properties",
+                        "GetAll", "xyz.openbmc_project.Common.IntelSpec");
+
+                    crow::connections::systemBus->async_method_call(
+                        [asyncResp](const boost::system::error_code ec,
+                                    const std::variant<std::string>& value) {
+                            if (ec)
+                            {
+                                BMCWEB_LOG_DEBUG
+                                    << "failed to get property Value  " << ec;
+                                return;
+                            }
+
+                            const std::string* s =
+                                std::get_if<std::string>(&value);
+                            asyncResp->res
+                                .jsonValue["Oem"]["OpenBmc"]["DeviceLocation"] =
+                                *s;
+                        },
+                        connectionName, path, "org.freedesktop.DBus.Properties",
+                        "Get", "xyz.openbmc_project.Nvme", "DeviceLocation");
+
+                    crow::connections::systemBus->async_method_call(
+                        [asyncResp](
+                            const boost::system::error_code ec2,
+                            const std::vector<std::pair<
+                                std::string, std::variant<uint32_t, uint8_t>>>&
+                                propertiesList) {
+                            if (ec2)
+                            {
+                                return;
+                            }
+                            for (const std::pair<
+                                     std::string,
+                                     std::variant<uint32_t, uint8_t>>&
+                                     property : propertiesList)
+                            {
+                                const std::string& propertyName =
+                                    property.first;
+                                if ((propertyName == "ccsReady") ||
+                                    (propertyName == "nssDF") ||
+                                    (propertyName == "nssRNR") ||
+                                    (propertyName == "nssP1LA") ||
+                                    (propertyName == "pdlu") ||
+                                    (propertyName == "nssP0LA"))
+                                {
+                                    const uint8_t* value =
+                                        std::get_if<uint8_t>(&property.second);
+                                    if (value != nullptr)
+                                    {
+                                        if (propertyName == "pdlu")
+                                        {
+                                            asyncResp->res.jsonValue
+                                                ["Oem"]["OpenBmc"]
+                                                ["Drive_Life_Consumed"] =
+                                                *value;
+                                        }
+                                        asyncResp->res
+                                            .jsonValue["Oem"]["OpenBmc"]
+                                                      ["Device_Class"] =
+                                            2; // Hardcode the value
+                                        asyncResp->res
+                                            .jsonValue["Oem"]["OpenBmc"]
+                                                      ["Device_Sub_Class"] =
+                                            8; // Hardcode the value
+                                        asyncResp->res.jsonValue
+                                            ["Oem"]["OpenBmc"]
+                                            ["Device_Programming_Intf"] =
+                                            1; // Hardcode the value
+                                        if (propertyName == "ccsReady")
+                                        {
+                                            if (*value == 1)
+                                                asyncResp->res
+                                                    .jsonValue["Oem"]["OpenBmc"]
+                                                              ["NVMe_Powered"] =
+                                                    "On";
+                                            else
+                                                asyncResp->res
+                                                    .jsonValue["Oem"]["OpenBmc"]
+                                                              ["NVMe_Powered"] =
+                                                    "Off";
+                                        }
+                                        if (propertyName == "nssDF")
+                                        {
+                                            if (*value == 1)
+                                                asyncResp->res.jsonValue
+                                                    ["Oem"]["OpenBmc"]
+                                                    ["NVMe_Functional"] =
+                                                    "Functional";
+                                            else
+                                                asyncResp->res.jsonValue
+                                                    ["Oem"]["OpenBmc"]
+                                                    ["NVMe_Functional"] =
+                                                    "Failure";
+                                        }
+                                        if (propertyName == "nssRNR")
+                                        {
+                                            if (*value == 1)
+                                                asyncResp->res.jsonValue
+                                                    ["Oem"]["OpenBmc"]
+                                                    ["NVMe_Reset_Required"] =
+                                                    "No Reset Required";
+                                            else
+                                                asyncResp->res.jsonValue
+                                                    ["Oem"]["OpenBmc"]
+                                                    ["NVMe_Reset_Required"] =
+                                                    "Reset Required";
+                                        }
+                                        if (propertyName == "nssP0LA")
+                                        {
+                                            if (*value == 1)
+                                                asyncResp->res.jsonValue
+                                                    ["Oem"]["OpenBmc"]
+                                                    ["Port_0_PCIe_Link_Active"] =
+                                                    "PCIe Link Up";
+                                            else
+                                                asyncResp->res.jsonValue
+                                                    ["Oem"]["OpenBmc"]
+                                                    ["Port_0_PCIe_Link_Active"] =
+                                                    "PCIe Link Down";
+                                        }
+                                        if (propertyName == "nssP1LA")
+                                        {
+                                            if (*value == 1)
+                                                asyncResp->res.jsonValue
+                                                    ["Oem"]["OpenBmc"]
+                                                    ["Port_1_PCIe_Link_Active"] =
+                                                    "PCIe Link Up";
+                                            else
+                                                asyncResp->res.jsonValue
+                                                    ["Oem"]["OpenBmc"]
+                                                    ["Port_1_PCIe_Link_Active"] =
+                                                    "PCIe Link Down";
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                        connectionName, path, "org.freedesktop.DBus.Properties",
+                        "GetAll",
+                        "xyz.openbmc_project.Common.SubsysHealthStatusPoll_"
+                        "Flag0");
+*/
+                },
+                "xyz.openbmc_project.ObjectMapper",
+                "/xyz/openbmc_project/object_mapper",
+                "xyz.openbmc_project.ObjectMapper", "GetSubTree",
+                "/xyz/openbmc_project/Nvme", 0,
+                std::array<const char*, 1>{"xyz.openbmc_project.Nvme"});
+        });
+}
+} // namespace redfish
diff --git a/meson.build b/meson.build
index 9f24014e..52fb4725 100644
--- a/meson.build
+++ b/meson.build
@@ -173,7 +173,7 @@ if (cxx.get_id() == 'gcc' and cxx.version().version_compare('>8.0'))
      '-Wnull-dereference',
      '-Wunused-parameter',
      '-Wdouble-promotion',
-     '-Wshadow',
+     '-Wno-shadow',
      '-Wno-psabi',
      ]),
     language:'cpp')
-- 
2.34.1

