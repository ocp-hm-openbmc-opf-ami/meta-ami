From 74db9d7dbd4f1b44b1b785dc3754f451f7a79a71 Mon Sep 17 00:00:00 2001
From: nibinc <nibinc@ami.com>
Date: Thu, 21 Sep 2023 11:51:54 -0400
Subject: [PATCH 111/111] Adding the OEM property support for discrete sensor

---
 redfish-core/lib/sensors.hpp                  | 122 ++++++++++++++++--
 .../v1/JsonSchemas/AMISensor/index.json       |  46 +++++++
 static/redfish/v1/schema/AMISensor_V1.xml     |  34 +++++
 3 files changed, 192 insertions(+), 10 deletions(-)
 create mode 100644 static/redfish/v1/JsonSchemas/AMISensor/index.json
 create mode 100644 static/redfish/v1/schema/AMISensor_V1.xml

diff --git a/redfish-core/lib/sensors.hpp b/redfish-core/lib/sensors.hpp
index 4543f98b..e495107f 100644
--- a/redfish-core/lib/sensors.hpp
+++ b/redfish-core/lib/sensors.hpp
@@ -45,6 +45,8 @@
 #include <utility>
 #include <variant>
 
+using SensorCallback = std::function<void(const std::vector<std::string>& stringState)>;
+
 namespace redfish
 {
 
@@ -86,7 +88,11 @@ constexpr auto sensorPaths = std::to_array<std::string_view>({
     "/xyz/openbmc_project/sensors/altitude",
     "/xyz/openbmc_project/sensors/energy",
 #endif
-    "/xyz/openbmc_project/sensors/utilization"
+    "/xyz/openbmc_project/sensors/utilization",
+    "/xyz/openbmc_project/sensors/powerunit",
+    "/xyz/openbmc_project/sensors/acpisystem",
+    "/xyz/openbmc_project/sensors/powersupply",
+    "/xyz/openbmc_project/sensors/os"
 });
 
 constexpr auto thermalPaths = std::to_array<std::string_view>({
@@ -718,6 +724,48 @@ inline void setLedState(nlohmann::json& sensorJson,
     }
 }
 
+inline void sensorState(uint16_t value, std::string objPath, std::string_view sensorType, const SensorCallback callback)
+{
+    uint16_t position = 0;
+    std::vector<uint16_t> positions;
+    std::map<std::string, std::string> type = {{"cpu", "Cpustatus"}, {"watchdog", "watchdog"},
+                                               {"acpisystem", "ACPISystem"},{"powersupply","Powersupply"},
+                                               {"powerunit","Powerunit"},{"os","OSCritical"}};
+    auto it = type.find(std::string(sensorType));
+    if (it != type.end()) {
+         while(value > 0 )
+         {
+            if (value & 1) {
+                 positions.push_back(position);
+            }
+            value >>= 1;
+            position++;
+         }
+         std::string interFace = "xyz.openbmc_project.Configuration." + it->second;
+         auto asyncCallback = [positions, callback](const boost::system::error_code ec,
+                                                    const std::variant<std::vector<std::string>>& state) {
+        if (ec)
+        {
+            BMCWEB_LOG_DEBUG << "DBUS response error " << ec;
+            return;
+        }
+        if (auto* stateVector = std::get_if<std::vector<std::string>>(&state)) {
+            if (!stateVector->empty()) {
+                std::vector<std::string> stateSensor;
+                for(auto& itr : positions){
+                    stateSensor.push_back(stateVector->at(itr));
+                }
+                 callback(stateSensor);
+            }
+
+            }
+        };
+         crow::connections::systemBus->async_method_call(
+            asyncCallback, "xyz.openbmc_project.EntityManager",
+              objPath, "org.freedesktop.DBus.Properties", "Get", interFace, "State");
+    }
+}
+
 /**
  * @brief Builds a json sensor representation of a sensor.
  * @param sensorName  The name of the sensor to be built
@@ -2909,24 +2957,77 @@ inline void
     const std::string& connectionName = valueIface.first;
     BMCWEB_LOG_DEBUG << "Looking up " << connectionName;
     BMCWEB_LOG_DEBUG << "Path " << sensorPath;
-
+    sdbusplus::message::object_path path(sensorPath);
+    std::string name = path.filename();
+    path = path.parent_path();
+    std::string type = path.filename();
+    std::set<std::string> discreteSensorTypes = {"cpu","watchdog","acpisystem",
+                                                 "powersupply","powerunit","os"};
     sdbusplus::asio::getAllProperties(
         *crow::connections::systemBus, connectionName, sensorPath, "",
         [asyncResp,
-         sensorPath](const boost::system::error_code& ec,
+         sensorPath, name, type, discreteSensorTypes](const boost::system::error_code& ec,
                      const ::dbus::utility::DBusPropertiesMap& valuesDict) {
         if (ec)
         {
             messages::internalError(asyncResp->res);
             return;
         }
-        sdbusplus::message::object_path path(sensorPath);
-        std::string name = path.filename();
-        path = path.parent_path();
-        std::string type = path.filename();
+        if(discreteSensorTypes.count(type) > 0)
+        {
+            uint16_t pass = 0;
+            for (const auto& [valueName, valueVariant] : valuesDict) {
+                const uint16_t *value;
+                std::string endPoint;
+                if(valueName == "Associations"){
+                    if (std::holds_alternative<std::vector<std::tuple<std::string, std::string,
+                                                                           std::string>>>(valueVariant)) {
+                        // Get the vector of tuples
+                        const auto& tupleVector = std::get<std::vector<std::tuple<std::string, std::string,
+                                                                             std::string>>>(valueVariant);
+                        for (const auto& tuple : tupleVector) {
+                            endPoint = std::get<2>(tuple);
+                            pass++;
+                        }
+                    }
+                }
+                else if(valueName == "State"){
+                    value = std::get_if<uint16_t>(&valueVariant);
+                    pass++;
+                }
+                if(pass == 2)
+                {
+                    asyncResp->res.jsonValue["@odata.type"] = "#Sensor.v1_2_0.Sensor";
+                    std::string nameSensor = name;
+                    std::replace(nameSensor.begin(), nameSensor.end(), '_', ' ');
+                    asyncResp->res.jsonValue["Name"] = nameSensor;
+                    asyncResp->res.jsonValue["Id"] = type + '_' + name;
+                    if(*value != 0)
+                    {
+                        std::string objPath = endPoint + "/" + std::string(name);
+                        sensorState(*value, objPath, type,[asyncResp](const std::vector<std::string>& stringState){
+                            nlohmann::json stateArray = nlohmann::json::array();
+                            for(auto& itr : stringState){
+                                stateArray.push_back(itr);
+                            }
+                            asyncResp->res.jsonValue["OEM"]["AMI"]["States"] = stateArray;
+                            asyncResp->res.jsonValue["OEM"]["AMI"]["ReadingTye"] = "Discrete";
+                        });
+                    }
+                    else{
+                        asyncResp->res.jsonValue["OEM"]["AMI"]["States"] = nullptr;
+                    }
+                    asyncResp->res.jsonValue["Status"]["State"] = getState(nullptr);
+                    asyncResp->res.jsonValue["Status"]["Health"] = getHealth(asyncResp->res.jsonValue, valuesDict,
+                                                                                  nullptr);
+                    }
+                }
+        }
+        else{
         objectPropertiesToJson(name, type, sensors::node::sensors, valuesDict,
                                asyncResp->res.jsonValue, nullptr);
-        });
+        }
+    });
 }
 
 inline void handleSensorGet(App& app, const crow::Request& req,
@@ -2951,8 +3052,9 @@ inline void handleSensorGet(App& app, const crow::Request& req,
 
     BMCWEB_LOG_DEBUG << "Sensor doGet enter";
 
-    constexpr std::array<std::string_view, 1> interfaces = {
-        "xyz.openbmc_project.Sensor.Value"};
+    constexpr std::array<std::string_view, 3> interfaces = {
+        "xyz.openbmc_project.Sensor.Value","xyz.openbmc_project.Sensor.State",
+        "xyz.openbmc_project.Association.Definitions"};
     std::string sensorPath = "/xyz/openbmc_project/sensors/" + nameType.first +
                              '/' + nameType.second;
     // Get a list of all of the sensors that implement Sensor.Value
diff --git a/static/redfish/v1/JsonSchemas/AMISensor/index.json b/static/redfish/v1/JsonSchemas/AMISensor/index.json
new file mode 100644
index 00000000..c2cce417
--- /dev/null
+++ b/static/redfish/v1/JsonSchemas/AMISensor/index.json
@@ -0,0 +1,46 @@
+{
+  "$id": "http://redfish.dmtf.org/schemas/v1/AMISensor.v1_0_0.json",
+  "$schema": "http://redfish.dmtf.org/schemas/v1/redfish-schema-v1.json",
+  "copyright": "Copyright 2014-2023 DMTF. For the full DMTF copyright policy, see http://www.dmtf.org/about/policies/copyright",
+  "definitions": {
+    "Sensor": {
+      "additionalProperties": false,
+      "description": "OEM Extension for sensor.",
+      "longDescription": "OEM extension for the sensor provides support for discrete sensors.",
+      "patternProperties": {
+        "^([a-zA-Z_][a-zA-Z0-9_]*)?@(odata|Redfish|Message)\\.[a-zA-Z_][a-zA-Z0-9_]*$": {
+          "description": "This property shall specify a valid odata or Redfish property.",
+          "type": [
+            "array",
+            "boolean",
+            "integer",
+            "number",
+            "null",
+            "object",
+            "string"
+          ]
+        }
+      },
+      "properties": {
+        "State": {
+          "description": "This property shall contain the state of the discrete sensors.",
+          "longDescription": "This property shall contain the different states of discrete sensors.",
+          "readonly": true,
+          "type": "array"
+        },
+        "ReadingType": {
+          "description": "This property will show the type of the sensor.",
+          "longDescription": "This property will provide information about the type of the sensor.",
+          "readonly": true,
+          "type": [
+            "string",
+            "null"
+          ]
+        }
+      },
+      "type": "object"
+    }
+  },
+  "owningEntity": "AMI",
+  "title": "#AMISensor.v1_0_0"
+}
diff --git a/static/redfish/v1/schema/AMISensor_V1.xml b/static/redfish/v1/schema/AMISensor_V1.xml
new file mode 100644
index 00000000..b552c255
--- /dev/null
+++ b/static/redfish/v1/schema/AMISensor_V1.xml
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+<root><$id>http://redfish.dmtf.org/schemas/v1/AMISensor.v1_0_0.json
+</$id><$schema>http://redfish.dmtf.org/schemas/v1/redfish-schema-v1.jsonundefined</$schema>undefined<copyright>Copyright 2014-2023 DMTF. For the full DMTF copyright policy, see http://www.dmtf.org/about/policies/copyright</copyright>undefined<definitions>
+<Sensor>
+	<additionalProperties>false</additionalProperties>
+	<description>OEM Extension for sensor.</description>
+	<longDescription>OEM extension for the sensor provides support for discrete sensors.</longDescription>
+	<patternProperties><^([a-zA-Z_][a-zA-Z0-9_]*)?@(odata|Redfish|Message)\.[a-zA-Z_][a-zA-Z0-9_]*$>
+		<description>This property shall specify a valid odata or Redfish property.</description>
+		<type>array</type>
+		<type>boolean</type>
+		<type>integer</type>
+		<type>number</type>
+		<type>null</type>
+		<type>object</type>
+		<type>string</type>
+	</^([a-zA-Z_][a-zA-Z0-9_]*)?@(odata|Redfish|Message)\.[a-zA-Z_][a-zA-Z0-9_]*$>
+</patternProperties>
+<properties>
+	<State>
+		<description>This property shall contain the state of the discrete sensors.</description>
+		<longDescription>This property shall contain the different states of discrete sensors.</longDescription>
+		<readonly>true</readonly>
+		<type>array</type>
+	</State>
+	<ReadingType>
+		<description>This property will show the type of the sensor.</description>
+		<longDescription>This property will provide information about the type of the sensor.</longDescription>
+		<readonly>true</readonly>
+		<type>string</type>
+		<type>null</type>
+	</ReadingType>
+</properties>
+<type>object</type>undefined</Sensor>undefined</definitions>undefined<owningEntity>AMI</owningEntity>undefined<title>#AMISensor.v1_0_0</title>undefined</root>
-- 
2.34.1

