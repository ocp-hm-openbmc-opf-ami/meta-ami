From 8fade23e06f0e752e15529e1e3ee1f2495136656 Mon Sep 17 00:00:00 2001
From: Pranoy Goru <gorumanip@ami.com>
Date: Sat, 14 Oct 2023 01:40:19 +0530
Subject: [PATCH 3/3] Add KVM VM status in user session info

Test:

If KVM is not open

https://x.x.x/kvm/kvmActiveStatus

{
"kvmActiveStatus": 0
}

IF KVM is open

https://x.x.x/kvm/kvmActiveStatus

{
"kvmActiveStatus": 1
}

Signed-off-by: Pranoy Goru <gorumanip@ami.com>
---
 http/websocket.hpp                            |  7 +-
 include/kvm_websocket.hpp                     | 73 ++++++++++++-------
 include/nbd_proxy.hpp                         | 21 +++++-
 include/sessions.hpp                          |  5 ++
 redfish-core/lib/redfish_sessions.hpp         | 12 +++
 static/redfish/v1/$metadata/index.xml         |  4 +
 .../v1/JsonSchemas/AMIWebSession/index.json   | 44 +++++++++++
 static/redfish/v1/schema/AMIWebSession_v1.xml | 44 +++++++++++
 8 files changed, 176 insertions(+), 34 deletions(-)
 create mode 100644 static/redfish/v1/JsonSchemas/AMIWebSession/index.json
 create mode 100644 static/redfish/v1/schema/AMIWebSession_v1.xml

diff --git a/http/websocket.hpp b/http/websocket.hpp
index 216c4131..c7d825f5 100644
--- a/http/websocket.hpp
+++ b/http/websocket.hpp
@@ -27,7 +27,9 @@ enum class MessageType
 struct Connection : std::enable_shared_from_this<Connection>
 {
   public:
-    explicit Connection(const crow::Request& reqIn) : req(reqIn.req) {}
+    explicit Connection(const crow::Request& reqIn) :
+        req(reqIn.req), session(reqIn.session)
+    {}
 
     Connection(const Connection&) = delete;
     Connection(Connection&&) = delete;
@@ -47,6 +49,7 @@ struct Connection : std::enable_shared_from_this<Connection>
     virtual ~Connection() = default;
     virtual boost::urls::url_view url() = 0;
     boost::beast::http::request<boost::beast::http::string_body> req;
+    std::shared_ptr<persistent_data::UserSession> session;
 };
 
 template <typename Adaptor>
@@ -213,7 +216,7 @@ class ConnectionImpl : public Connection
                 BMCWEB_LOG_ERROR("Error closing websocket {}", ec);
                 return;
             }
-            });
+        });
     }
 
     boost::urls::url_view url() override
diff --git a/include/kvm_websocket.hpp b/include/kvm_websocket.hpp
index 6459c311..7f673596 100644
--- a/include/kvm_websocket.hpp
+++ b/include/kvm_websocket.hpp
@@ -13,7 +13,8 @@ namespace crow
 namespace obmc_kvm
 {
 
-static constexpr const uint maxSessions = 4;
+static constexpr const uint maxSessions = 1;
+int kvmActiveStatus = 0;
 
 class KvmSession
 {
@@ -25,20 +26,20 @@ class KvmSession
             boost::asio::ip::make_address("127.0.0.1"), 5900);
         hostSocket.async_connect(
             endpoint, [this, &connIn](const boost::system::error_code& ec) {
-                if (ec)
+            if (ec)
+            {
+                BMCWEB_LOG_ERROR(
+                    "conn:{}, Couldn't connect to KVM socket port: {}",
+                    logPtr(&conn), ec);
+                if (ec != boost::asio::error::operation_aborted)
                 {
-                    BMCWEB_LOG_ERROR(
-                        "conn:{}, Couldn't connect to KVM socket port: {}",
-                        logPtr(&conn), ec);
-                    if (ec != boost::asio::error::operation_aborted)
-                    {
-                        connIn.close("Error in connecting to KVM port");
-                    }
-                    return;
+                    connIn.close("Error in connecting to KVM port");
                 }
+                return;
+            }
 
-                doRead();
-            });
+            doRead();
+        });
     }
 
     void onMessage(const std::string& data)
@@ -97,7 +98,7 @@ class KvmSession
             outputBuffer.consume(bytesRead);
 
             doRead();
-            });
+        });
     }
 
     void doWrite()
@@ -164,26 +165,42 @@ inline void requestRoutes(App& app)
         .websocket()
         .privileges(redfish::privileges::privilegeSetConfigureManager)
         .onopen([](crow::websocket::Connection& conn) {
-            BMCWEB_LOG_DEBUG("Connection {} opened", logPtr(&conn));
+        BMCWEB_LOG_DEBUG("Connection {} opened", logPtr(&conn));
 
-            if (sessions.size() == maxSessions)
-            {
-                conn.close("Max sessions are already connected");
-                return;
-            }
+        if (sessions.size() == maxSessions)
+        {
+            conn.close("Max sessions are already connected");
+            return;
+        }
 
-            sessions[&conn] = std::make_unique<KvmSession>(conn);
-        })
+        sessions[&conn] = std::make_unique<KvmSession>(conn);
+        conn.session->kvmConnections++;
+        kvmActiveStatus = 1;
+    })
         .onclose([](crow::websocket::Connection& conn, const std::string&) {
-            sessions.erase(&conn);
-        })
+        sessions.erase(&conn);
+        conn.session->kvmConnections--;
+        kvmActiveStatus = 0;
+    })
         .onmessage([](crow::websocket::Connection& conn,
                       const std::string& data, bool) {
-            if (sessions[&conn])
-            {
-                sessions[&conn]->onMessage(data);
-            }
-        });
+        if (sessions[&conn])
+        {
+            sessions[&conn]->onMessage(data);
+        }
+    });
+    BMCWEB_ROUTE(app, "/kvm/kvmActiveStatus")
+        .privileges({{"ConfigureComponents", "ConfigureManager"}})
+        .methods(boost::beast::http::verb::get)(
+            [](const crow::Request& req,
+               const std::shared_ptr<bmcweb::AsyncResp>& ares) {
+        if (req.session == nullptr)
+        {
+            BMCWEB_LOG_DEBUG("Internal Server Error");
+            return;
+        }
+        ares->res.jsonValue["kvmActiveStatus"] = kvmActiveStatus;
+    });
 }
 
 } // namespace obmc_kvm
diff --git a/include/nbd_proxy.hpp b/include/nbd_proxy.hpp
index 85485554..4ea18611 100644
--- a/include/nbd_proxy.hpp
+++ b/include/nbd_proxy.hpp
@@ -48,7 +48,10 @@ struct NbdProxyServer : std::enable_shared_from_this<NbdProxyServer>
         peerSocket(connIn.getIoContext()),
         acceptor(connIn.getIoContext(), stream_protocol::endpoint(socketId)),
         connection(connIn)
-    {}
+    {
+        std::filesystem::path endpointPath(endpointIdIn);
+        endpointIndex = std::stoul(endpointPath.filename().string());
+    }
 
     NbdProxyServer(const NbdProxyServer&) = delete;
     NbdProxyServer(NbdProxyServer&&) = delete;
@@ -76,6 +79,11 @@ struct NbdProxyServer : std::enable_shared_from_this<NbdProxyServer>
         return endpointId;
     }
 
+    unsigned getEndpointIndex() const
+    {
+        return endpointIndex;
+    }
+
     void run()
     {
         acceptor.async_accept(
@@ -164,8 +172,8 @@ struct NbdProxyServer : std::enable_shared_from_this<NbdProxyServer>
                     self2->ux2wsBuf.consume(self2->ux2wsBuf.size());
                     self2->doRead();
                 }
-                });
             });
+        });
     }
 
     void doWrite(std::function<void()>&& onDone)
@@ -211,7 +219,7 @@ struct NbdProxyServer : std::enable_shared_from_this<NbdProxyServer>
                 return;
             }
             onDone();
-            });
+        });
     }
 
     // Keeps UNIX socket endpoint file path
@@ -219,6 +227,9 @@ struct NbdProxyServer : std::enable_shared_from_this<NbdProxyServer>
     const std::string endpointId;
     const std::string path;
 
+    // endpoint id represented in unsigned int
+    unsigned endpointIndex;
+
     bool uxWriteInProgress = false;
 
     // UNIX => WebSocket buffer
@@ -331,6 +342,7 @@ inline void
         conn, *socketValue, *endpointValue, *endpointObjectPath);
 
     sessions[&conn]->run();
+    conn.session->vmNbdActive[sessions[&conn]->getEndpointIndex()] = true;
 };
 inline void onOpen(crow::websocket::Connection& conn)
 {
@@ -342,7 +354,7 @@ inline void onOpen(crow::websocket::Connection& conn)
         [&conn](const boost::system::error_code& ec,
                 const dbus::utility::ManagedObjectType& objects) {
         afterGetManagedObjects(conn, ec, objects);
-        });
+    });
 
     // We need to wait for dbus and the websockets to hook up before data is
     // sent/received.  Tell the core to hold off messages until the sockets are
@@ -360,6 +372,7 @@ inline void onClose(crow::websocket::Connection& conn,
         BMCWEB_LOG_DEBUG("No session to close");
         return;
     }
+    conn.session->vmNbdActive[sessions[&conn]->getEndpointIndex()] = false;
     // Remove reference to session in global map
     sessions.erase(session);
 }
diff --git a/include/sessions.hpp b/include/sessions.hpp
index 69249a27..ed338c24 100644
--- a/include/sessions.hpp
+++ b/include/sessions.hpp
@@ -45,6 +45,11 @@ struct UserSession
     std::string userRole{};
     std::vector<std::string> userGroups{};
 
+    // Use counter since one user can have multiple kvm connections
+    int kvmConnections = 0;
+    // currently there is only 2 nbd slots
+    std::array<bool, 2> vmNbdActive = {false, false};
+
     // There are two sources of truth for isConfigureSelfOnly:
     //  1. When pamAuthenticateUser() returns PAM_NEW_AUTHTOK_REQD.
     //  2. D-Bus User.Manager.GetUserInfo property UserPasswordExpired.
diff --git a/redfish-core/lib/redfish_sessions.hpp b/redfish-core/lib/redfish_sessions.hpp
index 356d1fd0..3b6c3bf5 100644
--- a/redfish-core/lib/redfish_sessions.hpp
+++ b/redfish-core/lib/redfish_sessions.hpp
@@ -40,6 +40,17 @@ inline void fillSessionObject(crow::Response& res,
     res.jsonValue["Name"] = "User Session";
     res.jsonValue["Description"] = "Manager User Session";
     res.jsonValue["ClientOriginIPAddress"] = session.clientIp;
+    res.jsonValue["SessionType"] = "WebUI";
+    res.jsonValue["Oem"]["AMI_WebSession"]["@odata.type"] =
+        "#AMIWebSession.v1_0_0.WebSession";
+    res.jsonValue["Oem"]["AMI_WebSession"]["KvmActive"] =
+        static_cast<bool>(session.kvmConnections);
+    res.jsonValue["Oem"]["AMI_WebSession"]["VmActive"] =
+        nlohmann::json::array();
+    for (const bool status : session.vmNbdActive)
+    {
+        res.jsonValue["Oem"]["AMI_WebSession"]["VmActive"].push_back(status);
+    }
     res.jsonValue["SessionType"] = session.sessionType;
     if (session.clientId)
     {
@@ -168,6 +179,7 @@ inline void
                 ipAddr.s_addr = remoteIpAddr;
                 asyncResp->res.jsonValue["ClientOriginIPAddress"] =
                     inet_ntoa(ipAddr);
+                asyncResp->res.jsonValue["SessionType"] = "IPMI";
             }
             catch (const sdbusplus::exception::UnpackPropertyError& error)
             {
diff --git a/static/redfish/v1/$metadata/index.xml b/static/redfish/v1/$metadata/index.xml
index 9d32da68..112de0c3 100644
--- a/static/redfish/v1/$metadata/index.xml
+++ b/static/redfish/v1/$metadata/index.xml
@@ -3440,4 +3440,8 @@
         <edmx:Include Namespace="PefService"/>
         <edmx:Include Namespace="PefService.v1_0_0"/>
     </edmx:Reference>
+    <edmx:Reference Uri="/redfish/v1/schema/AMIWebSession_v1.xml">
+        <edmx:Include Namespace="AMIWebSession"/>
+        <edmx:Include Namespace="AMIWebSession.v1_0_0"/>
+    </edmx:Reference>
 </edmx:Edmx>
diff --git a/static/redfish/v1/JsonSchemas/AMIWebSession/index.json b/static/redfish/v1/JsonSchemas/AMIWebSession/index.json
new file mode 100644
index 00000000..23604900
--- /dev/null
+++ b/static/redfish/v1/JsonSchemas/AMIWebSession/index.json
@@ -0,0 +1,44 @@
+{
+    "$id": "http://redfish.dmtf.org/schemas/v1/AMIWebSession.v1_0_0.json",
+    "$schema": "http://redfish.dmtf.org/schemas/v1/redfish-schema-v1.json",
+    "copyright": "Copyright 2014-2019 DMTF. For the full DMTF copyright policy, see http://www.dmtf.org/about/policies/copyright",
+    "definitions": {
+        "WebSession": {
+            "additionalProperties": false,
+            "description": "OEM Extension for Session",
+            "longDescription": "OEM Extension for Session to provide the Client details.",
+            "patternProperties": {
+                "^([a-zA-Z_][a-zA-Z0-9_]*)?@(odata|Redfish|Message)\\.[a-zA-Z_][a-zA-Z0-9_]*$": {
+                    "description": "This property shall specify a valid odata or Redfish property.",
+                    "type": [
+                        "array",
+                        "boolean",
+                        "integer",
+                        "number",
+                        "null",
+                        "object",
+                        "string"
+                    ]
+                }
+            },
+            "properties": {
+                "KvmActive" : {
+                    "description" : "Keyboard-Video-Mouse active status.",
+                    "longDescription": "Active status of Keyboard-Video-Mouse in current session.",
+                    "readonly": true,
+                    "type" : "boolean"
+                },
+                "VmActive" : {
+                    "description" : "Virtual Media active status.",
+                    "longDescription": "Active status of Virtual Media in current session.",
+                    "readonly": true,
+                    "type" : "array"
+                }
+            },
+            "type": "object"
+        }
+    },
+    "owningEntity": "AMI_WebSession",
+    "release": "1.0",
+    "title": "#AMIWebSession.v1_0_0"
+}
diff --git a/static/redfish/v1/schema/AMIWebSession_v1.xml b/static/redfish/v1/schema/AMIWebSession_v1.xml
new file mode 100644
index 00000000..4803c5e8
--- /dev/null
+++ b/static/redfish/v1/schema/AMIWebSession_v1.xml
@@ -0,0 +1,44 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<edmx:Edmx xmlns:edmx="http://docs.oasis-open.org/odata/ns/edmx" Version="4.0">
+
+  <edmx:Reference Uri="http://docs.oasis-open.org/odata/odata/v4.0/errata03/csd01/complete/vocabularies/Org.OData.Core.V1.xml">
+    <edmx:Include Namespace="Org.OData.Core.V1" Alias="OData"/>
+  </edmx:Reference>
+  <edmx:Reference Uri="http://docs.oasis-open.org/odata/odata/v4.0/errata03/csd01/complete/vocabularies/Org.OData.Measures.V1.xml">
+    <edmx:Include Namespace="Org.OData.Measures.V1" Alias="Measures"/>
+  </edmx:Reference>
+  <edmx:Reference Uri="http://redfish.dmtf.org/schemas/v1/RedfishExtensions_v1.xml">
+    <edmx:Include Namespace="RedfishExtensions.v1_0_0" Alias="Redfish"/>
+  </edmx:Reference>
+  <edmx:Reference Uri="http://redfish.dmtf.org/schemas/v1/Resource_v1.xml">
+    <edmx:Include Namespace="Resource"/>
+    <edmx:Include Namespace="Resource.v1_0_0"/>
+  </edmx:Reference>
+  <edmx:DataServices>
+
+    <Schema xmlns="http://docs.oasis-open.org/odata/ns/edm" Namespace="AMIWebSession">
+      <Annotation Term="Redfish.OwningEntity" String="AMI_WebSession"/>
+    </Schema>
+
+    <Schema xmlns="http://docs.oasis-open.org/odata/ns/edm" Namespace="AMIWebSession.v1_0_0">
+      <Annotation Term="Redfish.OwningEntity" String="AMI_WebSession"/>
+      <Annotation Term="Redfish.Release" String="1.0"/>
+
+      <EntityType Name="WebSession" BaseType="Resource.OemObject" Abstract="true">
+          <Annotation Term="OData.Description" String="AMI OEM Extension for Web Session"/>
+          <Annotation Term="OData.LongDescription" String="AMI OEM Extension for Web Session"/>
+
+            <Property Name="KvmActive" Type="Edm.Boolean">
+              <Annotation Term="OData.Description" String="Keyboard-Video-Mouse active status."/>
+              <Annotation Term="OData.LongDescription" String="Active status of Keyboard-Video-Mouse in current session."/>
+            </Property>
+
+            <Property Name="VmActive" Type="Collection(Edm.Boolean)">
+              <Annotation Term="OData.Description" String="Virtual Media active status."/>
+              <Annotation Term="OData.LongDescription" String="Active status of Virtual Media in current session."/>
+            </Property>
+
+      </EntityType>
+    </Schema>
+  </edmx:DataServices>
+</edmx:Edmx>
-- 
2.34.1

