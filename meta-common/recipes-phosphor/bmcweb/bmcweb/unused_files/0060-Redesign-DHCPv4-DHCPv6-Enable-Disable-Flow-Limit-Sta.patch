From c2422c91a51300c00e0d44ebe39fe1ca6328d5b0 Mon Sep 17 00:00:00 2001
From: ginugeorge <ginugeorge@ami.com>
Date: Tue, 17 Oct 2023 14:22:23 +0530
Subject: [PATCH 60/60] Redesign DHCPv4,DHCPv6 Enable/Disable Flow, Limit
 Static IPv6, Restrict IPv4 PATCH from DHCP to Static and vice versa

---
 redfish-core/lib/ethernet.hpp | 118 ++++++++++++++++++++++++++++------
 1 file changed, 97 insertions(+), 21 deletions(-)

diff --git a/redfish-core/lib/ethernet.hpp b/redfish-core/lib/ethernet.hpp
index 79447f9b..8cdde0b7 100644
--- a/redfish-core/lib/ethernet.hpp
+++ b/redfish-core/lib/ethernet.hpp
@@ -1139,6 +1139,40 @@ inline void handleSLAACAutoConfigPatch(
     });
 }
 
+inline void triggerDHCPDisable(const std::string& ifaceId, const EthernetInterfaceData& ethData, const DHCPParameters& v4dhcpParms, const DHCPParameters& v6dhcpParms, const std::shared_ptr<bmcweb::AsyncResp>& asyncResp, const bool flag)
+{
+    bool ipv4Active = translateDhcpEnabledToBool(ethData.dhcpEnabled, true);
+    bool ipv6Active = translateDhcpEnabledToBool(ethData.dhcpEnabled, false);
+
+    bool nextv4DHCPState{};
+    if(flag)
+    {
+        nextv4DHCPState = false;
+    }
+    else if(v4dhcpParms.dhcpv4Enabled)
+    {
+        nextv4DHCPState = *v4dhcpParms.dhcpv4Enabled;
+    }
+    else
+    {
+        nextv4DHCPState = ipv4Active;
+    }
+    bool nextv6DHCPState{};
+    if(!flag)
+    {
+        nextv6DHCPState = false;
+    }
+    else if(v6dhcpParms.dhcpv6OperatingMode)
+    {
+        nextv6DHCPState = (*v6dhcpParms.dhcpv6OperatingMode == "Enabled");
+    }
+    else
+    {
+        nextv6DHCPState = ipv6Active;
+    }
+    setDHCPEnabled(ifaceId, "DHCPEnabled", nextv4DHCPState, nextv6DHCPState, asyncResp);
+}
+
 inline void handleDHCPPatch(const std::string& ifaceId,
                             const EthernetInterfaceData& ethData,
                             const DHCPParameters& v4dhcpParms,
@@ -1271,6 +1305,7 @@ inline void
     handleIPv4StaticPatch(const std::string& ifaceId,
                           nlohmann::json::array_t& input,
                           const std::vector<IPv4AddressData>& ipv4Data,
+                          const EthernetInterfaceData& ethData, const DHCPParameters& v4dhcpParms, const DHCPParameters& v6dhcpParms,
                           const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
 {
     if (input.empty())
@@ -1281,6 +1316,10 @@ inline void
     }
     else if (input.size() > 1)
     {
+        if(!v4dhcpParms.dhcpv4Enabled)
+        {
+            messages::propertySizeExceeded(asyncResp->res, "IPv4StaticAddresses");
+        }
         return;
     }
 
@@ -1446,6 +1485,10 @@ inline void
             entryIdx++;
         }
     }
+    if(!v4dhcpParms.dhcpv4Enabled) // Invoke triggerDHCPDisable when DHCPv4 -> DHCPEnabled not present
+    {
+        triggerDHCPDisable(ifaceId, ethData, v4dhcpParms, v6dhcpParms, asyncResp, true);
+    }
 }
 
 inline void handleStaticNameServersPatch(
@@ -1470,6 +1513,7 @@ inline void handleStaticNameServersPatch(
 inline void handleIPv6StaticAddressesPatch(
     const std::string& ifaceId, const nlohmann::json::array_t& input,
     const std::vector<IPv6AddressData>& ipv6Data,
+    const EthernetInterfaceData& ethData, const DHCPParameters& v4dhcpParms, const DHCPParameters& v6dhcpParms,
     const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
 {
     if (input.empty())
@@ -1478,6 +1522,14 @@ inline void handleIPv6StaticAddressesPatch(
                                          "IPv6StaticAddresses");
         return;
     }
+    else if(input.size() > 16)
+    {
+        if(!v6dhcpParms.dhcpv6OperatingMode)
+        {
+            messages::propertySizeExceeded(asyncResp->res, "IPv6StaticAddresses");
+        }
+        return;
+    }
     size_t entryIdx = 1;
     std::vector<IPv6AddressData>::const_iterator nicIpEntry =
         getNextStaticIpEntry(ipv6Data.cbegin(), ipv6Data.cend());
@@ -1579,6 +1631,10 @@ inline void handleIPv6StaticAddressesPatch(
             entryIdx++;
         }
     }
+    if(!v6dhcpParms.dhcpv6OperatingMode) // Invoke triggerDHCPDisable when DHCPv6 -> OperatingMode not present
+    {
+        triggerDHCPDisable(ifaceId, ethData, v4dhcpParms, v6dhcpParms, asyncResp, false);
+    }
 }
 
 inline std::string extractParentInterfaceName(const std::string& ifaceId)
@@ -2107,7 +2163,7 @@ inline void requestEthernetInterfacesRoutes(App& app)
                                 nlohmann::json IPv4Static = *ipv4StaticAddresses;
                                 if(IPv4Static.size() > 1)
                                 {
-                                    messages::invalidIndex(asyncResp->res, 1);
+                                    messages::propertySizeExceeded(asyncResp->res, "IPv4StaticAddresses");
                                     return;
                                 }
                             }
@@ -2118,8 +2174,36 @@ inline void requestEthernetInterfacesRoutes(App& app)
                             return;
                         }
                     }
-                }    
+                }
 
+                if(dhcpv6)
+                {
+                    if (v6dhcpParms.dhcpv6OperatingMode) // DHCPv6 -> OperatingMode is present
+                    {
+                        if (((*v6dhcpParms.dhcpv6OperatingMode == "Stateful") || (*v6dhcpParms.dhcpv6OperatingMode == "Stateless")) && ipv6StaticAddresses)
+                        {
+                            messages::propertyValueConflict(asyncResp->res, "DHCPv6.OperatingMode","IPv6StaticAddresses");
+                            return;
+                        }
+                        else if (*v6dhcpParms.dhcpv6OperatingMode == "Disabled")
+                        {
+                            if (!ipv6StaticAddresses) // and IPv6StaticAddresses attribute is not present
+                            {
+                                messages::propertyMissing(asyncResp->res, "IPv6StaticAddresses");
+                                return;
+                            }
+                            else if(ipv6StaticAddresses) // and IPv6StaticAddresses attribute is present
+                            {
+                                nlohmann::json IPv6Static = *ipv6StaticAddresses;
+                                if(IPv6Static.size() > 16)
+                                {
+                                    messages::propertySizeExceeded(asyncResp->res, "IPv6StaticAddresses");
+                                    return;
+                                }
+                            }
+                        }
+                    }
+                }
 
                 handleDHCPPatch(ifaceId, ethData, v4dhcpParms, v6dhcpParms,
                                 asyncResp);
@@ -2148,23 +2232,15 @@ inline void requestEthernetInterfacesRoutes(App& app)
 
             if (ipv4StaticAddresses)
             {
-		if(!v4dhcpParms.dhcpv4Enabled)
-		{
-		   messages::propertyMissing(asyncResp->res, "DHCPv4.DHCPEnabled");
-		   return;
-		}
-		else
-		{
-		   // TODO(ed) for some reason the capture of
-		   // ipv4Addresses above is returning a const value,
-		   // not a non-const value. This doesn't really work
-		   // for us, as we need to be able to efficiently move
-		   // out the intermedia nlohmann::json objects. This
-		   // makes a copy of the structure, and operates on
-		   // that, but could be done more efficiently
-                   nlohmann::json::array_t ipv4Static = *ipv4StaticAddresses;
-                   handleIPv4StaticPatch(ifaceId, ipv4Static, ipv4Data, asyncResp);
-		}
+                // TODO(ed) for some reason the capture of
+                // ipv4Addresses above is returning a const value,
+                // not a non-const value. This doesn't really work
+                // for us, as we need to be able to efficiently move
+                // out the intermedia nlohmann::json objects. This
+                // makes a copy of the structure, and operates on
+                // that, but could be done more efficiently
+                nlohmann::json::array_t ipv4Static = *ipv4StaticAddresses;
+                handleIPv4StaticPatch(ifaceId, ipv4Static, ipv4Data, ethData, v4dhcpParms, v6dhcpParms, asyncResp);
             }
 
             if (staticNameServers)
@@ -2181,8 +2257,8 @@ inline void requestEthernetInterfacesRoutes(App& app)
 
             if (ipv6StaticAddresses)
             {
-                handleIPv6StaticAddressesPatch(ifaceId, *ipv6StaticAddresses,
-                                               ipv6Data, asyncResp);
+                handleIPv6StaticAddressesPatch(ifaceId, *ipv6StaticAddresses, ipv6Data, ethData, v4dhcpParms, v6dhcpParms,
+                                               asyncResp);
             }
 
             if (interfaceEnabled)
-- 
2.39.2

