From d771d8e37c97028f6852c01fa27b66f1f1863a33 Mon Sep 17 00:00:00 2001
From: Abinaya L <abinayal@ami.com>
Date: Thu, 25 Jan 2024 17:48:07 +0530
Subject: [PATCH 132/132] Added OOB BIOS Configuration Support in Redfish

---
 config/bmcweb.service.in             |    1 +
 config/pam-webserver                 |    3 +-
 redfish-core/include/redfish.hpp     |    5 +-
 redfish-core/lib/account_service.hpp |   68 +-
 redfish-core/lib/bios.hpp            | 2024 ++++++++++++++++++--------
 5 files changed, 1469 insertions(+), 632 deletions(-)

diff --git a/config/bmcweb.service.in b/config/bmcweb.service.in
index 29d195b7..d7a7b4c8 100644
--- a/config/bmcweb.service.in
+++ b/config/bmcweb.service.in
@@ -8,6 +8,7 @@ After=network.target
 Restart=always
 ExecReload=kill -s HUP $MAINPID
 ExecStart=@MESON_INSTALL_PREFIX@/bin/bmcweb
+ExecStop=/bin/bash /usr/bin/delete-hi-user.sh
 Type=simple
 WorkingDirectory=/home/root
 
diff --git a/config/pam-webserver b/config/pam-webserver
index a5e7af4c..74b39f94 100644
--- a/config/pam-webserver
+++ b/config/pam-webserver
@@ -3,6 +3,7 @@
 auth     include  common-auth
 # skip redfish group check for non-local user (ldap)
 auth     [success=ok perm_denied=1 default=ignore] pam_localuser.so
-auth     required pam_succeed_if.so user ingroup redfish
+auth     sufficient pam_succeed_if.so user ingroup redfish
+auth     sufficient pam_succeed_if.so user ingroup redfish-hostiface
 account  include  common-account
 password include  common-password
diff --git a/redfish-core/include/redfish.hpp b/redfish-core/include/redfish.hpp
index f0c8e7df..25a19703 100644
--- a/redfish-core/include/redfish.hpp
+++ b/redfish-core/include/redfish.hpp
@@ -233,9 +233,10 @@ class RedfishService
         requestRoutesSystems(app);
 
         requestRoutesBiosService(app);
+        // requestRoutesBiosAttributeRegistry(app);
         requestRoutesBiosReset(app);
         requestRoutesBiosSettings(app);
-        requestRoutesBiosAttributeRegistry(app);
+        requestRoutesBiosAttrRegistryService(app);
         requestRoutesBiosChangePassword(app);
 
 #ifdef BMCWEB_ENABLE_VM_NBDPROXY
@@ -306,7 +307,7 @@ class RedfishService
         requestFipsManagerRoutes(app);
 
         requestRoutesPefService(app);
-        //PcieSwitch
+        // PcieSwitch
         requestRoutesPcieSwitchCollection(app);
         requestRoutesPcieSwitchInstanceCollection(app);
         requestRoutesPcieSwitchPortsCollection(app);
diff --git a/redfish-core/lib/account_service.hpp b/redfish-core/lib/account_service.hpp
index 4a69c5e6..5796d56b 100644
--- a/redfish-core/lib/account_service.hpp
+++ b/redfish-core/lib/account_service.hpp
@@ -1956,19 +1956,63 @@ inline void handleAccountCollectionGet(
 
                 return;
             }
+            crow::connections::systemBus->async_method_call(
+                [asyncResp, thisUser, userCanSeeAllAccounts, userCanSeeSelf,
+                 user, &memberArray](
+                    const boost::system::error_code ec,
+                    const std::map<std::string, dbus::utility::DbusVariantType>&
+                        userInfo) {
+                if (ec)
+                {
+                    BMCWEB_LOG_ERROR("GetUserInfo failed");
+                    messages::internalError(asyncResp->res);
+                    return;
+                }
+                const std::vector<std::string>* userGroupPtr = nullptr;
+                auto userInfoIter = userInfo.find("UserGroups");
+                if (userInfoIter != userInfo.end())
+                {
+                    userGroupPtr = std::get_if<std::vector<std::string>>(
+                        &userInfoIter->second);
+                }
+                if (userGroupPtr == nullptr)
+                {
+                    BMCWEB_LOG_ERROR("User Group not found");
+                    messages::internalError(asyncResp->res);
+                    return;
+                }
 
-            // As clarified by Redfish here:
-            // https://redfishforum.com/thread/281/manageraccountcollection-change-allows-account-enumeration
-            // Users without ConfigureUsers, only see their own
-            // account. Users with ConfigureUsers, see all
-            // accounts.
-            if (userCanSeeAllAccounts || (thisUser == user && userCanSeeSelf))
-            {
-                nlohmann::json::object_t member;
-                member["@odata.id"] = boost::urls::format(
-                    "/redfish/v1/AccountService/Accounts/{}", user);
-                memberArray.emplace_back(std::move(member));
-            }
+                // If the host interface user found, then
+                // skip that user and don't add in response.
+                auto found = std::find_if(userGroupPtr->begin(),
+                                          userGroupPtr->end(),
+                                          [](const auto& group) {
+                    return (group == "redfish-hostiface") ? true : false;
+                });
+                if (found == userGroupPtr->end())
+                {
+                    // As clarified by Redfish here:
+                    // https://redfishforum.com/thread/281/manageraccountcollection-change-allows-account-enumeration
+                    // Users without ConfigureUsers, only
+                    // see their own account. Users with
+                    // ConfigureUsers, see all accounts.
+                    if (userCanSeeAllAccounts ||
+                        (thisUser == user && userCanSeeSelf))
+                    {
+                        memberArray.push_back(
+                            {{"@odata.id",
+                              "/redfish/v1/AccountService/Accounts/" + user}});
+                    }
+                }
+                else
+                {
+                    BMCWEB_LOG_DEBUG("Skip the HostInterface User");
+                }
+                asyncResp->res.jsonValue["Members@odata.count"] =
+                    memberArray.size();
+            },
+                "xyz.openbmc_project.User.Manager", "/xyz/openbmc_project/user",
+                "xyz.openbmc_project.User.Manager", "GetUserInfo", user);
         }
         asyncResp->res.jsonValue["Members@odata.count"] = memberArray.size();
     });
diff --git a/redfish-core/lib/bios.hpp b/redfish-core/lib/bios.hpp
index be199a09..e00b8368 100644
--- a/redfish-core/lib/bios.hpp
+++ b/redfish-core/lib/bios.hpp
@@ -9,830 +9,1588 @@
 
 namespace redfish
 {
+namespace bios
+{
+/**
+ * BiosConfig Manager Dbus info
+ */
+constexpr const char* biosConfigObj =
+    "/xyz/openbmc_project/bios_config/manager";
+constexpr const char* biosConfigIface =
+    "xyz.openbmc_project.BIOSConfig.Manager";
 
-/*baseBIOSTable
-map{attributeName,struct{attributeType,readonlyStatus,displayname,
-              description,menuPath,current,default,
-              array{struct{optionstring,optionvalue}}}}
-*/
-
-using BiosBaseTableType = boost::container::flat_map<
+using GetObjectType =
+    std::vector<std::pair<std::string, std::vector<std::string>>>;
+/**
+ * BiosService DBus types
+ */
+using BaseBIOSTable = boost::container::flat_map<
     std::string,
     std::tuple<
         std::string, bool, std::string, std::string, std::string,
-        std::variant<int64_t, std::string>, std::variant<int64_t, std::string>,
+        std::variant<int64_t, std::string, bool>,
+        std::variant<int64_t, std::string, bool>,
         std::vector<std::tuple<std::string, std::variant<int64_t, std::string>,
                                std::string>>>>;
 
-using BiosBaseTableItemType = std::pair<
+using BaseBIOSTableItem = std::pair<
     std::string,
     std::tuple<
         std::string, bool, std::string, std::string, std::string,
-        std::variant<int64_t, std::string>, std::variant<int64_t, std::string>,
+        std::variant<int64_t, std::string, bool>,
+        std::variant<int64_t, std::string, bool>,
         std::vector<std::tuple<std::string, std::variant<int64_t, std::string>,
                                std::string>>>>;
 
-using OptionsItemType =
-    std::tuple<std::string, std::variant<int64_t, std::string>, std::string>;
+using PendingAttrType = boost::container::flat_map<
+    std::string,
+    std::tuple<std::string, std::variant<int64_t, std::string, bool>>>;
 
-using PendingAttributesType = boost::container::flat_map<
-    std::string, std::tuple<std::string, std::variant<int64_t, std::string>>>;
+using PendingAttrItemType = std::pair<
+    std::string,
+    std::tuple<std::string, std::variant<int64_t, std::string, bool>>>;
 
-using PendingAttributesItemType =
-    std::pair<std::string,
-              std::tuple<std::string, std::variant<int64_t, std::string>>>;
+using AttrBoundType =
+    std::tuple<std::string, std::variant<int64_t, std::string>, std::string>;
 
-enum BiosBaseTableIndex
+enum BaseBiosTableIndex
 {
-    biosBaseAttrType = 0,
-    biosBaseReadonlyStatus,
-    biosBaseDisplayName,
-    biosBaseDescription,
-    biosBaseMenuPath,
-    biosBaseCurrValue,
-    biosBaseDefaultValue,
-    biosBaseOptions
+    baseBiosAttrType = 0,
+    baseBiosReadonlyStatus,
+    baseBiosDisplayName,
+    baseBiosDescription,
+    baseBiosMenuPath,
+    baseBiosCurrValue,
+    baseBiosDefaultValue,
+    baseBiosBoundValues
 };
-enum OptionsItemIndex
+
+enum BaseBiosBoundIndex
 {
-    optItemType = 0,
-    optItemValue,
-    optItemText
+    baseBiosBoundType = 0,
+    baseBiosBoundValue
 };
 
-enum PendingAttributesIndex
+enum BiosPendingAttributesIndex
 {
-    pendingAttrType = 0,
-    pendingAttrValue
+    biosPendingAttrType = 0,
+    biosPendingAttrValue
 };
-static std::string mapAttrTypeToRedfish(const std::string_view typeDbus)
+
+/**
+ *@brief Translates Base BIOS Table attribute type from DBUS property value to
+ *Redfish string type.
+ *
+ *@param[in] attrType The DBUS BIOS attribute type value
+ *
+ *@return Returns as a string, the attribute type required for Redfish.
+ *If attribute type didn't match, then returns 'UNKNOWN' string.
+ */
+static std::string getBiosAttrType(const std::string& attrType)
 {
-    std::string ret;
-    if (typeDbus == "xyz.openbmc_project.BIOSConfig."
-                    "Manager.AttributeType.String")
+    std::string type;
+    if (attrType ==
+        "xyz.openbmc_project.BIOSConfig.Manager.AttributeType.Enumeration")
     {
-        ret = "String";
+        type = "Enumeration";
     }
-    else if (typeDbus == "xyz.openbmc_project.BIOSConfig."
-                         "Manager.AttributeType.Integer")
+    else if (attrType ==
+             "xyz.openbmc_project.BIOSConfig.Manager.AttributeType.String")
     {
-        ret = "Integer";
+        type = "String";
     }
-    else if (typeDbus == "xyz.openbmc_project.BIOSConfig."
-                         "Manager.AttributeType.Enumeration")
+    else if (attrType ==
+             "xyz.openbmc_project.BIOSConfig.Manager.AttributeType.Password")
     {
-        ret = "Enumeration";
+        type = "Password";
+    }
+    else if (attrType ==
+             "xyz.openbmc_project.BIOSConfig.Manager.AttributeType.Integer")
+    {
+        type = "Integer";
+    }
+    else if (attrType ==
+             "xyz.openbmc_project.BIOSConfig.Manager.AttributeType.Boolean")
+    {
+        type = "Boolean";
     }
     else
     {
-        ret = "UNKNOWN";
+        type = "UNKNOWN";
     }
-
-    return ret;
+    return type;
 }
 
-static std::string mapBoundTypeToRedfish(const std::string_view typeDbus)
+/**
+ *@brief Translates Base BIOS Table attribute type from Redfish string type to
+ *DBUS property value.
+ *
+ *@param[in] attrType The Redfish BIOS attribute string type value
+ *
+ *@return Returns as a string, the attribute type required for DBUS.
+ *If attribute type didn't match, then returns 'UNKNOWN' string.
+ */
+static std::string getDbusBiosAttrType(const std::string& attrType)
 {
-    std::string ret;
-    if (typeDbus ==
-        "xyz.openbmc_project.BIOSConfig.Manager.BoundType.ScalarIncrement")
+    std::string type;
+    if (attrType == "Enumeration")
     {
-        ret = "ScalarIncrement";
+        type =
+            "xyz.openbmc_project.BIOSConfig.Manager.AttributeType.Enumeration";
     }
-    else if (typeDbus ==
-             "xyz.openbmc_project.BIOSConfig.Manager.BoundType.LowerBound")
+    else if (attrType == "String")
     {
-        ret = "LowerBound";
+        type = "xyz.openbmc_project.BIOSConfig.Manager.AttributeType.String";
     }
-    else if (typeDbus ==
-             "xyz.openbmc_project.BIOSConfig.Manager.BoundType.UpperBound")
+    else if (attrType == "Password")
+    {
+        type = "xyz.openbmc_project.BIOSConfig.Manager.AttributeType.Password";
+    }
+    else if (attrType == "Integer")
+    {
+        type = "xyz.openbmc_project.BIOSConfig.Manager.AttributeType.Integer";
+    }
+    else if (attrType == "Boolean")
     {
-        ret = "UpperBound";
+        type = "xyz.openbmc_project.BIOSConfig.Manager.AttributeType.Boolean";
     }
-    else if (typeDbus ==
-             "xyz.openbmc_project.BIOSConfig.Manager.BoundType.MinStringLength")
+    else
+    {
+        type = "UNKNOWN";
+    }
+    return type;
+}
+
+/**
+ *@brief Translates Base BIOS Table attribute bound value type from DBUS
+ *property value to Redfish string type.
+ *
+ *@param[in] attrType The DBUS BIOS Bound value attribute type value
+ *
+ *@return Returns as a string, the attribute bound value type required for
+ *Redfish. If attribute type didn't match, then returns 'UNKNOWN' string.
+ */
+static std::string getBiosBoundValType(const std::string& boundValType)
+{
+    std::string type;
+    if (boundValType ==
+        "xyz.openbmc_project.BIOSConfig.Manager.BoundType.ScalarIncrement")
+    {
+        type = "ScalarIncrement";
+    }
+    else if (boundValType ==
+             "xyz.openbmc_project.BIOSConfig.Manager.BoundType.LowerBound")
     {
-        ret = "MinStringLength";
+        type = "LowerBound";
     }
-    else if (typeDbus ==
-             "xyz.openbmc_project.BIOSConfig.Manager.BoundType.MaxStringLength")
+    else if (boundValType ==
+             "xyz.openbmc_project.BIOSConfig.Manager.BoundType.UpperBound")
     {
-        ret = "MaxStringLength";
+        type = "UpperBound";
     }
-    else if (typeDbus ==
+    else if (boundValType ==
              "xyz.openbmc_project.BIOSConfig.Manager.BoundType.OneOf")
     {
-        ret = "OneOf";
+        type = "OneOf";
     }
     else
     {
-        ret = "UNKNOWN";
+        type = "UNKNOWN";
     }
-
-    return ret;
+    return type;
 }
 
 /**
- * BiosService class supports handle get method for bios.
+ *@brief Translates Reset BIOS to Default Settings status type from DBUS
+ *property value to Redfish string type.
+ *
+ *@param[in] biosMode The DBUS BIOS Reset BIOS to Default Setting status value
+ *
+ *@return Returns as a string, the Reset BIOS Settings to default type required
+ *for Redfish. If attribute type didn't match, then returns 'UNKNOWN' string.
  */
-inline void
-    handleBiosServiceGet(crow::App& app, const crow::Request& req,
-                         const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
-                         const std::string& systemName)
+static std::string getBiosDefaultSettingsMode(const std::string& biosMode)
 {
-    if (!redfish::setUpRedfishRoute(app, req, asyncResp))
+    std::string mode;
+    if (biosMode == "xyz.openbmc_project.BIOSConfig.Manager.ResetFlag.NoAction")
     {
-        return;
+        mode = "NoAction";
     }
-    if constexpr (bmcwebEnableMultiHost)
+    else if (biosMode ==
+             "xyz.openbmc_project.BIOSConfig.Manager.ResetFlag.FactoryDefaults")
     {
-        // Option currently returns no systems.  TBD
-        messages::resourceNotFound(asyncResp->res, "ComputerSystem",
-                                   systemName);
-        return;
+        mode = "FactoryDefaults";
     }
-    if (systemName != "system")
+    else if (
+        biosMode ==
+        "xyz.openbmc_project.BIOSConfig.Manager.ResetFlag.FailSafeDefaults")
     {
-        messages::resourceNotFound(asyncResp->res, "ComputerSystem",
-                                   systemName);
-        return;
+        mode = "FailSafeDefaults";
     }
-    asyncResp->res.jsonValue["@odata.id"] = "/redfish/v1/Systems/system/Bios";
-    asyncResp->res.jsonValue["@odata.type"] = "#Bios.v1_2_0.Bios";
-    asyncResp->res.jsonValue["Name"] = "BIOS Configuration";
-    asyncResp->res.jsonValue["Description"] = "BIOS Configuration Service";
-    asyncResp->res.jsonValue["Id"] = "BIOS";
-    asyncResp->res.jsonValue["Actions"]["#Bios.ResetBios"] = {
-        {"target", "/redfish/v1/Systems/system/Bios/Actions/Bios.ResetBios"}};
-
-    asyncResp->res.jsonValue["Actions"]["#Bios.ChangePassword"] = {
-        {"target", "/redfish/v1/Systems/system/Bios/Actions/"
-                   "Bios.ChangePassword"}};
-
-    asyncResp->res.jsonValue["Settings"]["@odata.id"] =
-        "/redfish/v1/Systems/system/Bios/Settings";
-
-    // Get the ActiveSoftwareImage and SoftwareImages
-    sw_util::populateSoftwareInformation(asyncResp, sw_util::biosPurpose, "",
-                                         true);
+    else
+    {
+        mode = "UNKNOWN";
+    }
+    return mode;
+}
 
-    asyncResp->res.jsonValue["@Redfish.Settings"] = {
-        {"@odata.type", "#Settings.v1_3_0.Settings"},
-        {"SettingsObject",
-         {{"@odata.id", "/redfish/v1/Systems/system/Bios/Settings"}}}};
-    asyncResp->res.jsonValue["AttributeRegistry"] = "BiosAttributeRegistry";
-    asyncResp->res.jsonValue["Attributes"] = nlohmann::json::object();
+/**
+ *@brief sets the Reset BIOS Settings to default property.
+ *
+ * @param[in]       ResetBiosToDefaultsPending    Reset BIOS Settings to Default
+ *status
+ * @param[in,out]   asyncResp   Async HTTP response.
+ *
+ * @return None.
+ */
+static void
+    setResetBiosSettings(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                         const bool& resetBiosToDefaultsPending)
+{
+    BMCWEB_LOG_DEBUG("Set Reset Bios Settings to Defaults Pending Status");
 
     crow::connections::systemBus->async_method_call(
-        [asyncResp](const boost::system::error_code ec,
-                    const dbus::utility::MapperGetObject& getObjectType) {
-        if (ec)
+        [asyncResp, resetBiosToDefaultsPending](
+            const boost::system::error_code ec, const GetObjectType& objType) {
+        if (ec || objType.empty())
         {
-            BMCWEB_LOG_ERROR("ObjectMapper::GetObject call failed: {}", ec);
+            BMCWEB_LOG_ERROR("GetObject for path biosConfigObj");
             messages::internalError(asyncResp->res);
-
             return;
         }
-
-        if (getObjectType.empty())
+        const std::string& biosService = objType.begin()->first;
+        std::string biosMode;
+        if (resetBiosToDefaultsPending)
         {
-            BMCWEB_LOG_ERROR("getObjectType is empty.");
-            messages::internalError(asyncResp->res);
-
-            return;
+            biosMode =
+                "xyz.openbmc_project.BIOSConfig.Manager.ResetFlag.FactoryDefaults";
+        }
+        else
+        {
+            biosMode =
+                "xyz.openbmc_project.BIOSConfig.Manager.ResetFlag.NoAction";
         }
-
-        const std::string& service = getObjectType.begin()->first;
-
         crow::connections::systemBus->async_method_call(
-            [asyncResp](const boost::system::error_code ec2,
-                        const std::variant<BiosBaseTableType>& retBiosTable) {
-            if (ec2)
-            {
-                BMCWEB_LOG_ERROR("getBiosAttributes DBUS error: {}", ec2);
-                messages::internalError(asyncResp->res);
-                return;
-            }
-            const BiosBaseTableType* baseBiosTable =
-                std::get_if<BiosBaseTableType>(&retBiosTable);
-            nlohmann::json& attributesJson =
-                asyncResp->res.jsonValue["Attributes"];
-            if (baseBiosTable == nullptr)
+            [asyncResp](const boost::system::error_code ec) {
+            if (ec)
             {
-                BMCWEB_LOG_ERROR("baseBiosTable is empty");
+                BMCWEB_LOG_DEBUG("DBUS response error for "
+                                 "Set Reset BIOS setting to default status.");
                 messages::internalError(asyncResp->res);
                 return;
             }
-            for (const BiosBaseTableItemType& item : *baseBiosTable)
-            {
-                const std::string& key = item.first;
-                const std::string& itemType =
-                    std::get<biosBaseAttrType>(item.second);
-                std::string attrType = mapAttrTypeToRedfish(itemType);
-                if (attrType == "String" || attrType == "Enumeration")
-                {
-                    const std::string* currValue = std::get_if<std::string>(
-                        &std::get<biosBaseCurrValue>(item.second));
-                    attributesJson.emplace(
-                        key, currValue != nullptr ? *currValue : "");
-                }
-                else if (attrType == "Integer")
-                {
-                    const int64_t* currValue = std::get_if<int64_t>(
-                        &std::get<biosBaseCurrValue>(item.second));
-                    attributesJson.emplace(
-                        key, currValue != nullptr ? *currValue : 0);
-                }
-                else
-                {
-                    BMCWEB_LOG_ERROR("Unsupported attribute type.");
-                }
-            }
+            messages::success(asyncResp->res);
         },
-            service, "/xyz/openbmc_project/bios_config/manager",
-            "org.freedesktop.DBus.Properties", "Get",
-            "xyz.openbmc_project.BIOSConfig.Manager", "BaseBIOSTable");
+            biosService, biosConfigObj, "org.freedesktop.DBus.Properties",
+            "Set", biosConfigIface, "ResetBIOSSettings",
+            std::variant<std::string>(biosMode));
     },
         "xyz.openbmc_project.ObjectMapper",
         "/xyz/openbmc_project/object_mapper",
-        "xyz.openbmc_project.ObjectMapper", "GetObject",
-        "/xyz/openbmc_project/bios_config/manager",
-        std::array<const char*, 0>());
-}
-
-inline void requestRoutesBiosService(App& app)
-{
-    BMCWEB_ROUTE(app, "/redfish/v1/Systems/<str>/Bios/")
-        .privileges(redfish::privileges::getBios)
-        .methods(boost::beast::http::verb::get)(
-            std::bind_front(handleBiosServiceGet, std::ref(app)));
+        "xyz.openbmc_project.ObjectMapper", "GetObject", biosConfigObj,
+        std::array<const char*, 1>{biosConfigIface});
 }
 
 /**
- * BiosChangePassword class supports handle POST method for change bios
- * password. The class retrieves and sends data directly to D-Bus.
+ *@brief Reads the Reset BIOS Settings to default property.
+ *
+ * @param[in,out]   asyncResp   Async HTTP response.
+ *
+ * @return None.
  */
-inline void requestRoutesBiosChangePassword(App& app)
+static void
+    getResetBiosSettings(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
 {
-    BMCWEB_ROUTE(app,
-                 "/redfish/v1/Systems/system/Bios/Actions/Bios.ChangePassword/")
-        .privileges(redfish::privileges::postBios)
-        .methods(boost::beast::http::verb::post)(
-            [](const crow::Request& req,
-               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp) {
-        std::string currentPassword, newPassword, userName;
-        if (!json_util::readJsonPatch(
-                req, asyncResp->res, "NewPassword", newPassword, "OldPassword",
-                currentPassword, "PasswordName", userName))
-        {
-            return;
-        }
-        if (currentPassword.empty())
-        {
-            messages::actionParameterUnknown(asyncResp->res, "ChangePassword",
-                                             "OldPassword");
-            return;
-        }
-        if (newPassword.empty())
-        {
-            messages::actionParameterUnknown(asyncResp->res, "ChangePassword",
-                                             "NewPassword");
-            return;
-        }
-        if (userName.empty())
-        {
-            messages::actionParameterUnknown(asyncResp->res, "ChangePassword",
-                                             "PasswordName");
-            return;
-        }
+    BMCWEB_LOG_DEBUG("Get Reset Bios Settings to Defaults Pending Status");
 
-        // In Intel BIOS, we are not supporting user password in BIOS setup
-        if (userName == "UserPassword")
+    crow::connections::systemBus->async_method_call(
+        [asyncResp](const boost::system::error_code ec,
+
+                    const GetObjectType& objType) {
+        if (ec || objType.empty())
         {
-            messages::actionParameterUnknown(asyncResp->res, "ChangePassword",
-                                             "PasswordName");
+            BMCWEB_LOG_ERROR("GetObject for path biosConfigObj");
+            messages::internalError(asyncResp->res);
             return;
         }
-
+        const std::string& biosService = objType.begin()->first;
         crow::connections::systemBus->async_method_call(
-            [asyncResp](const boost::system::error_code ec) {
+            [asyncResp](
+                const boost::system::error_code ec,
+                const std::variant<std::string>& resetBiosSettingsMode) {
             if (ec)
             {
-                BMCWEB_LOG_CRITICAL("Failed in doPost(BiosChangePassword) {}",
-                                    ec);
+                BMCWEB_LOG_DEBUG("DBUS response error for "
+                                 "Get Reset BIOS setting to default status.");
+                messages::internalError(asyncResp->res);
+                return;
+            }
+            const std::string* value =
+                std::get_if<std::string>(&resetBiosSettingsMode);
+            if (value == nullptr)
+            {
+                BMCWEB_LOG_DEBUG(
+                    "Null value returned for Reset BIOS Settings status");
+                messages::internalError(asyncResp->res);
+                return;
+            }
+
+            std::string biosMode = getBiosDefaultSettingsMode(*value);
+
+            if (biosMode == "NoAction")
+            {
+                asyncResp->res.jsonValue["ResetBiosToDefaultsPending"] = false;
+            }
+            else if ((biosMode == "FactoryDefaults") ||
+                     (biosMode == "FailSafeDefaults"))
+            {
+                asyncResp->res.jsonValue["ResetBiosToDefaultsPending"] = true;
+            }
+            else
+            {
+                BMCWEB_LOG_DEBUG("Invalid Reset BIOS Settings Status");
                 messages::internalError(asyncResp->res);
                 return;
             }
         },
-            "xyz.openbmc_project.BIOSConfigManager",
-            "/xyz/openbmc_project/bios_config/password",
-            "xyz.openbmc_project.BIOSConfig.Password", "ChangePassword",
-            userName, currentPassword, newPassword);
-    });
+            biosService, biosConfigObj, "org.freedesktop.DBus.Properties",
+            "Get", biosConfigIface, "ResetBIOSSettings");
+    },
+        "xyz.openbmc_project.ObjectMapper",
+        "/xyz/openbmc_project/object_mapper",
+        "xyz.openbmc_project.ObjectMapper", "GetObject", biosConfigObj,
+        std::array<const char*, 1>{biosConfigIface});
 }
 
 /**
- * BiosSettings class supports handle GET/PATCH method for
- * BIOS configuration pending settings.
+ *@brief Reads the BIOS Base Table DBUS property and update the Bios Attributes
+ *response.
+ *
+ * @param[in,out]   asyncResp   Async HTTP response.
+ *
+ * @return None.
  */
-inline void requestRoutesBiosSettings(App& app)
+static void
+    getBiosAttributes(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
 {
-    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Bios/Settings")
-        .privileges(redfish::privileges::getBios)
-        .methods(boost::beast::http::verb::get)(
-            [](const crow::Request&,
-               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp) {
-        asyncResp->res.jsonValue["@odata.id"] =
-            "/redfish/v1/Systems/system/Bios/Settings";
-        asyncResp->res.jsonValue["@odata.type"] = "#Bios.v1_1_0.Bios";
-        asyncResp->res.jsonValue["Name"] = "Bios Settings Version 1";
-        asyncResp->res.jsonValue["Id"] = "BiosSettingsV1";
-        asyncResp->res.jsonValue["AttributeRegistry"] = "BiosAttributeRegistry";
+    crow::connections::systemBus->async_method_call(
+        [asyncResp](const boost::system::error_code ec,
+                    const GetObjectType& objType) {
+        if (ec || objType.empty())
+        {
+            BMCWEB_LOG_ERROR("GetObject for path biosConfigObj");
+            messages::internalError(asyncResp->res);
+            return;
+        }
+
+        const std::string& biosService = objType.begin()->first;
 
         crow::connections::systemBus->async_method_call(
             [asyncResp](const boost::system::error_code ec,
-                        const dbus::utility::MapperGetObject& getObjectType) {
+                        const std::variant<BaseBIOSTable>& baseBiosTableResp) {
             if (ec)
             {
-                BMCWEB_LOG_ERROR("ObjectMapper::GetObject call failed: {}", ec);
+                BMCWEB_LOG_ERROR("Get BaseBIOSTable DBus response error");
                 messages::internalError(asyncResp->res);
-
                 return;
             }
+            const BaseBIOSTable* baseBiosTable =
+                std::get_if<BaseBIOSTable>(&baseBiosTableResp);
 
-            if (getObjectType.empty())
+            nlohmann::json& attributesJson =
+                asyncResp->res.jsonValue["Attributes"];
+            if (baseBiosTable == nullptr)
             {
-                BMCWEB_LOG_ERROR("getObjectType is empty.");
+                BMCWEB_LOG_ERROR("Empty BaseBIOSTable");
                 messages::internalError(asyncResp->res);
-
                 return;
             }
-
-            std::string service = getObjectType.begin()->first;
-
-            crow::connections::systemBus->async_method_call(
-                [asyncResp](const boost::system::error_code ec2,
-                            const std::variant<PendingAttributesType>&
-                                retPendingAttributes) {
-                if (ec2)
-                {
-                    BMCWEB_LOG_ERROR("getBiosSettings DBUS error: {}", ec2);
-                    messages::resourceNotFound(
-                        asyncResp->res, "Systems/system/Bios", "Settings");
-                    return;
-                }
-
-                const PendingAttributesType* pendingAttributes =
-                    std::get_if<PendingAttributesType>(&retPendingAttributes);
-                nlohmann::json& attributesJson =
-                    asyncResp->res.jsonValue["Attributes"];
-                if (pendingAttributes == nullptr)
+            for (const BaseBIOSTableItem& attrIt : *baseBiosTable)
+            {
+                const std::string& attr = attrIt.first;
+
+                // read the attribute type at 0th field and convert from
+                // dbus to string format
+                std::string attrType = getBiosAttrType(
+                    std::string(std::get<BaseBiosTableIndex::baseBiosAttrType>(
+                        attrIt.second)));
+                if ((attrType == "String") || (attrType == "Enumeration"))
                 {
-                    BMCWEB_LOG_ERROR("pendingAttributes is empty");
-                    messages::internalError(asyncResp->res);
-                    return;
+                    // read the current value of attribute at 5th field
+                    const std::string* attrCurrValue = std::get_if<std::string>(
+                        &std::get<BaseBiosTableIndex::baseBiosCurrValue>(
+                            attrIt.second));
+                    if (attrCurrValue != nullptr)
+                    {
+                        attributesJson.emplace(attr, *attrCurrValue);
+                    }
+                    else
+                    {
+                        attributesJson.emplace(attr, std::string(""));
+                    }
                 }
-
-                for (const PendingAttributesItemType& pendingAttributesItem :
-                     *pendingAttributes)
+                else if ((attrType == "Integer") || (attrType == "Boolean"))
                 {
-                    const std::string& biosAttrType =
-                        std::get<pendingAttrType>(pendingAttributesItem.second);
-
-                    std::string itemType = mapAttrTypeToRedfish(biosAttrType);
-
-                    if (itemType == "String" || itemType == "Enumeration")
+                    // read the current value of attribute at 5th field
+                    const int64_t* attrCurrValue = std::get_if<int64_t>(
+                        &std::get<BaseBiosTableIndex::baseBiosCurrValue>(
+                            attrIt.second));
+                    if (attrCurrValue != nullptr)
                     {
-                        const std::string* currValue = std::get_if<std::string>(
-                            &std::get<pendingAttrValue>(
-                                pendingAttributesItem.second));
-
-                        if (!currValue)
+                        if (attrType == "Boolean")
                         {
-                            BMCWEB_LOG_ERROR(
-                                "No string data in pending attributes item data");
-                            messages::internalError(asyncResp->res);
-                            return;
+                            if (*attrCurrValue)
+                            {
+                                attributesJson.emplace(attr, true);
+                            }
+                            else
+                            {
+                                attributesJson.emplace(attr, false);
+                            }
                         }
-                        attributesJson.emplace(pendingAttributesItem.first,
-                                               *currValue);
-                    }
-                    else if (itemType == "Integer")
-                    {
-                        const int64_t* currValue =
-                            std::get_if<int64_t>(&std::get<pendingAttrValue>(
-                                pendingAttributesItem.second));
-
-                        if (!currValue)
+                        else
                         {
-                            BMCWEB_LOG_ERROR(
-                                "No int64_t data in pending attributes item data");
-                            messages::internalError(asyncResp->res);
-                            return;
+                            attributesJson.emplace(attr, *attrCurrValue);
                         }
-
-                        attributesJson.emplace(pendingAttributesItem.first,
-                                               *currValue);
                     }
                     else
                     {
-                        BMCWEB_LOG_ERROR("Unsupported attribute type.");
-                        messages::internalError(asyncResp->res);
-                        return;
+                        if (attrType == "Boolean")
+                        {
+                            attributesJson.emplace(attr, false);
+                        }
+                        else
+                        {
+                            attributesJson.emplace(attr, 0);
+                        }
                     }
                 }
-            },
-                service, "/xyz/openbmc_project/bios_config/manager",
-                "org.freedesktop.DBus.Properties", "Get",
-                "xyz.openbmc_project.BIOSConfig.Manager", "PendingAttributes");
+                else
+                {
+                    BMCWEB_LOG_ERROR("Attribute type not supported");
+                }
+            }
         },
-            "xyz.openbmc_project.ObjectMapper",
-            "/xyz/openbmc_project/object_mapper",
-            "xyz.openbmc_project.ObjectMapper", "GetObject",
-            "/xyz/openbmc_project/bios_config/manager",
-            std::array<const char*, 0>());
-    });
-
-    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Bios/Settings")
-        .privileges(redfish::privileges::patchBios)
-        .methods(boost::beast::http::verb::patch)(
-            [](const crow::Request& req,
-               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp) {
-        nlohmann::json inpJson;
+            biosService, biosConfigObj, "org.freedesktop.DBus.Properties",
+            "Get", biosConfigIface, "BaseBIOSTable");
+    },
+        "xyz.openbmc_project.ObjectMapper",
+        "/xyz/openbmc_project/object_mapper",
+        "xyz.openbmc_project.ObjectMapper", "GetObject", biosConfigObj,
+        std::array<const char*, 1>{biosConfigIface});
+}
+
+/**
+ *@brief Validates the requested BIOS Base Table JSON with the required
+ *attribute format.
+ *
+ * @param[in]      attrJson    BIOS Attribute JSON
+ * @param[in,out]   asyncResp   Async HTTP response.
+ *
+ * @return Returns as a bool flag, true if attribute json is in valid format,
+ * or else returns false.
+ */
+static bool isValidAttrJson(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                            const nlohmann::json& attrJson)
+{
+    std::vector<std::string> keys{
+        "AttributeName", "CurrentValue", "DefaultValue",
+        "DisplayName",   "Description",  "MenuPath",
+        "ReadOnly",      "Type",         "Values"};
+    std::vector<std::string> boundKeys{"LowerBound", "UpperBound",
+                                       "ScalarIncrement"};
+
+    for (const auto& key : keys)
+    {
+        if (!attrJson.contains(key))
+        {
+            if (key == "Values")
+            {
+                // If Type is Integer, then check for the bound values
+                if (attrJson[keys.at(7)] == "Integer")
+                {
+                    for (const auto& boundKey : boundKeys)
+                    {
+                        if (!attrJson.contains(boundKey))
+                        {
+                            messages::propertyMissing(asyncResp->res, boundKey);
+                            BMCWEB_LOG_ERROR(
+                                "Required propery missing in req!");
+                            return false;
+                        }
+                    }
+                }
+                else
+                {
+                    messages::propertyMissing(asyncResp->res, key);
+                    BMCWEB_LOG_ERROR("Required propery missing in req!");
+                    return false;
+                }
+            }
+        }
+    }
 
-        if (!redfish::json_util::readJsonPatch(req, asyncResp->res, "data",
-                                               inpJson))
+    if (attrJson[keys.at(0)] == "")
+    {
+        messages::propertyValueIncorrect(asyncResp->res, keys.at(0), "empty");
+        BMCWEB_LOG_ERROR("AttributeName is not valid in req!");
+        return false;
+    }
+    return true;
+}
+
+/**
+ *@brief Sets the BIOS Base Table DBUS property with requested BIOS default
+ *attributes.
+ *
+ * @param[in]      baseBiosTableJson BIOS Base Table default Attribute details
+ * @param[in,out]   asyncResp   Async HTTP response.
+ *
+ * @return Returns None.
+ */
+static void fillBiosTable(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                          const std::vector<nlohmann::json>& baseBiosTableJson)
+{
+    BaseBIOSTable baseBiosTable;
+    for (const nlohmann::json& attrJson : baseBiosTableJson)
+    {
+        // Check all the fields are present
+        if (!isValidAttrJson(asyncResp, attrJson))
         {
-            BMCWEB_LOG_ERROR("No 'data' in req!");
+            BMCWEB_LOG_ERROR("Req attributes are missing!");
             return;
         }
+        std::string attr;
+        std::string attrDispName;
+        std::string attrDescr;
+        std::string attrMenuPath;
+        std::string attrType;
+        bool attrReadOnly;
+        std::vector<std::tuple<std::string, std::variant<int64_t, std::string>,
+                               std::string>>
+            attrValues;
+
+        attr = attrJson["AttributeName"].get<std::string>();
+        attrDispName = attrJson["DisplayName"].get<std::string>();
+        attrDescr = attrJson["Description"].get<std::string>();
+        attrMenuPath = attrJson["MenuPath"].get<std::string>();
+        attrType = attrJson["Type"].get<std::string>();
+        attrReadOnly = attrJson["ReadOnly"].get<bool>();
 
-        if (inpJson.empty())
+        if ((attrType == "String") || (attrType == "Enumeration"))
         {
-            messages::invalidObject(asyncResp->res,
-                                    boost::urls::format("data"));
-            BMCWEB_LOG_ERROR("No input in req!");
+            std::string currVal = attrJson["CurrentValue"].get<std::string>();
+            std::string defaultVal =
+                attrJson["DefaultValue"].get<std::string>();
+
+            // read and update the bound values
+            for (const auto& value :
+                 attrJson["Values"].get<std::vector<std::string>>())
+            {
+                attrValues.emplace_back(std::make_tuple(
+                    "xyz.openbmc_project.BIOSConfig.Manager.BoundType.OneOf",
+                    value, ""));
+            }
+            attrType = getDbusBiosAttrType(attrType);
+            baseBiosTable.insert(std::make_pair(
+                attr, std::make_tuple(attrType, attrReadOnly, attrDispName,
+                                      attrDescr, attrMenuPath, currVal,
+                                      defaultVal, attrValues)));
+        }
+        else if (attrType == "Integer")
+        {
+            int64_t currVal = attrJson["CurrentValue"].get<int64_t>();
+            int64_t defaultVal = attrJson["DefaultValue"].get<int64_t>();
+
+            // read and update the bound values
+            attrValues.emplace_back(std::make_tuple(
+                "xyz.openbmc_project.BIOSConfig.Manager.BoundType.LowerBound",
+                attrJson["LowerBound"].get<int64_t>(), ""));
+            attrValues.emplace_back(std::make_tuple(
+                "xyz.openbmc_project.BIOSConfig.Manager.BoundType.UpperBound",
+                attrJson["UpperBound"].get<int64_t>(), ""));
+            attrValues.emplace_back(std::make_tuple(
+                "xyz.openbmc_project.BIOSConfig.Manager.BoundType.ScalarIncrement",
+                attrJson["ScalarIncrement"].get<int64_t>(), ""));
+
+            attrType = getDbusBiosAttrType(attrType);
+            baseBiosTable.insert(std::make_pair(
+                attr, std::make_tuple(attrType, attrReadOnly, attrDispName,
+                                      attrDescr, attrMenuPath, currVal,
+                                      defaultVal, attrValues)));
+        }
+        else if (attrType == "Boolean")
+        {
+            // for Boolean type, BaseBIOSTable DBus method will expect the data
+            // in the int64_t type
+            int64_t currVal =
+                static_cast<int64_t>(attrJson["CurrentValue"].get<bool>());
+            int64_t defaultVal =
+                static_cast<int64_t>(attrJson["DefaultValue"].get<bool>());
+            // read and update the bound values
+            for (const auto& value :
+                 attrJson["Values"].get<std::vector<bool>>())
+            {
+                attrValues.emplace_back(std::make_tuple(
+                    "xyz.openbmc_project.BIOSConfig.Manager.BoundType.OneOf",
+                    (value == true ? 1 : 0), ""));
+            }
+            attrType = getDbusBiosAttrType(attrType);
+            baseBiosTable.insert(std::make_pair(
+                attr, std::make_tuple(attrType, attrReadOnly, attrDispName,
+                                      attrDescr, attrMenuPath, currVal,
+                                      defaultVal, attrValues)));
+        }
+        else
+        {
+            messages::propertyValueIncorrect(asyncResp->res, "Type", "UNKNOWN");
+            BMCWEB_LOG_ERROR("Attribute Type is not valid in req!");
             return;
         }
+    }
 
+    if (baseBiosTable.empty())
+    {
+        BMCWEB_LOG_ERROR("Base Bios Table empty");
+        messages::invalidObject(asyncResp->res,
+                                boost::urls::format("Attributes"));
+    }
+
+    crow::connections::systemBus->async_method_call(
+        [asyncResp, baseBiosTable](const boost::system::error_code ec) {
+        if (ec)
+        {
+            BMCWEB_LOG_DEBUG("Error occurred in setting BaseBIOSTable");
+            messages::internalError(asyncResp->res);
+            return;
+        }
+
+        messages::success(asyncResp->res);
+    },
+        "xyz.openbmc_project.BIOSConfigManager",
+        "/xyz/openbmc_project/bios_config/manager",
+        "org.freedesktop.DBus.Properties", "Set",
+        "xyz.openbmc_project.BIOSConfig.Manager", "BaseBIOSTable",
+        std::variant<BaseBIOSTable>(baseBiosTable));
+}
+
+/**
+ *@brief Reads the BIOS Pending Attributes, which are updated by oob the user
+ * and update the Bios Settings Attributes response.
+ *
+ * @param[in,out]   asyncResp   Async HTTP response.
+ *
+ * @return None.
+ */
+static void
+    getBiosSettingsAttr(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
+{
+    crow::connections::systemBus->async_method_call(
+        [asyncResp](const boost::system::error_code ec,
+                    const GetObjectType& objType) {
+        if (ec || objType.empty())
+        {
+            BMCWEB_LOG_ERROR("GetObject for path biosConfigObj");
+            messages::internalError(asyncResp->res);
+            return;
+        }
+        const std::string& biosService = objType.begin()->first;
         crow::connections::systemBus->async_method_call(
-            [asyncResp,
-             inpJson](const boost::system::error_code ec,
-                      const dbus::utility::MapperGetObject& getObjectType) {
+            [asyncResp](const boost::system::error_code ec,
+                        const std::variant<PendingAttrType>& pendingAttrsResp) {
             if (ec)
             {
-                BMCWEB_LOG_ERROR("ObjectMapper::GetObject call failed: {}", ec);
+                BMCWEB_LOG_ERROR("Get PendingAttributes DBus response error");
                 messages::internalError(asyncResp->res);
+                return;
+            }
+
+            const PendingAttrType* pendingAttrs =
+                std::get_if<PendingAttrType>(&pendingAttrsResp);
 
+            nlohmann::json& attributesJson =
+                asyncResp->res.jsonValue["Attributes"];
+            if (pendingAttrs == nullptr)
+            {
+                BMCWEB_LOG_ERROR("Empty Pending Attributes");
+                messages::internalError(asyncResp->res);
                 return;
             }
 
-            if (getObjectType.empty())
+            for (const PendingAttrItemType& attrIt : *pendingAttrs)
             {
-                BMCWEB_LOG_ERROR("getObjectType is empty.");
+                const std::string& attr = attrIt.first;
+
+                // read the attribute type at 0th field and convert from
+                // dbus to string format
+                std::string attrType = getBiosAttrType(std::string(
+                    std::get<BiosPendingAttributesIndex::biosPendingAttrType>(
+                        attrIt.second)));
+                if ((attrType == "String") || (attrType == "Enumeration"))
+                {
+                    // read the current value of attribute at 1st field
+                    const std::string* attrCurrValue = std::get_if<std::string>(
+                        &std::get<
+                            BiosPendingAttributesIndex::biosPendingAttrValue>(
+                            attrIt.second));
+                    if (attrCurrValue != nullptr)
+                    {
+                        attributesJson.emplace(attr, *attrCurrValue);
+                    }
+                    else
+                    {
+                        attributesJson.emplace(attr, std::string(""));
+                    }
+                }
+                else if ((attrType == "Integer") || (attrType == "Boolean"))
+                {
+                    // read the current value of attribute at 1st field
+                    const int64_t* attrCurrValue = std::get_if<int64_t>(
+                        &std::get<
+                            BiosPendingAttributesIndex::biosPendingAttrValue>(
+                            attrIt.second));
+                    if (attrCurrValue != nullptr)
+                    {
+                        if (attrType == "Boolean")
+                        {
+                            if (*attrCurrValue)
+                            {
+                                attributesJson.emplace(attr, true);
+                            }
+                            else
+                            {
+                                attributesJson.emplace(attr, false);
+                            }
+                        }
+                        else
+                        {
+                            attributesJson.emplace(attr, *attrCurrValue);
+                        }
+                    }
+                    else
+                    {
+                        if (attrType == "Boolean")
+                        {
+                            attributesJson.emplace(attr, false);
+                        }
+                        else
+                        {
+                            attributesJson.emplace(attr, 0);
+                        }
+                    }
+                }
+                else
+                {
+                    BMCWEB_LOG_ERROR("Attribute type not supported");
+                }
+            }
+        },
+            biosService, biosConfigObj, "org.freedesktop.DBus.Properties",
+            "Get", biosConfigIface, "PendingAttributes");
+    },
+        "xyz.openbmc_project.ObjectMapper",
+        "/xyz/openbmc_project/object_mapper",
+        "xyz.openbmc_project.ObjectMapper", "GetObject", biosConfigObj,
+        std::array<const char*, 1>{biosConfigIface});
+}
+
+/**
+ *@brief Updates the BIOS Pending Attributes DBUS property, which are requested
+ *by the oob user.
+ *
+ * @param[in,out]   asyncResp   Async HTTP response.
+ *
+ * @return None.
+ */
+static void
+    setBiosPendingAttr(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                       const nlohmann::json& pendingAttrJson)
+{
+    crow::connections::systemBus->async_method_call(
+        [asyncResp, pendingAttrJson](const boost::system::error_code ec,
+                                     const GetObjectType& objType) {
+        if (ec || objType.empty())
+        {
+            BMCWEB_LOG_ERROR("GetObject for path biosConfigObj");
+            messages::internalError(asyncResp->res);
+            return;
+        }
+        const std::string& biosService = objType.begin()->first;
+        crow::connections::systemBus->async_method_call(
+            [asyncResp, pendingAttrJson, biosService](
+                const boost::system::error_code ec,
+                const std::variant<BaseBIOSTable>& baseBiosTableResp) {
+            if (ec)
+            {
+                BMCWEB_LOG_ERROR("Get BaseBIOSTable DBus response error");
                 messages::internalError(asyncResp->res);
+                return;
+            }
 
+            const BaseBIOSTable* baseBiosTable =
+                std::get_if<BaseBIOSTable>(&baseBiosTableResp);
+
+            if (baseBiosTable == nullptr)
+            {
+                BMCWEB_LOG_ERROR("Empty BaseBIOSTable");
+                messages::internalError(asyncResp->res);
                 return;
             }
 
-            std::string service = getObjectType.begin()->first;
+            PendingAttrType pendingAttrs{};
+            for (const auto& pendingAttrIt : pendingAttrJson.items())
+            {
+                // Check whether the requested attribute is available
+                // inside BaseBIOSTable or not
+                auto attrIt = baseBiosTable->find(pendingAttrIt.key());
+                if (attrIt == baseBiosTable->end())
+                {
+                    BMCWEB_LOG_ERROR("Not Found Attribute ");
+                    messages::propertyValueNotInList(
+                        asyncResp->res, pendingAttrIt.key(), "Attributes");
+                    return;
+                }
 
-            crow::connections::systemBus->async_method_call(
-                [asyncResp,
-                 inpJson](const boost::system::error_code ec2,
-                          const std::variant<BiosBaseTableType>& retBiosTable) {
-                if (ec2)
+                // read the attribute type at 0th field and convert from
+                // dbus to string format
+                std::string attrItType =
+                    std::get<BaseBiosTableIndex::baseBiosAttrType>(
+                        attrIt->second);
+                std::string attrType = getBiosAttrType(attrItType);
+                if ((attrType == "String") || (attrType == "Enumeration"))
+                {
+                    std::string attrReqVal = pendingAttrIt.value();
+                    // read the bound values for the attribute
+                    const std::vector<AttrBoundType> boundValues =
+                        std::get<BaseBiosTableIndex::baseBiosBoundValues>(
+                            attrIt->second);
+                    auto found = std::find_if(
+                        boundValues.begin(), boundValues.end(),
+                        [attrReqVal](const AttrBoundType& boundValueIt) {
+                        // read the bound value type at 0th field
+                        // and convert from dbus to string format
+                        std::string boundValType =
+                            getBiosBoundValType(std::string(
+                                std::get<BaseBiosBoundIndex::baseBiosBoundType>(
+                                    boundValueIt)));
+
+                        if (boundValType == "OneOf")
+                        {
+                            // read the bound value  at 1st field
+                            // for each entry
+                            const std::string* currBoundVal =
+                                std::get_if<std::string>(
+                                    &std::get<
+                                        BaseBiosBoundIndex::baseBiosBoundValue>(
+                                        boundValueIt));
+                            if (currBoundVal == nullptr)
+                            {
+                                BMCWEB_LOG_ERROR("Bound Value not found");
+                                return false;
+                            }
+
+                            return (attrReqVal == *currBoundVal) ? true : false;
+                        }
+                        else
+                        {
+                            return false;
+                        }
+                    });
+
+                    if (found == boundValues.end())
+                    {
+                        BMCWEB_LOG_ERROR("Requested Attribute Value invalid");
+                        messages::internalError(asyncResp->res);
+                        return;
+                    }
+                    pendingAttrs.insert(std::make_pair(
+                        pendingAttrIt.key(),
+                        std::make_tuple(attrItType, attrReqVal)));
+                }
+                else if (attrType == "Boolean")
+                {
+                    int64_t attrReqVal =
+                        static_cast<int64_t>(pendingAttrIt.value().get<bool>());
+                    // read the bound values for the attribute
+                    const std::vector<AttrBoundType> boundValues =
+                        std::get<BaseBiosTableIndex::baseBiosBoundValues>(
+                            attrIt->second);
+
+                    auto found = std::find_if(
+                        boundValues.begin(), boundValues.end(),
+                        [attrReqVal](const AttrBoundType& boundValueIt) {
+                        // read the bound value type at 0th field
+                        // and convert from dbus to string format
+                        std::string boundValType =
+                            getBiosBoundValType(std::string(
+                                std::get<BaseBiosBoundIndex::baseBiosBoundType>(
+                                    boundValueIt)));
+                        if (boundValType == "OneOf")
+                        {
+                            // read the bound value  at 1st field
+                            // for each entry
+                            const int64_t* currBoundVal = std::get_if<int64_t>(
+                                &std::get<
+                                    BaseBiosBoundIndex::baseBiosBoundValue>(
+                                    boundValueIt));
+                            if (currBoundVal == nullptr)
+                            {
+                                BMCWEB_LOG_ERROR("Bound Value not found");
+                                return false;
+                            }
+                            return (attrReqVal == *currBoundVal) ? true : false;
+                        }
+                        else
+                        {
+                            return false;
+                        }
+                    });
+
+                    if (found == boundValues.end())
+                    {
+                        BMCWEB_LOG_ERROR("Requested Attribute Value invalid");
+                        messages::internalError(asyncResp->res);
+                        return;
+                    }
+                    pendingAttrs.insert(std::make_pair(
+                        pendingAttrIt.key(),
+                        std::make_tuple(attrItType, attrReqVal)));
+                }
+                else if (attrType == "Integer")
                 {
-                    BMCWEB_LOG_ERROR("getBiosAttributes DBUS error: {}", ec2);
+                    int64_t attrReqVal = pendingAttrIt.value();
+                    pendingAttrs.emplace(
+                        pendingAttrIt.key(),
+                        std::make_tuple(attrItType, attrReqVal));
+                }
+                else
+                {
+                    BMCWEB_LOG_ERROR("Unknown Attribute Type");
                     messages::internalError(asyncResp->res);
                     return;
                 }
+            }
 
-                const BiosBaseTableType* baseBiosTable =
-                    std::get_if<BiosBaseTableType>(&retBiosTable);
+            if (pendingAttrs.empty())
+            {
+                BMCWEB_LOG_ERROR("PendingAttributes empty");
+                messages::invalidObject(asyncResp->res,
+                                        boost::urls::format("Attributes"));
+            }
 
-                if (baseBiosTable == nullptr)
+            crow::connections::systemBus->async_method_call(
+                [asyncResp](const boost::system::error_code ec) {
+                if (ec)
                 {
-                    BMCWEB_LOG_ERROR("baseBiosTable is empty.");
+                    BMCWEB_LOG_ERROR("Set PendingAttributes failed ");
                     messages::internalError(asyncResp->res);
                     return;
                 }
 
-                PendingAttributesType pendingAttributes{};
+                messages::success(asyncResp->res);
+            },
+                biosService, biosConfigObj, "org.freedesktop.DBus.Properties",
+                "Set", biosConfigIface, "PendingAttributes",
+                std::variant<PendingAttrType>(pendingAttrs));
+        },
+            biosService, biosConfigObj, "org.freedesktop.DBus.Properties",
+            "Get", biosConfigIface, "BaseBIOSTable");
+    },
+        "xyz.openbmc_project.ObjectMapper",
+        "/xyz/openbmc_project/object_mapper",
+        "xyz.openbmc_project.ObjectMapper", "GetObject", biosConfigObj,
+        std::array<const char*, 1>{biosConfigIface});
+}
 
-                for (const nlohmann::detail::iteration_proxy_value<
-                         nlohmann::detail::iter_impl<
-                             const nlohmann::basic_json<>>>& attributes :
-                     inpJson.items())
+/**
+ *@brief Reads the BIOS Base Table DBUS property and update the Bios Attribute
+ *Registry response.
+ *
+ * @param[in,out]   asyncResp   Async HTTP response.
+ *
+ * @return None.
+ */
+static void getBiosAttributeRegistry(
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
+{
+    crow::connections::systemBus->async_method_call(
+        [asyncResp](const boost::system::error_code ec,
+                    const GetObjectType& objType) {
+        if (ec || objType.empty())
+        {
+            BMCWEB_LOG_ERROR("GetObject for path biosConfigObj");
+            return;
+        }
+
+        const std::string& biosService = objType.begin()->first;
+        crow::connections::systemBus->async_method_call(
+            [asyncResp](const boost::system::error_code ec,
+                        const std::variant<BaseBIOSTable>& baseBiosTableResp) {
+            if (ec)
+            {
+                BMCWEB_LOG_ERROR("Get BaseBIOSTable DBus response error");
+                messages::internalError(asyncResp->res);
+                return;
+            }
+
+            const BaseBIOSTable* baseBiosTable =
+                std::get_if<BaseBIOSTable>(&baseBiosTableResp);
+
+            nlohmann::json& attributeArray =
+                asyncResp->res.jsonValue["RegistryEntries"]["Attributes"];
+
+            if (baseBiosTable == nullptr)
+            {
+                BMCWEB_LOG_ERROR("Empty BaseBIOSTable");
+                messages::internalError(asyncResp->res);
+                return;
+            }
+            for (const BaseBIOSTableItem& attrIt : *baseBiosTable)
+            {
+                // read the attribute type at 0th field and convert from
+                // dbus to string format
+                std::string attrType = getBiosAttrType(
+                    std::string(std::get<BaseBiosTableIndex::baseBiosAttrType>(
+                        attrIt.second)));
+
+                if (attrType == "UNKNOWN")
                 {
-                    BiosBaseTableType::const_iterator knobIter =
-                        baseBiosTable->find(attributes.key());
-                    if (knobIter == baseBiosTable->end())
+                    BMCWEB_LOG_ERROR("Attribute type not supported");
+                    continue;
+                }
+                nlohmann::json attributeIt;
+                attributeIt["AttributeName"] = attrIt.first;
+                attributeIt["Type"] = attrType;
+                attributeIt["ReadOnly"] =
+                    std::get<BaseBiosTableIndex::baseBiosReadonlyStatus>(
+                        attrIt.second);
+                attributeIt["DisplayName"] =
+                    std::get<BaseBiosTableIndex::baseBiosDisplayName>(
+                        attrIt.second);
+                const std::string& helpText =
+                    std::get<BaseBiosTableIndex::baseBiosDescription>(
+                        attrIt.second);
+                if (!helpText.empty())
+                {
+                    attributeIt["HelpText"] = helpText;
+                }
+                attributeIt["MenuPath"] =
+                    std::get<BaseBiosTableIndex::baseBiosMenuPath>(
+                        attrIt.second);
+
+                if ((attrType == "String") || (attrType == "Enumeration"))
+                {
+                    // read the current value of attribute at 5th field
+                    const std::string* attrCurrValue = std::get_if<std::string>(
+                        &std::get<BaseBiosTableIndex::baseBiosCurrValue>(
+                            attrIt.second));
+                    if (attrCurrValue != nullptr)
                     {
-                        BMCWEB_LOG_ERROR("Cannot find {} in baseBiosTable",
-                                         attributes.key());
-                        messages::propertyValueNotInList(
-                            asyncResp->res, attributes.key(), "data");
-                        return;
+                        attributeIt["CurrentValue"] = *attrCurrValue;
+                    }
+                    else
+                    {
+                        attributeIt["CurrentValue"] = "";
+                    }
+
+                    // read the default value of attribute at 6th field
+                    const std::string* attrDefaultValue =
+                        std::get_if<std::string>(
+                            &std::get<BaseBiosTableIndex::baseBiosDefaultValue>(
+                                attrIt.second));
+                    if (attrDefaultValue != nullptr)
+                    {
+                        attributeIt["DefaultValue"] = *attrDefaultValue;
+                    }
+                    else
+                    {
+                        attributeIt["DefaultValue"] = "";
+                    }
+                }
+                else if ((attrType == "Integer") || (attrType == "Boolean"))
+                {
+                    // read the current value of attribute at 5th field
+                    const int64_t* attrCurrValue = std::get_if<int64_t>(
+                        &std::get<BaseBiosTableIndex::baseBiosCurrValue>(
+                            attrIt.second));
+                    if (attrCurrValue != nullptr)
+                    {
+                        if (attrType == "Boolean")
+                        {
+                            if (*attrCurrValue)
+                            {
+                                attributeIt["CurrentValue"] = true;
+                            }
+                            else
+                            {
+                                attributeIt["CurrentValue"] = false;
+                            }
+                        }
+                        else
+                        {
+                            attributeIt["CurrentValue"] = *attrCurrValue;
+                        }
+                    }
+                    else
+                    {
+                        if (attrType == "Boolean")
+                        {
+                            attributeIt["CurrentValue"] = false;
+                        }
+                        else
+                        {
+                            attributeIt["CurrentValue"] = 0;
+                        }
                     }
 
-                    const std::string& itemType =
-                        std::get<biosBaseAttrType>(knobIter->second);
-                    std::string attrType = mapAttrTypeToRedfish(itemType);
+                    // read the current value of attribute at 6th field
+                    const int64_t* attrDefaultValue = std::get_if<int64_t>(
+                        &std::get<BaseBiosTableIndex::baseBiosDefaultValue>(
+                            attrIt.second));
+                    if (attrDefaultValue != nullptr)
+                    {
+                        if (attrType == "Boolean")
+                        {
+                            if (*attrDefaultValue)
+                            {
+                                attributeIt["DefaultValue"] = true;
+                            }
+                            else
+                            {
+                                attributeIt["DefaultValue"] = false;
+                            }
+                        }
+                        else
+                        {
+                            attributeIt["DefaultValue"] = *attrDefaultValue;
+                        }
+                    }
+                    else
+                    {
+                        if (attrType == "Boolean")
+                        {
+                            attributeIt["DefaultValue"] = false;
+                        }
+                        else
+                        {
+                            attributeIt["DefaultValue"] = 0;
+                        }
+                    }
+                }
+
+                nlohmann::json boundValArray = nlohmann::json::array();
 
-                    if (attrType == "String" || attrType == "Enumeration")
+                // read the bound values for the attribute
+                const std::vector<AttrBoundType> boundValues =
+                    std::get<BaseBiosTableIndex::baseBiosBoundValues>(
+                        attrIt.second);
+
+                for (const AttrBoundType& boundValueIt : boundValues)
+                {
+                    nlohmann::json boundValJson;
+
+                    // read the bound value type at 0th field
+                    // and convert from dbus to string format
+                    std::string boundValType = getBiosBoundValType(std::string(
+                        std::get<BaseBiosBoundIndex::baseBiosBoundType>(
+                            boundValueIt)));
+
+                    if (boundValType == "UNKNOWN")
                     {
-                        std::string val = attributes.value();
+                        BMCWEB_LOG_ERROR("Attribute type not supported");
+                        continue;
+                    }
 
-                        pendingAttributes.emplace(
-                            attributes.key(), std::make_tuple(itemType, val));
+                    if (boundValType == "OneOf")
+                    {
+                        if ((attrType == "String") ||
+                            (attrType == "Enumeration"))
+                        {
+                            // read the bound value  at 1st field
+                            // for each entry
+                            const std::string* currBoundVal =
+                                std::get_if<std::string>(
+                                    &std::get<
+                                        BaseBiosBoundIndex::baseBiosBoundValue>(
+                                        boundValueIt));
+                            if (currBoundVal != nullptr)
+                            {
+                                boundValJson["ValueName"] = *currBoundVal;
+                            }
+                            else
+                            {
+                                boundValJson["ValueName"] = "";
+                            }
+                        }
+                        else if (attrType == "Boolean")
+                        {
+                            // read the bound value  at 1st field
+                            // for each entry
+                            const int64_t* currBoundVal = std::get_if<int64_t>(
+                                &std::get<
+                                    BaseBiosBoundIndex::baseBiosBoundValue>(
+                                    boundValueIt));
+                            if (currBoundVal != nullptr)
+                            {
+                                if (*currBoundVal)
+                                {
+                                    boundValJson["ValueName"] = true;
+                                }
+                                else
+                                {
+                                    boundValJson["ValueName"] = false;
+                                }
+                            }
+                            else
+                            {
+                                boundValJson["ValueName"] = false;
+                            }
+                        }
+                        else
+                        {
+                            continue;
+                        }
+                    }
+                    else if (boundValType == "LowerBound")
+                    {
+                        const int64_t* currBoundVal = std::get_if<int64_t>(
+                            &std::get<BaseBiosBoundIndex::baseBiosBoundValue>(
+                                boundValueIt));
+                        if (currBoundVal != nullptr)
+                        {
+                            attributeIt["LowerBound"] = *currBoundVal;
+                        }
+                        else
+                        {
+                            attributeIt["LowerBound"] = 0;
+                        }
+                    }
+                    else if (boundValType == "UpperBound")
+                    {
+                        const int64_t* currBoundVal = std::get_if<int64_t>(
+                            &std::get<BaseBiosBoundIndex::baseBiosBoundValue>(
+                                boundValueIt));
+                        if (currBoundVal != nullptr)
+                        {
+                            attributeIt["UpperBound"] = *currBoundVal;
+                        }
+                        else
+                        {
+                            attributeIt["UpperBound"] = 0;
+                        }
                     }
-                    else if (attrType == "Integer")
+                    else if (boundValType == "ScalarIncrement")
                     {
-                        pendingAttributes.emplace(
-                            attributes.key(),
-                            std::make_tuple(itemType, static_cast<int64_t>(
-                                                          attributes.value())));
+                        const int64_t* currBoundVal = std::get_if<int64_t>(
+                            &std::get<BaseBiosBoundIndex::baseBiosBoundValue>(
+                                boundValueIt));
+                        if (currBoundVal != nullptr)
+                        {
+                            attributeIt["ScalarIncrement"] = *currBoundVal;
+                        }
+                        else
+                        {
+                            attributeIt["ScalarIncrement"] = 0;
+                        }
                     }
                     else
                     {
-                        BMCWEB_LOG_ERROR("UNKNOWN attrType == {}", itemType);
-                        messages::internalError(asyncResp->res);
-
-                        return;
+                        // read the bound value  at 1st field
+                        // for each entry
+                        const int64_t* currBoundVal = std::get_if<int64_t>(
+                            &std::get<BaseBiosBoundIndex::baseBiosBoundValue>(
+                                boundValueIt));
+                        if (currBoundVal != nullptr)
+                        {
+                            boundValJson["ValueName"] = *currBoundVal;
+                        }
+                        else
+                        {
+                            boundValJson["ValueName"] = 0;
+                        }
                     }
+                    boundValArray.push_back(boundValJson);
                 }
 
-                if (pendingAttributes.empty())
+                if (boundValArray.empty())
                 {
-                    BMCWEB_LOG_ERROR("pendingAttributes is empty.");
-                    messages::invalidObject(asyncResp->res,
-                                            boost::urls::format("data"));
+                    BMCWEB_LOG_ERROR("Bound Values Array is empty");
+                    continue;
                 }
-
-                crow::connections::systemBus->async_method_call(
-                    [asyncResp](const boost::system::error_code ec3) {
-                    if (ec3 == boost::system::errc::io_error)
-                    {
-                        BMCWEB_LOG_ERROR(
-                            "Invalid input data passed while patching Bios/Setting");
-                        messages::invalidObject(asyncResp->res,
-                                                boost::urls::format("data"));
-                        return;
-                    }
-                    if (ec3)
-                    {
-                        BMCWEB_LOG_ERROR("doPatch resp_handler got error {}",
-                                         ec3);
-                        messages::internalError(asyncResp->res);
-                        return;
-                    }
-
-                    messages::success(asyncResp->res);
-                },
-                    "xyz.openbmc_project.BIOSConfigManager",
-                    "/xyz/openbmc_project/bios_config/manager",
-                    "org.freedesktop.DBus.Properties", "Set",
-                    "xyz.openbmc_project.BIOSConfig.Manager",
-                    "PendingAttributes",
-                    std::variant<PendingAttributesType>(pendingAttributes));
-            },
-                service, "/xyz/openbmc_project/bios_config/manager",
-                "org.freedesktop.DBus.Properties", "Get",
-                "xyz.openbmc_project.BIOSConfig.Manager", "BaseBIOSTable");
+                if (attrType != "Integer")
+                {
+                    attributeIt["Value"] = boundValArray;
+                }
+                attributeArray.push_back(attributeIt);
+            }
         },
-            "xyz.openbmc_project.ObjectMapper",
-            "/xyz/openbmc_project/object_mapper",
-            "xyz.openbmc_project.ObjectMapper", "GetObject",
-            "/xyz/openbmc_project/bios_config/manager",
-            std::array<const char*, 0>());
-    });
+            biosService, biosConfigObj, "org.freedesktop.DBus.Properties",
+            "Get", biosConfigIface, "BaseBIOSTable");
+    },
+        "xyz.openbmc_project.ObjectMapper",
+        "/xyz/openbmc_project/object_mapper",
+        "xyz.openbmc_project.ObjectMapper", "GetObject", biosConfigObj,
+        std::array<const char*, 1>{biosConfigIface});
 }
+} // namespace bios
+
 /**
- * BiosAttributeRegistry class supports handle get method for BIOS attribute
- * registry.
+ * BiosService class supports handle put method for bios.
  */
-inline void requestRoutesBiosAttributeRegistry(App& app)
+inline void
+    handleBiosServicePut(const crow::Request& req,
+                         const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
 {
-    BMCWEB_ROUTE(
-        app,
-        "/redfish/v1/Registries/BiosAttributeRegistry/BiosAttributeRegistry/")
-        .privileges(redfish::privileges::getBios)
-        .methods(boost::beast::http::verb::get)(
-            [](const crow::Request&,
-               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp) {
-        asyncResp->res.jsonValue["@odata.id"] =
-            "/redfish/v1/Registries/BiosAttributeRegistry/"
-            "BiosAttributeRegistry";
-        asyncResp->res.jsonValue["@odata.type"] =
-            "#AttributeRegistry.v1_3_2.AttributeRegistry";
-        asyncResp->res.jsonValue["Name"] = "Bios Attribute Registry";
-        asyncResp->res.jsonValue["Id"] = "BiosAttributeRegistry";
-        asyncResp->res.jsonValue["RegistryVersion"] = "1.0.0";
-        asyncResp->res.jsonValue["Language"] = "en";
-        asyncResp->res.jsonValue["OwningEntity"] = "OpenBMC";
-        asyncResp->res.jsonValue["RegistryEntries"]["Attributes"] =
-            nlohmann::json::array();
-
-        crow::connections::systemBus->async_method_call(
-            [asyncResp](const boost::system::error_code ec,
-                        const dbus::utility::MapperGetObject& getObjectType) {
-            if (ec)
-            {
-                BMCWEB_LOG_ERROR("ObjectMapper::GetObject call failed: {}", ec);
-                messages::internalError(asyncResp->res);
-
-                return;
-            }
-
-            if (getObjectType.empty())
-            {
-                BMCWEB_LOG_ERROR("getObjectType is empty.");
-                messages::internalError(asyncResp->res);
+    crow::connections::systemBus->async_method_call(
+        [req,
+         asyncResp](const boost::system::error_code ec,
+                    const std::map<std::string, dbus::utility::DbusVariantType>&
+                        userInfo) {
+        if (ec)
+        {
+            BMCWEB_LOG_ERROR("GetUserInfo failed");
+            messages::internalError(asyncResp->res);
+            return;
+        }
 
-                return;
-            }
+        const std::vector<std::string>* userGroupPtr = nullptr;
+        auto userInfoIter = userInfo.find("UserGroups");
+        if (userInfoIter != userInfo.end())
+        {
+            userGroupPtr =
+                std::get_if<std::vector<std::string>>(&userInfoIter->second);
+        }
 
-            std::string service = getObjectType.begin()->first;
+        if (userGroupPtr == nullptr)
+        {
+            BMCWEB_LOG_ERROR("User Group not found");
+            messages::internalError(asyncResp->res);
+            return;
+        }
 
-            crow::connections::systemBus->async_method_call(
-                [asyncResp](
-                    const boost::system::error_code ec2,
-                    const std::variant<BiosBaseTableType>& retBiosTable) {
-                if (ec2)
-                {
-                    BMCWEB_LOG_ERROR("getBiosAttributeRegistry DBUS error: {}",
-                                     ec2);
-                    messages::resourceNotFound(asyncResp->res,
-                                               "Registries/Bios", "Bios");
-                    return;
-                }
-                const BiosBaseTableType* baseBiosTable =
-                    std::get_if<BiosBaseTableType>(&retBiosTable);
-                nlohmann::json& attributeArray =
-                    asyncResp->res.jsonValue["RegistryEntries"]["Attributes"];
-                if (baseBiosTable == nullptr)
-                {
-                    BMCWEB_LOG_ERROR("baseBiosTable == nullptr");
-                    messages::internalError(asyncResp->res);
-                    return;
-                }
-                for (const BiosBaseTableItemType& item : *baseBiosTable)
-                {
-                    const std::string& itemType =
-                        std::get<biosBaseAttrType>(item.second);
-                    std::string attrType = mapAttrTypeToRedfish(itemType);
-                    if (attrType == "UNKNOWN")
-                    {
-                        BMCWEB_LOG_ERROR("UNKNOWN attrType == {}", itemType);
-                        continue;
-                    }
-                    nlohmann::json attributeItem;
-                    attributeItem["AttributeName"] = item.first;
-                    attributeItem["Type"] = attrType;
-                    attributeItem["ReadOnly"] =
-                        std::get<biosBaseReadonlyStatus>(item.second);
-                    attributeItem["DisplayName"] =
-                        std::get<biosBaseDisplayName>(item.second);
-                    attributeItem["HelpText"] =
-                        std::get<biosBaseDescription>(item.second);
-                    attributeItem["MenuPath"] =
-                        std::get<biosBaseMenuPath>(item.second);
-
-                    if (attrType == "String" || attrType == "Enumeration")
-                    {
-                        const std::string* currValue = std::get_if<std::string>(
-                            &std::get<biosBaseCurrValue>(item.second));
+        auto found = std::find_if(userGroupPtr->begin(), userGroupPtr->end(),
+                                  [](const auto& group) {
+            return (group == "redfish-hostiface") ? true : false;
+        });
 
-                        if (!currValue)
-                        {
-                            BMCWEB_LOG_ERROR(
-                                "Unable to get currValue, no std::string data in BIOS attributes item data");
-                            continue;
-                        }
+        // Only Host Iface (redfish-hostiface) group user should
+        // perform PUT operations
+        if (found == userGroupPtr->end())
+        {
+            BMCWEB_LOG_ERROR("Not Sufficient Privilege");
+            messages::insufficientPrivilege(asyncResp->res);
+            return;
+        }
+        std::vector<nlohmann::json> baseBiosTableJson;
+        if (!redfish::json_util::readJsonAction(
+                req, asyncResp->res, "Attributes", baseBiosTableJson))
+        {
+            BMCWEB_LOG_ERROR("No 'Attributes' found");
+            messages::unrecognizedRequestBody(asyncResp->res);
+            return;
+        }
 
-                        const std::string* defValue = std::get_if<std::string>(
-                            &std::get<biosBaseDefaultValue>(item.second));
+        if (baseBiosTableJson.empty())
+        {
+            messages::invalidObject(asyncResp->res,
+                                    boost::urls::format("Attributes"));
+            BMCWEB_LOG_ERROR("No input in req!");
+            return;
+        }
 
-                        if (!defValue)
-                        {
-                            BMCWEB_LOG_ERROR(
-                                "Unable to get defValue, no std::string data in BIOS attributes item data");
-                            continue;
-                        }
+        // Set the BaseBIOSTable
+        bios::fillBiosTable(asyncResp, baseBiosTableJson);
+    },
+        "xyz.openbmc_project.User.Manager", "/xyz/openbmc_project/user",
+        "xyz.openbmc_project.User.Manager", "GetUserInfo",
+        req.session->username);
+}
 
-                        attributeItem["CurrentValue"] =
-                            currValue != nullptr ? *currValue : "";
-                        attributeItem["DefaultValue"] =
-                            defValue != nullptr ? *defValue : "";
-                    }
-                    else if (attrType == "Integer")
-                    {
-                        const int64_t* currValue = std::get_if<int64_t>(
-                            &std::get<biosBaseCurrValue>(item.second));
+/**
+ * BiosService class supports handle patch method for bios.
+ */
+inline void
+    handleBiosServicePatch(const crow::Request& req,
+                           const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
+{
+    std::optional<bool> resetBiosToDefaultsPending;
+    if (!json_util::readJsonPatch(req, asyncResp->res,
+                                  "ResetBiosToDefaultsPending",
+                                  resetBiosToDefaultsPending))
+    {
+        BMCWEB_LOG_ERROR("No 'ResetBiosToDefaultsPending' found");
+        messages::unrecognizedRequestBody(asyncResp->res);
+        return;
+    }
 
-                        if (!currValue)
-                        {
-                            BMCWEB_LOG_ERROR(
-                                "Unable to get currValue, no int64_t data in BIOS attributes item data");
-                            continue;
-                        }
+    if (resetBiosToDefaultsPending)
+    {
+        // set the ResetBiosToDefaultsPending
+        bios::setResetBiosSettings(asyncResp, *resetBiosToDefaultsPending);
+    }
+}
 
-                        const int64_t* defValue = std::get_if<int64_t>(
-                            &std::get<biosBaseDefaultValue>(item.second));
+/**
+ * BiosService class supports handle get method for bios.
+ */
+inline void
+    handleBiosServiceGet(const crow::Request&,
+                         const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
+{
+    asyncResp->res.jsonValue["@odata.id"] = "/redfish/v1/Systems/system/Bios";
+    asyncResp->res.jsonValue["@odata.type"] = "#Bios.v1_2_0.Bios";
+    asyncResp->res.jsonValue["Name"] = "BIOS Configuration";
+    asyncResp->res.jsonValue["Description"] = "BIOS Configuration Service";
+    asyncResp->res.jsonValue["Id"] = "BIOS";
+    asyncResp->res.jsonValue["Actions"]["#Bios.ResetBios"] = {
+        {"target", "/redfish/v1/Systems/system/Bios/Actions/Bios.ResetBios"}};
 
-                        if (!defValue)
-                        {
-                            BMCWEB_LOG_ERROR(
-                                "Unable to get defValue, no int64_t data in BIOS attributes item data");
-                            continue;
-                        }
+    asyncResp->res.jsonValue["Actions"]["#Bios.ChangePassword"] = {
+        {"target", "/redfish/v1/Systems/system/Bios/Actions/"
+                   "Bios.ChangePassword"}};
 
-                        attributeItem["CurrentValue"] =
-                            currValue != nullptr ? *currValue : 0;
-                        attributeItem["DefaultValue"] =
-                            defValue != nullptr ? *defValue : 0;
-                    }
-                    else
-                    {
-                        BMCWEB_LOG_ERROR("UNKNOWN attrType == {}", itemType);
-                        continue;
-                    }
+    asyncResp->res.jsonValue["@Redfish.Settings"]["@odata.type"] =
+        "#Settings.v1_2_2.Settings";
+    asyncResp->res.jsonValue["@Redfish.Settings"]["SettingsObject"] = {
+        {"@odata.id", "/redfish/v1/Systems/system/Bios/Settings"}};
+    // Get the ActiveSoftwareImage and SoftwareImages
+    sw_util::populateSoftwareInformation(asyncResp, sw_util::biosPurpose, "",
+                                         true);
+    asyncResp->res.jsonValue["Attributes"] = nlohmann::json({});
+    // Get the BIOS Attributes
+    bios::getBiosAttributes(asyncResp);
+    // Get the ResetBiosToDefaultsPending
+    bios::getResetBiosSettings(asyncResp);
+}
 
-                    nlohmann::json optionsArray = nlohmann::json::array();
-                    const std::vector<OptionsItemType>& optionsVector =
-                        std::get<biosBaseOptions>(item.second);
-                    for (const OptionsItemType& optItem : optionsVector)
-                    {
-                        nlohmann::json optItemJson;
-                        const std::string& strOptItemType =
-                            std::get<optItemType>(optItem);
-                        std::string optItemTypeRedfish =
-                            mapBoundTypeToRedfish(strOptItemType);
-                        if (optItemTypeRedfish == "UNKNOWN")
-                        {
-                            BMCWEB_LOG_ERROR("UNKNOWN optItemTypeRedfish == {}",
-                                             strOptItemType);
-                            continue;
-                        }
-                        if (optItemTypeRedfish == "OneOf")
-                        {
-                            const std::string* currValue =
-                                std::get_if<std::string>(
-                                    &std::get<optItemValue>(optItem));
+inline void requestRoutesBiosService(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Bios/")
+        .privileges(redfish::privileges::getBios)
+        .methods(boost::beast::http::verb::get)(handleBiosServiceGet);
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Bios/")
+        .privileges(redfish::privileges::patchBios)
+        .methods(boost::beast::http::verb::patch)(handleBiosServicePatch);
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Bios/")
+        .privileges(redfish::privileges::putBios)
+        .methods(boost::beast::http::verb::put)(handleBiosServicePut);
+}
 
-                            if (!currValue)
-                            {
-                                BMCWEB_LOG_ERROR(
-                                    "Unable to get currValue, no std::string data in option item value");
-                                continue;
-                            }
+/**
+ * BiosSetting class supports handle patch method for Bios Settings.
+ */
+inline void
+    handleBiosSettingsPatch(const crow::Request& req,
+                            const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
+{
+    nlohmann::json pendingAttrJson;
+    if (!redfish::json_util::readJsonPatch(req, asyncResp->res, "Attributes",
+                                           pendingAttrJson))
+    {
+        BMCWEB_LOG_ERROR("No 'Attributes' found");
+        messages::unrecognizedRequestBody(asyncResp->res);
+        return;
+    }
 
-                            optItemJson["ValueDisplayName"] =
-                                std::get<optItemText>(optItem);
-                            optItemJson["ValueName"] =
-                                currValue != nullptr ? *currValue : "";
-                        }
-                        else
-                        {
-                            const int64_t* currValue = std::get_if<int64_t>(
-                                &std::get<optItemValue>(optItem));
+    if (pendingAttrJson.empty())
+    {
+        messages::invalidObject(asyncResp->res,
+                                boost::urls::format("Attributes"));
+        BMCWEB_LOG_ERROR("No input in req!");
+        return;
+    }
 
-                            if (!currValue)
-                            {
-                                BMCWEB_LOG_ERROR(
-                                    "Unable to get currValue, no int64_t data in option item value");
-                                continue;
-                            }
+    // Update the Pending Atttributes
+    bios::setBiosPendingAttr(asyncResp, pendingAttrJson);
+}
 
-                            optItemJson["ValueDisplayName"] =
-                                currValue != nullptr ? *currValue : 0;
-                            optItemJson["ValueName"] =
-                                currValue != nullptr ? *currValue : 0;
-                        }
+/**
+ * BiosSetting class supports handle get method for Bios Settings.
+ */
+inline void
+    handleBiosSettingsGet(const crow::Request&,
+                          const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
+{
+    asyncResp->res.jsonValue["@odata.id"] =
+        "/redfish/v1/Systems/system/Bios/Settings";
+    asyncResp->res.jsonValue["@odata.type"] = "#Bios.v1_1_0.Bios";
+    asyncResp->res.jsonValue["Name"] = "BIOS Configuration";
+    asyncResp->res.jsonValue["Description"] = "BIOS Settings";
+    asyncResp->res.jsonValue["Id"] = "BIOS_Settings";
+    asyncResp->res.jsonValue["Attributes"] = nlohmann::json({});
+    // get the BIOS Attributes
+    bios::getBiosSettingsAttr(asyncResp);
+}
 
-                        optionsArray.push_back(optItemJson);
+inline void requestRoutesBiosSettings(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Bios/Settings")
+        .privileges(redfish::privileges::getBios)
+        .methods(boost::beast::http::verb::get)(handleBiosSettingsGet);
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Bios/Settings")
+        .privileges(redfish::privileges::patchBios)
+        .methods(boost::beast::http::verb::patch)(handleBiosSettingsPatch);
+}
+/**
+ * BiosChangePassword class supports handle POST method for change bios
+ * password. The class retrieves and sends data directly to D-Bus.
+ */
+inline void requestRoutesBiosChangePassword(App& app)
+{
+    BMCWEB_ROUTE(app,
+                 "/redfish/v1/Systems/system/Bios/Actions/Bios.ChangePassword/")
+        .privileges(redfish::privileges::postBios)
+        .methods(boost::beast::http::verb::post)(
+            [](const crow::Request& req,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp) {
+        std::string currentPassword, newPassword, userName;
+        if (!json_util::readJsonPatch(
+                req, asyncResp->res, "NewPassword", newPassword, "OldPassword",
+                currentPassword, "PasswordName", userName))
+        {
+            return;
+        }
+        if (currentPassword.empty())
+        {
+            messages::actionParameterUnknown(asyncResp->res, "ChangePassword",
+                                             "OldPassword");
+            return;
+        }
+        if (newPassword.empty())
+        {
+            messages::actionParameterUnknown(asyncResp->res, "ChangePassword",
+                                             "NewPassword");
+            return;
+        }
+        if (userName.empty())
+        {
+            messages::actionParameterUnknown(asyncResp->res, "ChangePassword",
+                                             "PasswordName");
+            return;
+        }
 
-                        if (optionsArray.empty())
-                        {
-                            BMCWEB_LOG_ERROR("optionsArray is empty");
-                            continue;
-                        }
-                    }
+        // In Intel BIOS, we are not supporting user password in BIOS setup
+        if (userName == "UserPassword")
+        {
+            messages::actionParameterUnknown(asyncResp->res, "ChangePassword",
+                                             "PasswordName");
+            return;
+        }
 
-                    attributeItem["Value"] = optionsArray;
-                    attributeArray.push_back(attributeItem);
-                }
-            },
-                service, "/xyz/openbmc_project/bios_config/manager",
-                "org.freedesktop.DBus.Properties", "Get",
-                "xyz.openbmc_project.BIOSConfig.Manager", "BaseBIOSTable");
+        crow::connections::systemBus->async_method_call(
+            [asyncResp](const boost::system::error_code ec) {
+            if (ec)
+            {
+                BMCWEB_LOG_CRITICAL("Failed in doPost(BiosChangePassword) {}",
+                                    ec);
+                messages::internalError(asyncResp->res);
+                return;
+            }
         },
-            "xyz.openbmc_project.ObjectMapper",
-            "/xyz/openbmc_project/object_mapper",
-            "xyz.openbmc_project.ObjectMapper", "GetObject",
-            "/xyz/openbmc_project/bios_config/manager",
-            std::array<const char*, 0>());
+            "xyz.openbmc_project.BIOSConfigPassword",
+            "/xyz/openbmc_project/bios_config/password",
+            "xyz.openbmc_project.BIOSConfig.Password", "ChangePassword",
+            userName, currentPassword, newPassword);
     });
 }
 
@@ -895,4 +1653,36 @@ inline void requestRoutesBiosReset(App& app)
             std::bind_front(handleBiosResetPost, std::ref(app)));
 }
 
+/**
+ * BiosAttributeRegistry class supports handle get method for Bios Attribute
+ * Registry.
+ */
+inline void handleBiosAttrRegistryGet(
+    const crow::Request&, const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
+{
+    asyncResp->res.jsonValue["@odata.id"] =
+        "/redfish/v1/Registries/BiosAttributeRegistry/"
+        "BiosAttributeRegistry";
+    asyncResp->res.jsonValue["@odata.type"] =
+        "#AttributeRegistry.v1_3_2.AttributeRegistry";
+    asyncResp->res.jsonValue["Name"] = "Bios Attribute Registry";
+    asyncResp->res.jsonValue["Id"] = "BiosAttributeRegistry";
+    asyncResp->res.jsonValue["RegistryVersion"] = "1.0.0";
+    asyncResp->res.jsonValue["Language"] = "en";
+    asyncResp->res.jsonValue["OwningEntity"] = "OpenBMC";
+    asyncResp->res.jsonValue["RegistryEntries"]["Attributes"] =
+        nlohmann::json::array();
+
+    // Get the BIOS Attributes Registry
+    bios::getBiosAttributeRegistry(asyncResp);
+}
+
+inline void requestRoutesBiosAttrRegistryService(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Registries/"
+                      "BiosAttributeRegistry/BiosAttributeRegistry/")
+        .privileges(redfish::privileges::getBios)
+        .methods(boost::beast::http::verb::get)(handleBiosAttrRegistryGet);
+}
+
 } // namespace redfish
-- 
2.25.1

