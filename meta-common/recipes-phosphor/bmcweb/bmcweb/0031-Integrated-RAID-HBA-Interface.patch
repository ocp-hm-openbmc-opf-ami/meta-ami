From fbdd3bfaf0251d586c1c5f389d4a7406faa612ed Mon Sep 17 00:00:00 2001
From: Pranoy Goru <gorumanip@ami.com>
Date: Tue, 31 Oct 2023 00:31:41 +0530
Subject: [PATCH 101/101] Integrated RAID interface in redfish

Description
Added RAID and HBA interface in redfish

# busctl tree xyz.openbmc_project.hba.manager
`-/xyz
  `-/xyz/openbmc_project
    `-/xyz/openbmc_project/HBA
      `-/xyz/openbmc_project/HBA/0
        `-/xyz/openbmc_project/HBA/0/pd
          |-/xyz/openbmc_project/HBA/0/pd/0
          `-/xyz/openbmc_project/HBA/0/pd/1

# busctl tree xyz.openbmc_project.raid.manager
`-/xyz
  `-/xyz/openbmc_project
    `-/xyz/openbmc_project/Raid
      |-/xyz/openbmc_project/Raid/0
      | |-/xyz/openbmc_project/Raid/0/ld
      | `-/xyz/openbmc_project/Raid/0/pd
      `-/xyz/openbmc_project/Raid/1
        |-/xyz/openbmc_project/Raid/1/ld
        `-/xyz/openbmc_project/Raid/1/pd

Test case:

1) Get RAID and HBA Device count

https://localhost:2443/redfish/v1/Systems/system/Storage
{
    "@odata.id": "/redfish/v1/Systems/system/Storage",
    "@odata.type": "#StorageCollection.StorageCollection",
    "Members": [
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/1"
        },
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_0"
        },
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_1"
        },
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/HBA_0"
        }
    ],
    "Members@odata.count": 4,
    "Name": "Storage Collection"
}

2) Get RAID instance

https://localhost:2443/redfish/v1/Systems/system/Storage/Raid_1
{
    "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_1",
    "@odata.type": "#Storage.v1_10_1.Storage",
    "Actions": {
        "Oem": {
            "#StorageCollection.CreateDrive": {
                "target": "/redfish/v1/Systems/system/Storage/Raid_1/Actions/StorageLDrive.Create"
            },
            "#StorageCollection.DeleteDrive": {
                "target": "/redfish/v1/Systems/system/Storage/Raid_1/Actions/StorageLDrive.Delete"
            }
        }
    },
    "Description": "Integrated Raid Controller",
    "Drives": [
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_1/Drives/0"
        },
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_1/Drives/1"
        }
    ],
    "Drives@odata.count": 2,
    "Id": "Raid_1",
    "Name": "Local Storage Controller",
    "Oem": {
        "OpenBmc": {
            "configComplete": 0,
            "manageRAIDConfigStatus": 0,
            "setRAIDDeleteLDStatus": 0
        }
    },
    "Status": {
        "Health": "OK"
    },
    "StorageControllers": [
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_1#/StorageControllers/0",
            "FirmwareVersion": "5.210.02-3663",
            "MemberId": "1",
            "Name": "MegaRAID 9560-16i 4GB",
            "SerialNumber": "SK01071465",
            "SupportedRAIDTypes": [
                "RAID0",
                "RAID1",
                "RAID10"
            ]
        }
    ],
    "Volumes": {
        "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_1/Volumes"
    }
}

3) Get Physical Drive Count

https://localhost:2443/redfish/v1/Systems/system/Storage/Raid_1/Volumes
{
    "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_1/Volumes",
    "@odata.type": "#VolumeCollection.VolumeCollection",
    "Members": [
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_1/Volumes/0"
        }
    ],
    "Members@odata.count": 1,
    "Name": "Volume Collection"
}

4) Get Physical Drive instance

https://localhost:2443/redfish/v1/Systems/system/Storage/Raid_1/Volumes/0
{
    "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_1/Volumes/0",
    "@odata.type": "#Volume.v1_6_2.Volume",
    "CapacityBytes": 499021512704,
    "DriveList": [
        34,
        99
    ],
    "Id": "0",
    "Links": {
        "Drives": [
            {
                "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_1/Drives/0"
            },
            {
                "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_1/Drives/1"
            }
        ],
        "Drives@odata.count": 2
    },
    "Name": "AMIRaid5",
    "RAIDType": "RAID0",
    "ReadCachePolicy": "NoReadAhead",
    "Status": {
        "Health": "OK"
    },
    "StripSizeBytes": 262144,
    "WriteCachePolicy": "WriteThrough"
}

5) Get Logical Drive instance
https://localhost:2443/redfish/v1/Systems/system/Storage/Raid_1/Drives/0

{
    "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_1/Drives/0",
    "@odata.type": "#Drive.v1_13_0.Drive",
    "BlockSizeBytes": 512,
    "FailurePredicted": 0,
    "Id": "34",
    "Links": {
        "Volumes": [
            {
                "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_1/Volumes/0"
            }
        ],
        "Volumes@odata.count": 1
    },
    "Manufacturer": "ATA",
    "Name": "PhysicalDisk_34",
    "NegotiatedSpeedGbs": 3.0,
    "Oem": {
        "OpenBmc": {
            "@odata.type": "#OemDrive.v1_0_0.Drive",
            "ProductID": "ST9250421AS",
            "SlotNumber": 1
        }
    },
    "Protocol": "SATA",
    "Revision": "SD13",
    "SerialNumber": "5TH06AQE",
    "Status": {
        "Health": "NG"
    }
}

6) Get HBA instance

https://localhost:2443/redfish/v1/Systems/system/Storage/HBA_0
{
    "@odata.id": "/redfish/v1/Systems/system/Storage/HBA_0",
    "@odata.type": "#Storage.v1_10_1.Storage",
    "Description": "Integrated HBA Controller",
    "Drives": [
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/HBA_0/Drives/0"
        },
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/HBA_0/Drives/1"
        }
    ],
    "Drives@odata.count": 2,
    "Id": "HBA_0",
    "Name": "Local Storage Controller",
    "Oem": {
        "OpenBmc": {
            "configComplete": 0,
            "manageRAIDConfigStatus": 0,
            "setRAIDDeleteLDStatus": 0
        }
    },
    "Status": {
        "Health": "OK"
    },
    "StorageControllers": [
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/HBA_0#/StorageControllers/0",
            "FirmwareVersion": "24.00.00.00",
            "MemberId": "83886080",
            "Name": "HBA 9500-16i",
            "SerialNumber": "SPC1719977"
        }
    ]
}

5) Get Logical HBA Drive instance
https://localhost:2443/redfish/v1/Systems/system/Storage/Raid_1/Drives/0

{
    "@odata.id": "/redfish/v1/Systems/system/Storage/HBA_0/Drives/0",
    "@odata.type": "#Drive.v1_13_0.Drive",
    "BlockSizeBytes": 512,
    "Id": "1",
    "Manufacturer": "ATA",
    "Name": "PhysicalDisk_1",
    "NegotiatedSpeedGbs": 3.0,
    "Oem": {
        "OpenBmc": {
            "@odata.type": "#OemDrive.v1_0_0.Drive",
            "ProductID": "ST9250421AS",
            "SlotNumber": 1
        }
    },
    "Protocol": "SATA",
    "Revision": "SD13",
    "SerialNumber": "5TH06AQE",
    "Status": {
        "Health": "OK"
    }
}

7) Create Logical Drive

POST Call
https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Raid_0/Actions/StorageLDrive.Create

Sample Json Body

{
    "CmdParm": 1,
    "Prl": 0,
    "StripeSize": 9,
    "InitState": 0,
    "DiskCachePolicy": 0,
    "SizeLow": 0,
    "SizeHigh": 0,
    "Readpolicy": 0,
    "Writepolicy": 0,
    "Iopolicy": 0,
    "Accesspolicy": 0,
    "SpanDepth": 1,
    "NumDrives": 2,
    "Accelerator": 0,
    "ParityGroupCount": 0,
    "ArrayNumber": 0,
    "VDName": [
        65,
        77,
        73,
        82,
        97,
        105,
        100,
        53
    ],
    "SpanID": [
        0,
        0
    ],
    "DeviceID": [
        3,
        4
    ]
}

Response
202

{
    "@odata.id": "/redfish/v1/TaskService/Tasks/1",
    "@odata.type": "#Task.v1_4_3.Task",
    "Id": "1",
    "TaskState": "New",
    "TaskStatus": "OK"
}

8) Get Call
https://{{BMCIP}}/redfish/v1/TaskService/Tasks/1

Response

{
    "@odata.id": "/redfish/v1/TaskService/Tasks/5",
    "@odata.type": "#Task.v1_4_3.Task",
    "EndTime": "2023-10-26T06:12:47+00:00",
    "HidePayload": false,
    "Id": "5",
    "Messages": [
        {
            "@odata.type": "#Message.v1_1_1.Message",
            "Message": "The task with Id '5' has started.",
            "MessageArgs": [
                "5"
            ],
            "MessageId": "TaskEvent.1.0.3.TaskStarted",
            "MessageSeverity": "OK",
            "Resolution": "None."
        },
        {
            "@odata.type": "#Message.v1_1_1.Message",
            "Message": "The task with Id '5' has completed.",
            "MessageArgs": [
                "5"
            ],
            "MessageId": "TaskEvent.1.0.3.TaskCompletedOK",
            "MessageSeverity": "OK",
            "Resolution": "None."
        }
    ],
    "Name": "Task 5",
    "Payload": {
        "HttpHeaders": [
            "User-Agent: PostmanRuntime/7.34.0",
            "Accept: */*",
            "Host: 172.31.32.52",
            "Accept-Encoding: gzip, deflate, br",
            "Connection: keep-alive",
            "Content-Length: 579"
        ],
        "HttpOperation": "POST",
        "JsonBody": "{\n  \"Accelerator\": 0,\n  \"Accesspolicy\": 0,\n  \"ArrayNumber\": 0,\n  \"CmdParm\": 1,\n  \"DeviceID\": [\n    3,\n    4\n  ],\n  \"DiskCachePolicy\": 0,\n  \"InitState\": 0,\n  \"Iopolicy\": 0,\n  \"NumDrives\": 2,\n  \"ParityGroupCount\": 0,\n  \"Prl\": 0,\n  \"Readpolicy\": 0,\n  \"SizeHigh\": 0,\n  \"SizeLow\": 0,\n  \"SpanDepth\": 1,\n  \"SpanID\": [\n    0,\n    0\n  ],\n  \"StripeSize\": 9,\n  \"VDName\": [\n    65,\n    77,\n    73,\n    82,\n    97,\n    105,\n    100,\n    53\n  ],\n  \"Writepolicy\": 0\n}",
        "TargetUri": "/redfish/v1/Systems/system/Storage/Raid_0/Actions/StorageLDrive.Create"
    },
    "PercentComplete": 100,
    "StartTime": "2023-10-26T06:12:41+00:00",
    "TaskMonitor": "/redfish/v1/TaskService/Tasks/5/Monitor",
    "TaskState": "SUCCESS",
    "TaskStatus": "OK"
}

9) Delete Logical drive

Post https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Raid_0/Actions/StorageLDrive.Delete

Body

{
    "LDriveId": "0"
}

Respose 202

{
    "@odata.id": "/redfish/v1/TaskService/Tasks/7",
    "@odata.type": "#Task.v1_4_3.Task",
    "Id": "5",
    "TaskState": "New",
    "TaskStatus": "OK"
}

Get https://{{BMCIP}}/redfish/v1/TaskService/Tasks/7

{
    "@odata.id": "/redfish/v1/TaskService/Tasks/7",
    "@odata.type": "#Task.v1_4_3.Task",
    "EndTime": "2023-10-30T19:04:02+00:00",
    "HidePayload": false,
    "Id": "7",
    "Messages": [
        {
            "@odata.type": "#Message.v1_1_1.Message",
            "Message": "The task with Id '7' has started.",
            "MessageArgs": [
                "7"
            ],
            "MessageId": "TaskEvent.1.0.3.TaskStarted",
            "MessageSeverity": "OK",
            "Resolution": "None."
        },
        {
            "@odata.type": "#Message.v1_1_1.Message",
            "Message": "The task with Id '7' has completed.",
            "MessageArgs": [
                "7"
            ],
            "MessageId": "TaskEvent.1.0.3.TaskCompletedOK",
            "MessageSeverity": "OK",
            "Resolution": "None."
        }
    ],
    "Name": "Task 7",
    "Payload": {
        "HttpHeaders": [
            "User-Agent: PostmanRuntime/7.34.0",
            "Accept: */*",
            "Host: 172.31.32.52",
            "Accept-Encoding: gzip, deflate, br",
            "Connection: keep-alive",
            "Content-Length: 25"
        ],
        "HttpOperation": "POST",
        "JsonBody": "{\n  \"LDriveId\": \"0\"\n}",
        "TargetUri": "/redfish/v1/Systems/system/Storage/Raid_0/Actions/StorageLDrive.Delete"
    },
    "PercentComplete": 100,
    "StartTime": "2023-10-30T19:03:56+00:00",
    "TaskMonitor": "/redfish/v1/TaskService/Tasks/7/Monitor",
    "TaskState": "SUCCESS",
    "TaskStatus": "OK"
}

Signed-off-by: Pranoy Goru <gorumanip@ami.com>
---
 redfish-core/include/redfish.hpp          |    7 +
 redfish-core/include/utils/collection.hpp |    3 +
 redfish-core/lib/raid.hpp                 |   37 +
 redfish-core/lib/storage.hpp              |    8 +
 redfish-core/lib/storage_raid.hpp         | 1105 +++++++++++++++++++++
 5 files changed, 1160 insertions(+)
 create mode 100644 redfish-core/lib/raid.hpp
 create mode 100644 redfish-core/lib/storage_raid.hpp

diff --git a/redfish-core/include/redfish.hpp b/redfish-core/include/redfish.hpp
index bb1990f9..6c8517a9 100644
--- a/redfish-core/include/redfish.hpp
+++ b/redfish-core/include/redfish.hpp
@@ -60,6 +60,7 @@
 #include "sensors.hpp"
 #include "service_root.hpp"
 #include "storage.hpp"
+#include "storage_raid.hpp"
 #include "systems.hpp"
 #include "task.hpp"
 #include "telemetry_service.hpp"
@@ -144,6 +145,12 @@ class RedfishService
         requestRoutesNvmePorts(app);
         requestRoutesNvmePortsInstance(app);
 
+        requestRoutesRaidLogical(app);
+        requestRoutesRaidLogicalDrive(app);
+        requestRoutesPhysicalDrive(app);
+        requestRoutesCreateLogicalDriveAction(app);
+        requestRoutesDeleteLogicalDriveAction(app);
+
         requestRoutesCable(app);
         requestRoutesCableCollection(app);
 #ifdef BMCWEB_INSECURE_ENABLE_REDFISH_FW_TFTP_UPDATE
diff --git a/redfish-core/include/utils/collection.hpp b/redfish-core/include/utils/collection.hpp
index 29476bc4..1ecd1dd4 100644
--- a/redfish-core/include/utils/collection.hpp
+++ b/redfish-core/include/utils/collection.hpp
@@ -5,6 +5,7 @@
 #include "error_messages.hpp"
 #include "http/utility.hpp"
 #include "human_sort.hpp"
+#include "raid.hpp"
 #include "storage_nvme.hpp"
 
 #include <boost/url/url.hpp>
@@ -90,6 +91,8 @@ inline void
                 asyncResp->res.jsonValue["Members@odata.count"];
             nlohmann::json& storageControllerArray = members;
             getNvmeDevices(asyncResp, count, storageControllerArray);
+            getRaidDevices(asyncResp, count, storageControllerArray);
+            getHBADevices(asyncResp, count, storageControllerArray);
         }
     });
 }
diff --git a/redfish-core/lib/raid.hpp b/redfish-core/lib/raid.hpp
new file mode 100644
index 00000000..32f84af1
--- /dev/null
+++ b/redfish-core/lib/raid.hpp
@@ -0,0 +1,37 @@
+#pragma once
+
+#include "health.hpp"
+#include "openbmc_dbus_rest.hpp"
+#include "redfish_util.hpp"
+#include "utils/json_utils.hpp"
+
+#include <app.hpp>
+#include <registries/privilege_registry.hpp>
+
+namespace redfish
+{
+
+void getLogicalDrives(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
+                             const std::string& raidName,
+                             nlohmann::json& storageArray,
+                             nlohmann::json& count);
+
+void getPhysicalDrives(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
+                              const std::string& name,
+                              nlohmann::json& storageArray,
+                              nlohmann::json& count, int flag,
+                              const std::string& pdPath,
+                              const std::array<const char*, 1> interfaces);
+
+void getRaidDevices(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
+                           nlohmann::json& count,
+                           nlohmann::json& storageControllerArray);
+
+void getHBADevices(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
+                          nlohmann::json& count,
+                          nlohmann::json& storageControllerArray);
+
+void getStorageInstance(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
+                               const std::string& name);
+
+}
diff --git a/redfish-core/lib/storage.hpp b/redfish-core/lib/storage.hpp
index 39415845..4a67611c 100644
--- a/redfish-core/lib/storage.hpp
+++ b/redfish-core/lib/storage.hpp
@@ -25,6 +25,7 @@
 #include "human_sort.hpp"
 #include "openbmc_dbus_rest.hpp"
 #include "query.hpp"
+#include "raid.hpp"
 #include "redfish_util.hpp"
 #include "registries/privilege_registry.hpp"
 #include "utils/collection.hpp"
@@ -207,6 +208,13 @@ inline void
     {
         return;
     }
+    std::size_t raid = storageId.find("Raid_");
+    std::size_t hba = storageId.find("HBA_");
+    if ((raid != std::string::npos) || (hba != std::string::npos))
+    {
+        getStorageInstance(asyncResp, storageId);
+        return;
+    }
     if constexpr (bmcwebEnableMultiHost)
     {
         // Option currently returns no systems.  TBD
diff --git a/redfish-core/lib/storage_raid.hpp b/redfish-core/lib/storage_raid.hpp
new file mode 100644
index 00000000..f582e058
--- /dev/null
+++ b/redfish-core/lib/storage_raid.hpp
@@ -0,0 +1,1105 @@
+/*
+// Copyright (c) 2021 AMI Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+*/
+#include "raid.hpp"
+
+#include <task.hpp>
+
+namespace redfish
+{
+
+void getLogicalDrives(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
+                      const std::string& raidName, nlohmann::json& storageArray,
+                      nlohmann::json& count)
+
+{
+    const std::string& ldPath = "/xyz/openbmc_project/Raid/" + raidName + "/ld";
+    crow::connections::systemBus->async_method_call(
+        [asyncResp, raidName, &storageArray,
+         &count](const boost::system::error_code ec,
+                 const std::vector<std::string>& storageList) {
+        if (ec)
+        {
+            BMCWEB_LOG_ERROR("Volume mapper call error");
+            messages::internalError(asyncResp->res);
+            return;
+        }
+
+        for (const std::string& objpath : storageList)
+        {
+            std::size_t lastPos = objpath.rfind('/');
+            if (lastPos == std::string::npos || (objpath.size() <= lastPos + 1))
+            {
+                BMCWEB_LOG_ERROR("Failed to find '/' in ", objpath);
+                continue;
+            }
+            storageArray.push_back(
+                {{"@odata.id", "/redfish/v1/Systems/system/Storage/Raid_" +
+                                   raidName + "/Volumes/" +
+                                   objpath.substr(lastPos + 1)}});
+        }
+        count = storageArray.size();
+    },
+        "xyz.openbmc_project.ObjectMapper",
+        "/xyz/openbmc_project/object_mapper",
+        "xyz.openbmc_project.ObjectMapper", "GetSubTreePaths", ldPath, 0,
+        std::array<const char*, 1>{"xyz.openbmc_project.raid.LogicalDrive"});
+}
+
+void raidStatusTask(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                    task::Payload&& payload, const std::string& propertyName)
+{
+    std::shared_ptr<task::TaskData> task = task::TaskData::createTask(
+        [propertyName](const boost::system::error_code ec,
+                       sdbusplus::message_t& msg,
+                       const std::shared_ptr<task::TaskData>& taskData) {
+        if (ec)
+        {
+            taskData->messages.emplace_back(messages::internalError());
+            taskData->state = "Cancelled";
+            return task::completed;
+        }
+
+        std::string iface;
+        dbus::utility::DBusPropertiesMap values;
+
+        std::string index = std::to_string(taskData->index);
+        msg.read(iface, values);
+
+        if (iface == "xyz.openbmc_project.raid.Base")
+        {
+            const uint32_t* status = nullptr;
+
+            for (const auto& property : values)
+            {
+                if (property.first == propertyName)
+                {
+                    status = std::get_if<uint32_t>(&property.second);
+                    if (status == nullptr)
+                    {
+                        taskData->messages.emplace_back(
+                            messages::internalError());
+                        return task::completed;
+                    }
+                }
+            }
+
+            if (status == nullptr)
+            {
+                return !task::completed;
+            }
+
+            if (*status == 4294967295)
+            {
+                BMCWEB_LOG_DEBUG("COMMAND_IN_PROGRESS case");
+                taskData->state = "COMMAND_IN_PROGRESS";
+                taskData->messages.emplace_back(messages::taskStarted(index));
+                taskData->extendTimer(std::chrono::minutes(3));
+                return !task::completed;
+            }
+            if (*status == 0)
+            {
+                BMCWEB_LOG_DEBUG("Command SUCCESS case");
+                taskData->state = "SUCCESS";
+                taskData->messages.emplace_back(
+                    messages::taskCompletedOK(index));
+                taskData->percentComplete = 100;
+                return task::completed;
+            }
+            if (*status == 129)
+            {
+                BMCWEB_LOG_DEBUG("RAID_DEVICE_NOT_PRESENT Failed case");
+                taskData->state = "RAID_DEVICE_NOT_PRESENT";
+                taskData->messages.emplace_back(messages::taskAborted(index));
+                taskData->percentComplete = 100;
+                return task::completed;
+            }
+            if (*status == 130)
+            {
+                BMCWEB_LOG_DEBUG("RAID_CTRL_ID_INVALID Failed case");
+                taskData->state = "RAID_CTRL_ID_INVALID";
+                taskData->messages.emplace_back(messages::taskAborted(index));
+                taskData->percentComplete = 100;
+                return task::completed;
+            }
+            if (*status == 131)
+            {
+                BMCWEB_LOG_DEBUG("RAID_CTRL_DEVID_INVALID Failed case");
+                taskData->state = "RAID_CTRL_DEVID_INVALID";
+                taskData->messages.emplace_back(messages::taskAborted(index));
+                taskData->percentComplete = 100;
+                return task::completed;
+            }
+            if (*status == 132)
+            {
+                BMCWEB_LOG_DEBUG("RAID_NO_VIRTUAL_DEVICE_PRESENT Failed case");
+                taskData->state = "RAID_NO_VIRTUAL_DEVICE_PRESENT";
+                taskData->messages.emplace_back(messages::taskAborted(index));
+                taskData->percentComplete = 100;
+                return task::completed;
+            }
+            if (*status == 133)
+            {
+                BMCWEB_LOG_DEBUG("RAID_OPERATION_NOT_PERMITTED case");
+                taskData->state = "RAID_OPERATION_NOT_PERMITTED";
+                taskData->messages.emplace_back(messages::taskAborted(index));
+                taskData->percentComplete = 100;
+                return task::completed;
+            }
+            if (*status == 134)
+            {
+                BMCWEB_LOG_DEBUG("RAID_UNSUPPORTED_LOGICAL_DEV Failed case");
+                taskData->state = "RAID_UNSUPPORTED_LOGICAL_DEV";
+                taskData->messages.emplace_back(messages::taskAborted(index));
+                taskData->percentComplete = 100;
+                return task::completed;
+            }
+            if (*status == 135)
+            {
+                BMCWEB_LOG_DEBUG("RAID_OPERATION_NOT_PERMITTED case");
+                taskData->state = "RAID_OPERATION_NOT_PERMITTED";
+                taskData->messages.emplace_back(messages::taskAborted(index));
+                taskData->percentComplete = 100;
+                return task::completed;
+            }
+            if (*status == 140)
+            {
+                BMCWEB_LOG_DEBUG("RAID_COMMAND_FAILED case");
+                taskData->state = "RAID_COMMAND_FAILED";
+                taskData->messages.emplace_back(messages::taskAborted(index));
+                taskData->percentComplete = 100;
+                return task::completed;
+            }
+            if (*status == 255)
+            {
+                BMCWEB_LOG_DEBUG("UNSPECIFIED_ERR case");
+                taskData->state = "UNSPECIFIED_ERR";
+                taskData->messages.emplace_back(messages::taskAborted(index));
+                taskData->percentComplete = 100;
+                return task::completed;
+            }
+        }
+
+        return !task::completed;
+    },
+        "type='signal',interface='org.freedesktop.DBus.Properties',"
+        "member='PropertiesChanged',path='/xyz/openbmc_project/Raid'");
+    task->startTimer(std::chrono::minutes(3));
+    task->populateResp(asyncResp->res);
+    task->payload.emplace(std::move(payload));
+}
+
+inline void requestRoutesDeleteLogicalDriveAction(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/"
+                      "<str>/Actions/StorageLDrive.Delete")
+        .privileges(redfish::privileges::postChassis)
+        .methods(boost::beast::http::verb::post)(
+            [](const crow::Request& req,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& name) {
+        //            if (!redfish::utils::checkLicenseStatus(asyncResp,
+        //                                                    "StorageLDrive.Delete"))
+        //            {
+        //                return;
+        //            }
+        crow::connections::systemBus->async_method_call(
+            [asyncResp, req, name](const boost::system::error_code ec1,
+                                   const std::variant<uint32_t>& val) {
+            if (ec1)
+            {
+                BMCWEB_LOG_DEBUG("Failed to get property Value  ", ec1);
+                return;
+            }
+
+            const uint32_t* status = std::get_if<uint32_t>(&val);
+
+            if (*status == 0)
+            {
+                std::size_t type = name.find("_");
+                if (type != std::string::npos)
+                {
+                    const std::string& path = "/xyz/openbmc_project/" +
+                                              name.substr(0, type) + "/" +
+                                              name.substr(type + 1);
+
+                    crow::connections::systemBus->async_method_call(
+                        [asyncResp, req, name,
+                         type](const boost::system::error_code ec,
+                               const std::variant<uint32_t> value) {
+                        if (ec)
+                        {
+                            BMCWEB_LOG_DEBUG("failed to get property Value  ",
+                                             ec);
+                            messages::resourceNotFound(asyncResp->res, "",
+                                                       "LDriveId");
+                            return;
+                        }
+
+                        const uint32_t* ctrlId = std::get_if<uint32_t>(&value);
+
+                        std::string ldriveId;
+
+                        if (!json_util::readJsonAction(req, asyncResp->res,
+                                                       "LDriveId", ldriveId))
+                        {
+                            BMCWEB_LOG_DEBUG("Paramaters are not provided");
+                            return;
+                        }
+
+                        const std::string& ldpath =
+                            "/xyz/openbmc_project/" + name.substr(0, type) +
+                            "/" + name.substr(type + 1) + "/ld/" + ldriveId;
+
+                        const uint32_t val = *ctrlId;
+
+                        crow::connections::systemBus->async_method_call(
+                            [asyncResp, req,
+                             val](const boost::system::error_code ec,
+                                  const std::variant<uint16_t> value) {
+                            if (ec)
+                            {
+                                BMCWEB_LOG_DEBUG(
+                                    "failed to get property Value  ", ec);
+                                messages::resourceNotFound(asyncResp->res, "",
+                                                           "LDriveId");
+                                return;
+                            }
+                            const uint16_t* targetId =
+                                std::get_if<uint16_t>(&value);
+
+                            crow::connections::systemBus->async_method_call(
+                                [asyncResp,
+                                 req](const boost::system::error_code ec) {
+                                if (ec)
+                                {
+                                    BMCWEB_LOG_ERROR(
+                                        "Bad D-Bus request error: ", ec);
+                                    messages::resourceNotFound(asyncResp->res,
+                                                               "", "LDriveId");
+                                    return;
+                                }
+                                task::Payload payload(req);
+                                raidStatusTask(asyncResp, std::move(payload),
+                                               "setRAIDDeleteLDStatus");
+                            },
+                                "xyz.openbmc_project.raid.manager",
+                                "/xyz/openbmc_project/Raid",
+                                "xyz.openbmc_project.raid.Base",
+                                "setRAIDDeleteLD", val, *targetId);
+                        },
+                            "xyz.openbmc_project.raid.manager", ldpath,
+                            "org.freedesktop.DBus.Properties", "Get",
+                            "xyz.openbmc_project.raid.LogicalDrive",
+                            "TargetId");
+                    },
+                        "xyz.openbmc_project.raid.manager", path,
+                        "org.freedesktop.DBus.Properties", "Get",
+                        "xyz.openbmc_project.raid.Controller", "MemberId");
+                }
+                else
+                {
+                    messages::internalError(asyncResp->res);
+                    return;
+                }
+            }
+            else
+            {
+                messages::actionNotSupported(
+                    asyncResp->res,
+                    "StorageLDrive.Delete already running and it");
+                return;
+            }
+        },
+            "xyz.openbmc_project.raid.manager", "/xyz/openbmc_project/Raid",
+            "org.freedesktop.DBus.Properties", "Get",
+            "xyz.openbmc_project.raid.Base", "configComplete");
+    });
+}
+
+inline void requestRoutesCreateLogicalDriveAction(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/"
+                      "<str>/Actions/StorageLDrive.Create")
+        .privileges(redfish::privileges::postChassis)
+        .methods(boost::beast::http::verb::post)(
+            [](const crow::Request& req,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& name) {
+        //                if (!redfish::utils::checkLicenseStatus(asyncResp,
+        //                                                        "StorageLDrive.Create"))
+        //                {
+        //                    return;
+        //                }
+
+        crow::connections::systemBus->async_method_call(
+            [asyncResp, req, name](const boost::system::error_code ec1,
+                                   const std::variant<uint32_t>& val) {
+            if (ec1)
+            {
+                BMCWEB_LOG_DEBUG("Failed to get property Value ", ec1);
+                return;
+            }
+            const uint32_t* status = std::get_if<uint32_t>(&val);
+            if (*status == 0)
+            {
+                std::size_t type = name.find("_");
+                if (type != std::string::npos)
+                {
+                    const std::string& path = "/xyz/openbmc_project/" +
+                                              name.substr(0, type) + "/" +
+                                              name.substr(type + 1);
+
+                    crow::connections::systemBus->async_method_call(
+                        [asyncResp, req](const boost::system::error_code ec,
+                                         const std::variant<uint32_t> value) {
+                        if (ec)
+                        {
+                            BMCWEB_LOG_DEBUG("Failed to get property Value  ",
+                                             ec);
+                            return;
+                        }
+
+                        std::uint8_t cmdParm;
+                        std::uint8_t prl;
+                        std::uint8_t stripeSize;
+                        std::uint8_t initState;
+                        std::uint8_t diskCachePolicy;
+                        std::uint32_t sizeLow;
+                        std::uint32_t sizeHigh;
+                        std::uint8_t readpolicy;
+                        std::uint8_t writepolicy;
+                        std::uint8_t iopolicy;
+                        std::uint8_t accesspolicy;
+                        std::uint8_t spanDepth;
+                        std::uint8_t numDrives;
+                        std::uint8_t Accelerator;
+                        std::uint8_t ParityGroupCount;
+                        std::uint16_t ArrayNumber;
+                        //      std::string VdNameBuf;
+                        std::vector<uint8_t> VDName;
+                        std::vector<uint8_t> SpanID;
+                        std::vector<uint16_t> deviceID;
+
+                        if (!json_util::readJsonAction(
+                                req, asyncResp->res, "CmdParm", cmdParm, "Prl",
+                                prl, "StripeSize", stripeSize, "InitState",
+                                initState, "DiskCachePolicy", diskCachePolicy,
+                                "SizeLow", sizeLow, "SizeHigh", sizeHigh,
+                                "Readpolicy", readpolicy, "Writepolicy",
+                                writepolicy, "Iopolicy", iopolicy,
+                                "Accesspolicy", accesspolicy, "SpanDepth",
+                                spanDepth, "NumDrives", numDrives,
+                                "Accelerator", Accelerator, "ParityGroupCount",
+                                ParityGroupCount, "ArrayNumber", ArrayNumber,
+                                "VDName", VDName, "SpanID", SpanID, "DeviceID",
+                                deviceID))
+                        {
+                            BMCWEB_LOG_DEBUG("Paramaters are not provided");
+                            return;
+                        }
+
+                        const uint32_t* ctrlId = std::get_if<uint32_t>(&value);
+
+                        crow::connections::systemBus->async_method_call(
+                            [asyncResp,
+                             req](const boost::system::error_code ec) {
+                            if (ec)
+                            {
+                                BMCWEB_LOG_ERROR(
+                                    "Bad Invalid Arguments D-Bus request error:  ",
+                                    ec);
+                                messages::internalError(asyncResp->res);
+                                return;
+                            }
+                            task::Payload payload(req);
+                            raidStatusTask(asyncResp, std::move(payload),
+                                           "manageRAIDConfigStatus");
+                        },
+                            "xyz.openbmc_project.raid.manager",
+                            "/xyz/openbmc_project/Raid",
+                            "xyz.openbmc_project.raid.Base", "manageRAIDConfig",
+                            *ctrlId, cmdParm, prl, stripeSize, initState,
+                            diskCachePolicy, sizeLow, sizeHigh, readpolicy,
+                            writepolicy, iopolicy, accesspolicy, spanDepth,
+                            numDrives, Accelerator, ParityGroupCount,
+                            ArrayNumber, VDName, SpanID, deviceID);
+                    },
+                        "xyz.openbmc_project.raid.manager", path,
+                        "org.freedesktop.DBus.Properties", "Get",
+                        "xyz.openbmc_project.raid.Controller", "MemberId");
+                }
+                else
+                {
+                    messages::internalError(asyncResp->res);
+                    return;
+                }
+            }
+            else
+            {
+                messages::actionNotSupported(
+                    asyncResp->res,
+                    "StorageLDrive.Create already running and it");
+                return;
+            }
+        },
+            "xyz.openbmc_project.raid.manager", "/xyz/openbmc_project/Raid",
+            "org.freedesktop.DBus.Properties", "Get",
+            "xyz.openbmc_project.raid.Base", "configComplete");
+    });
+}
+
+void getPhysicalDrives(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
+                       const std::string& name, nlohmann::json& storageArray,
+                       nlohmann::json& count, int flag,
+                       const std::string& pdPath,
+                       const std::array<const char*, 1> interfaces)
+{
+    crow::connections::systemBus->async_method_call(
+        [asyncResp, name, &storageArray, &count,
+         flag](const boost::system::error_code ec,
+               const std::vector<std::string>& storageList) {
+        if (ec)
+        {
+            BMCWEB_LOG_ERROR("Drive mapper call error");
+            messages::internalError(asyncResp->res);
+            return;
+        }
+
+        for (const std::string& objpath : storageList)
+        {
+            std::size_t lastPos = objpath.rfind('/');
+            if (lastPos == std::string::npos || (objpath.size() <= lastPos + 1))
+            {
+                BMCWEB_LOG_ERROR("Failed to find '/' in ", objpath);
+                continue;
+            }
+            if (flag == 1)
+                storageArray.push_back(
+                    {{"@odata.id", "/redfish/v1/Systems/system/Storage/Raid_" +
+                                       name + "/Drives/" +
+                                       objpath.substr(lastPos + 1)}});
+            else
+                storageArray.push_back(
+                    {{"@odata.id", "/redfish/v1/Systems/system/Storage/HBA_" +
+                                       name + "/Drives/" +
+                                       objpath.substr(lastPos + 1)}});
+        }
+        count = storageArray.size();
+    },
+        "xyz.openbmc_project.ObjectMapper",
+        "/xyz/openbmc_project/object_mapper",
+        "xyz.openbmc_project.ObjectMapper", "GetSubTreePaths", pdPath, 0,
+        interfaces);
+}
+
+void getRaidDevices(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
+                    nlohmann::json& count,
+                    nlohmann::json& storageControllerArray)
+{
+    crow::connections::systemBus->async_method_call(
+        [asyncResp, &count,
+         &storageControllerArray](const boost::system::error_code ec,
+                                  const std::vector<std::string>& storageList) {
+        if (ec)
+        {
+            BMCWEB_LOG_ERROR("DBUS error: no matched iface \n");
+            //    messages::internalError(asyncResp->res);
+            return;
+        }
+        for (const std::string& objpath : storageList)
+        {
+            std::size_t lastPos = objpath.rfind('/');
+            if (lastPos == std::string::npos || (objpath.size() <= lastPos + 1))
+            {
+                BMCWEB_LOG_ERROR("Failed to find '/' in ", objpath);
+                continue;
+            }
+            storageControllerArray.push_back(
+                {{"@odata.id", "/redfish/v1/Systems/system/Storage/Raid_" +
+                                   objpath.substr(lastPos + 1)}});
+        } // object path loop
+        count = storageControllerArray.size();
+    },
+        "xyz.openbmc_project.ObjectMapper",
+        "/xyz/openbmc_project/object_mapper",
+        "xyz.openbmc_project.ObjectMapper", "GetSubTreePaths",
+        "/xyz/openbmc_project/Raid", 0,
+        std::array<const char*, 1>{"xyz.openbmc_project.raid.Controller"});
+}
+
+void requestRoutesRaidLogical(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/Raid_"
+                      "<str>"
+                      "/Volumes/")
+        .privileges(redfish::privileges::getStorage)
+        .methods(boost::beast::http::verb::get)(
+            [](const crow::Request&,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& raidName) {
+        //                if (!redfish::utils::checkLicenseStatus(asyncResp,
+        //                                                        "Raid_" +
+        //                                                        raidName))
+        //                {
+        //                    return;
+        //                }
+        asyncResp->res.jsonValue["@odata.type"] =
+            "#VolumeCollection.VolumeCollection";
+        asyncResp->res.jsonValue["@odata.id"] =
+            "/redfish/v1/Systems/system/Storage/Raid_" + raidName + "/Volumes";
+        asyncResp->res.jsonValue["Name"] = "Volume Collection";
+        nlohmann::json& storageControllerArray =
+            asyncResp->res.jsonValue["Members"];
+        storageControllerArray = nlohmann::json::array();
+        nlohmann::json& count = asyncResp->res.jsonValue["Members@odata.count"];
+        getLogicalDrives(asyncResp, raidName, storageControllerArray, count);
+    });
+}
+
+inline void requestRoutesRaidLogicalDrive(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/Raid_"
+                      "<str>"
+                      "/Volumes/"
+                      "<str>")
+        .privileges(redfish::privileges::getStorage)
+        .methods(boost::beast::http::verb::get)(
+            [](const crow::Request&,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& raidName, const std::string& driveName) {
+        //            if (!redfish::utils::checkLicenseStatus(asyncResp,
+        //                                                    "Raid_" +
+        //                                                    raidName))
+        //            {
+        //                return;
+        //            }
+        asyncResp->res.jsonValue["@odata.type"] = "#Volume.v1_6_2.Volume";
+        asyncResp->res.jsonValue["@odata.id"] =
+            "/redfish/v1/Systems/system/Storage/Raid_" + raidName +
+            "/Volumes/" + driveName;
+        // asyncResp->res.jsonValue["Id"] = driveName;
+        const std::string& ldPath = "/xyz/openbmc_project/Raid/" + raidName +
+                                    "/ld/" + driveName;
+        crow::connections::systemBus->async_method_call(
+            [asyncResp](
+                const boost::system::error_code ec2,
+                const std::vector<std::pair<
+                    std::string, std::variant<std::string, uint64_t, uint32_t,
+                                              std::vector<uint16_t>>>>&
+                    propertiesList) {
+            if (ec2)
+            {
+                return;
+            }
+            for (const std::pair<std::string,
+                                 std::variant<std::string, uint64_t, uint32_t,
+                                              std::vector<uint16_t>>>&
+                     property : propertiesList)
+            {
+                const std::string& propertyName = property.first;
+
+                if (propertyName == "StripSizeBytes")
+                {
+                    const uint32_t* value =
+                        std::get_if<uint32_t>(&property.second);
+                    if (value != nullptr)
+                    {
+                        asyncResp->res.jsonValue[propertyName] = *value;
+                    }
+                }
+                else if (propertyName == "CapacityBytes")
+                {
+                    const uint64_t* value =
+                        std::get_if<uint64_t>(&property.second);
+                    if (value != nullptr)
+                    {
+                        asyncResp->res.jsonValue[propertyName] = *value;
+                    }
+                }
+                else if ((propertyName == "RAIDType") ||
+                         (propertyName == "ReadCachePolicyType") ||
+                         (propertyName == "WriteCachePolicyType"))
+                {
+                    const std::string* value =
+                        std::get_if<std::string>(&property.second);
+                    if (value != nullptr)
+                    {
+                        if (propertyName == "ReadCachePolicyType")
+                        {
+                            asyncResp->res.jsonValue["ReadCachePolicy"] =
+                                *value;
+                        }
+                        else if (propertyName == "WriteCachePolicyType")
+                        {
+                            asyncResp->res.jsonValue["WriteCachePolicy"] =
+                                *value;
+                        }
+                        else
+                            asyncResp->res.jsonValue[propertyName] = *value;
+                    }
+                }
+                else if (propertyName == "Health")
+                {
+                    const std::string* value =
+                        std::get_if<std::string>(&property.second);
+                    if (*value == "ok")
+                        asyncResp->res.jsonValue["Status"][propertyName] =
+                            *value;
+                    else
+                        asyncResp->res.jsonValue["Status"][propertyName] =
+                            *value;
+                }
+                else if (propertyName == "DriveList")
+                {
+                    const std::vector<uint16_t>* value =
+                        std::get_if<std::vector<uint16_t>>(&property.second);
+                    if (value != nullptr)
+                    {
+                        asyncResp->res.jsonValue[propertyName] = *value;
+                    }
+                }
+                else if (propertyName == "Name")
+                {
+                    const std::string* value =
+                        std::get_if<std::string>(&property.second);
+                    asyncResp->res.jsonValue[propertyName] = *value;
+                }
+                else if (propertyName == "TargetId")
+                {
+                    const std::vector<uint16_t>* value =
+                        std::get_if<std::vector<uint16_t>>(&property.second);
+                    if (value != nullptr)
+                    {
+                        asyncResp->res.jsonValue["Id"] = *value;
+                    }
+                }
+            }
+        },
+            "xyz.openbmc_project.raid.manager", ldPath,
+            "org.freedesktop.DBus.Properties", "GetAll",
+            "xyz.openbmc_project.raid.LogicalDrive");
+        nlohmann::json& storageControllerArray =
+            asyncResp->res.jsonValue["Links"]["Drives"];
+        storageControllerArray = nlohmann::json::array();
+        nlohmann::json& count =
+            asyncResp->res.jsonValue["Links"]["Drives@odata.count"];
+        const std::string& pdPath = "/xyz/openbmc_project/Raid/" + raidName +
+                                    "/pd";
+        const std::array<const char*, 1> interfaces = {
+            "xyz.openbmc_project.raid.PhysicalDrive"};
+
+        getPhysicalDrives(asyncResp, raidName, storageControllerArray, count, 1,
+                          pdPath, interfaces);
+    });
+}
+
+void getHBADevices(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
+                   nlohmann::json& count,
+                   nlohmann::json& storageControllerArray)
+{
+    crow::connections::systemBus->async_method_call(
+        [asyncResp, &count,
+         &storageControllerArray](const boost::system::error_code ec,
+                                  const std::vector<std::string>& storageList) {
+        if (ec)
+        {
+            BMCWEB_LOG_ERROR("DBUS error: no matched iface \n");
+            //    messages::internalError(asyncResp->res);
+            return;
+        }
+        for (const std::string& objpath : storageList)
+        {
+            std::size_t lastPos = objpath.rfind('/');
+            if (lastPos == std::string::npos || (objpath.size() <= lastPos + 1))
+            {
+                BMCWEB_LOG_ERROR("Failed to find '/' in ", objpath);
+                continue;
+            }
+            storageControllerArray.push_back(
+                {{"@odata.id", "/redfish/v1/Systems/system/Storage/HBA_" +
+                                   objpath.substr(lastPos + 1)}});
+        } // object path loop
+        count = storageControllerArray.size();
+    },
+        "xyz.openbmc_project.ObjectMapper",
+        "/xyz/openbmc_project/object_mapper",
+        "xyz.openbmc_project.ObjectMapper", "GetSubTreePaths",
+        "/xyz/openbmc_project/HBA", 0,
+        std::array<const char*, 1>{"xyz.openbmc_project.hba.Controller"});
+}
+
+void getStorageInstance(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
+                        const std::string& name)
+{
+    asyncResp->res.jsonValue["@odata.type"] = "#Storage.v1_10_1.Storage";
+    asyncResp->res.jsonValue["@odata.id"] =
+        "/redfish/v1/Systems/system/Storage/" + name;
+    asyncResp->res.jsonValue["Name"] = "Local Storage Controller";
+
+    asyncResp->res.jsonValue["Id"] = name;
+
+    std::size_t type = name.find("_");
+    if (type != std::string::npos)
+    {
+        asyncResp->res.jsonValue["Description"] =
+            "Integrated " + name.substr(0, type) + " Controller";
+
+        const std::string& path = "/xyz/openbmc_project/" +
+                                  name.substr(0, type) + "/" +
+                                  name.substr(type + 1);
+
+        const std::string& pdPath = "/xyz/openbmc_project/" +
+                                    name.substr(0, type) + "/" +
+                                    name.substr(type + 1) + "/pd";
+
+        const char* service;
+        const char* inf;
+        const char* driveInf;
+        int flag;
+
+        if (name.substr(0, type) == "HBA")
+        {
+            service = "xyz.openbmc_project.hba.manager";
+            inf = "xyz.openbmc_project.hba.Controller";
+            driveInf = "xyz.openbmc_project.hba.PhysicalDrive";
+            flag = 2;
+        }
+        else if (name.substr(0, type) == "Raid")
+        {
+            asyncResp->res.jsonValue["Volumes"] = {
+                {"@odata.id",
+                 "/redfish/v1/Systems/system/Storage/" + name + "/Volumes"}};
+            asyncResp->res.jsonValue["Actions"]["Oem"]
+                                    ["#StorageCollection.CreateDrive"] = {
+                {"target", "/redfish/v1/Systems/system/Storage/" + name +
+                               "/Actions/StorageLDrive.Create"}};
+
+            asyncResp->res.jsonValue["Actions"]["Oem"]
+                                    ["#StorageCollection.DeleteDrive"] = {
+                {"target", "/redfish/v1/Systems/system/Storage/" + name +
+                               "/Actions/StorageLDrive.Delete"}};
+
+            service = "xyz.openbmc_project.raid.manager";
+            inf = "xyz.openbmc_project.raid.Controller";
+            driveInf = "xyz.openbmc_project.raid.PhysicalDrive";
+            flag = 1;
+        }
+        else
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+        nlohmann::json& storageControllerArray =
+            asyncResp->res.jsonValue["Drives"];
+        storageControllerArray = nlohmann::json::array();
+        nlohmann::json& count = asyncResp->res.jsonValue["Drives@odata.count"];
+        const std::array<const char*, 1> interfaces = {driveInf};
+        getPhysicalDrives(asyncResp, name.substr(type + 1),
+                          storageControllerArray, count, flag, pdPath,
+                          (interfaces));
+
+        crow::connections::systemBus->async_method_call(
+            [asyncResp](
+                const boost::system::error_code ec2,
+                const std::vector<
+                    std::pair<std::string, std::variant<bool, uint32_t>>>&
+                    propertiesList) {
+            if (ec2)
+            {
+                return;
+            }
+            for (const std::pair<std::string, std::variant<bool, uint32_t>>&
+                     property : propertiesList)
+            {
+                const std::string& propertyName = property.first;
+                if ((propertyName == "manageRAIDConfigStatus") ||
+                    (propertyName == "setRAIDDeleteLDStatus") ||
+                    (propertyName == "configComplete"))
+                {
+                    const uint32_t* value =
+                        std::get_if<uint32_t>(&property.second);
+                    if (value != nullptr)
+                    {
+                        asyncResp->res
+                            .jsonValue["Oem"]["OpenBmc"][propertyName] = *value;
+                    }
+                }
+            }
+        },
+            "xyz.openbmc_project.raid.manager", "/xyz/openbmc_project/Raid",
+            "org.freedesktop.DBus.Properties", "GetAll",
+            "xyz.openbmc_project.raid.Base");
+
+        crow::connections::systemBus->async_method_call(
+            [asyncResp, name,
+             type](const boost::system::error_code ec2,
+                   const std::vector<std::pair<
+                       std::string, std::variant<bool, std::string, uint32_t>>>&
+                       propertiesList) {
+            if (ec2)
+            {
+                messages::internalError(asyncResp->res);
+                return;
+            }
+
+            nlohmann::json& controllerArray =
+                asyncResp->res.jsonValue["StorageControllers"];
+            controllerArray = nlohmann::json::array();
+
+            nlohmann::json& storageController =
+                controllerArray.emplace_back(nlohmann::json::object());
+
+            storageController["@odata.id"] =
+                "/redfish/v1/Systems/system/Storage/" + name +
+                "#/StorageControllers/0";
+
+            for (const std::pair<std::string,
+                                 std::variant<bool, std::string, uint32_t>>&
+                     property : propertiesList)
+            {
+                const std::string& propertyName = property.first;
+
+                if (propertyName == "MemberId")
+                {
+                    const uint32_t* value =
+                        std::get_if<uint32_t>(&property.second);
+                    if (value != nullptr)
+                    {
+                        storageController[propertyName] =
+                            std::to_string(*value);
+                    }
+                }
+                if ((propertyName == "Name") ||
+                    (propertyName == "SerialNumber") ||
+                    (propertyName == "FirmwareVersion"))
+                {
+                    const std::string* value =
+                        std::get_if<std::string>(&property.second);
+                    if (value != nullptr)
+                    {
+                        storageController[propertyName] = *value;
+                    }
+                }
+
+                if (propertyName == "Health")
+                {
+                    const std::string* value =
+                        std::get_if<std::string>(&property.second);
+                    if (*value == "ok")
+                        asyncResp->res.jsonValue["Status"][propertyName] =
+                            *value;
+                    else
+                        asyncResp->res.jsonValue["Status"][propertyName] =
+                            *value;
+                }
+
+                if (name.substr(0, type) == "Raid")
+                {
+                    if ((propertyName == "SupportedRAIDTypes_RAID0") ||
+                        // (propertyName ==
+                        //  "SupportedRAIDTypes_RAID00") ||
+                        (propertyName == "SupportedRAIDTypes_RAID1") ||
+                        (propertyName == "SupportedRAIDTypes_RAID10") ||
+                        (propertyName == "SupportedRAIDTypes_RAID1E") ||
+                        (propertyName == "SupportedRAIDTypes_RAID1E0_RLQ0") ||
+                        (propertyName == "SupportedRAIDTypes_RAID1E_RLQ0") ||
+                        (propertyName == "SupportedRAIDTypes_RAID5") ||
+                        (propertyName == "SupportedRAIDTypes_RAID50") ||
+                        (propertyName == "SupportedRAIDTypes_RAID6") ||
+                        (propertyName == "SupportedRAIDTypes_RAID60"))
+                    {
+                        const bool* value = std::get_if<bool>(&property.second);
+                        nlohmann::json& entriesArray =
+                            storageController["SupportedRAIDTypes"];
+                        if (!entriesArray.is_array())
+                            entriesArray = nlohmann::json::array();
+                        std::size_t found = propertyName.rfind("_");
+                        if (found != std::string::npos)
+                        {
+                            if (*value == true)
+                                entriesArray.push_back(
+                                    propertyName.substr(found + 1));
+                        }
+                    }
+                }
+            }
+        },
+            service, path, "org.freedesktop.DBus.Properties", "GetAll", inf);
+    }
+    else
+    {
+        messages::internalError(asyncResp->res);
+        return;
+    }
+}
+
+inline void requestRoutesPhysicalDrive(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/"
+                      "<str>"
+                      "/Drives/"
+                      "<str>")
+        .privileges(redfish::privileges::getStorage)
+        .methods(boost::beast::http::verb::get)(
+            [](const crow::Request&,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& name, const std::string& driveName) {
+        //            if (!redfish::utils::checkLicenseStatus(asyncResp, name))
+        //            {
+        //                return;
+        //            }
+        asyncResp->res.jsonValue["@odata.type"] = "#Drive.v1_13_0.Drive";
+        asyncResp->res.jsonValue["@odata.id"] =
+            "/redfish/v1/Systems/system/Storage/" + name + "/Drives/" +
+            driveName;
+
+        asyncResp->res.jsonValue["Oem"]["OpenBmc"]["@odata.type"] =
+            "#OemDrive.v1_0_0.Drive";
+        std::size_t type = name.find("_");
+        if (type != std::string::npos)
+        {
+            const char* service;
+            const char* interface;
+            const std::string& pdPath =
+                "/xyz/openbmc_project/" + name.substr(0, type) + "/" +
+                name.substr(type + 1) + "/pd/" + driveName;
+
+            if (name.substr(0, type) == "Raid")
+            {
+                service = "xyz.openbmc_project.raid.manager";
+                interface = "xyz.openbmc_project.raid.PhysicalDrive";
+                nlohmann::json& storageControllerArray =
+                    asyncResp->res.jsonValue["Links"]["Volumes"];
+                storageControllerArray = nlohmann::json::array();
+                nlohmann::json& count =
+                    asyncResp->res.jsonValue["Links"]["Volumes@odata.count"];
+                getLogicalDrives(asyncResp, name.substr(type + 1),
+                                 storageControllerArray, count);
+            }
+            else if (name.substr(0, type) == "HBA")
+            {
+                service = "xyz.openbmc_project.hba.manager";
+                interface = "xyz.openbmc_project.hba.PhysicalDrive";
+            }
+            else
+            {
+                messages::internalError(asyncResp->res);
+                return;
+            }
+            crow::connections::systemBus->async_method_call(
+                [asyncResp](
+                    const boost::system::error_code ec2,
+                    const std::vector<std::pair<
+                        std::string, std::variant<std::string, uint32_t,
+                                                  uint16_t, double, uint8_t>>>&
+                        propertiesList) {
+                if (ec2)
+                {
+                    messages::internalError(asyncResp->res);
+                    return;
+                }
+                for (const std::pair<std::string,
+                                     std::variant<std::string, uint32_t,
+                                                  uint16_t, double, uint8_t>>&
+                         property : propertiesList)
+                {
+                    const std::string& propertyName = property.first;
+
+                    if (propertyName == "NegotiatedSpeedGbs")
+                    {
+                        const double* value =
+                            std::get_if<double>(&property.second);
+                        if (value != nullptr)
+                        {
+                            asyncResp->res.jsonValue[propertyName] = *value;
+                        }
+                    }
+                    if (propertyName == "SlotNumber")
+                    {
+                        const uint8_t* value =
+                            std::get_if<uint8_t>(&property.second);
+                        if (value != nullptr)
+                        {
+                            asyncResp->res.jsonValue["Oem"]["OpenBmc"]
+                                                    [propertyName] = *value;
+                        }
+                    }
+                    if (propertyName == "Id")
+                    {
+                        const uint16_t* value =
+                            std::get_if<uint16_t>(&property.second);
+                        if (value != nullptr)
+                        {
+                            asyncResp->res.jsonValue[propertyName] =
+                                std::to_string(*value);
+                            asyncResp->res.jsonValue["Name"] =
+                                "PhysicalDisk_" + (std::to_string(*value));
+                        }
+                    }
+
+                    if ((propertyName == "BlockSizeBytes") ||
+                        (propertyName == "FailurePredicted"))
+                    {
+                        const uint32_t* value =
+                            std::get_if<uint32_t>(&property.second);
+                        if (value != nullptr)
+                        {
+                            asyncResp->res.jsonValue[propertyName] = *value;
+                        }
+                    }
+                    if ((propertyName == "Manufacturer") ||
+                        (propertyName == "Protocol") ||
+                        (propertyName == "Revision") ||
+                        (propertyName == "SerialNumber") ||
+                        (propertyName == "ProductID"))
+                    {
+                        const std::string* value =
+                            std::get_if<std::string>(&property.second);
+                        if (value != nullptr)
+                        {
+                            if (propertyName == "ProductID")
+                                asyncResp->res.jsonValue["Oem"]["OpenBmc"]
+                                                        [propertyName] = *value;
+                            else
+                                asyncResp->res.jsonValue[propertyName] = *value;
+                        }
+                    }
+                    if (propertyName == "Health")
+                    {
+                        const std::string* value =
+                            std::get_if<std::string>(&property.second);
+                        if (*value == "ok")
+                            asyncResp->res.jsonValue["Status"][propertyName] =
+                                *value;
+                        else
+                            asyncResp->res.jsonValue["Status"][propertyName] =
+                                *value;
+                    }
+                }
+            },
+                service, pdPath, "org.freedesktop.DBus.Properties", "GetAll",
+                interface);
+        }
+        else
+        {
+            messages::actionParameterUnknown(asyncResp->res, "Raid/HBA", name);
+
+            return;
+        }
+    });
+}
+
+} // namespace redfish
-- 
2.34.1

