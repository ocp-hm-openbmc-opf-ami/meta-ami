From 6b5e979b5738c249ef1c9af7b58b48885ba78118 Mon Sep 17 00:00:00 2001
From: Pranoy Goru <gorumanip@ami.com>
Date: Thu, 25 Jan 2024 00:01:27 +0530
Subject: [PATCH] Integrated RAID Interface in Redfish

Description
Added RAID, HBA and MSCC Interface in Redfish

$ busctl tree xyz.openbmc_project.hba.manager
`-/xyz
  `-/xyz/openbmc_project
    `-/xyz/openbmc_project/HBA
      `-/xyz/openbmc_project/HBA/0
        `-/xyz/openbmc_project/HBA/0/pd
          |-/xyz/openbmc_project/HBA/0/pd/0
          `-/xyz/openbmc_project/HBA/0/pd/1
--------------------------------------------------------------------------------------------
BRCM RAID
---------------------------------------------------------------------------------------
$ busctl tree xyz.openbmc_project.raid.manager
`-/xyz
  `-/xyz/openbmc_project
    `-/xyz/openbmc_project/Raid
      `-/xyz/openbmc_project/Raid/0
        |-/xyz/openbmc_project/Raid/0/ld
        | `-/xyz/openbmc_project/Raid/0/ld/0
        `-/xyz/openbmc_project/Raid/0/pd
          |-/xyz/openbmc_project/Raid/0/pd/0
          `-/xyz/openbmc_project/Raid/0/pd/1
------------------------------------------------------------------------------------------------------
$ busctl introspect xyz.openbmc_project.raid.manager /xyz/openbmc_project/Raid/0

NAME                                TYPE      SIGNATURE RESULT/VALUE                             FLAGS
org.freedesktop.DBus.Introspectable interface -         -                                        -
.Introspect                         method    -         s                                        -
org.freedesktop.DBus.Peer           interface -         -                                        -
.GetMachineId                       method    -         s                                        -
.Ping                               method    -         -                                        -
org.freedesktop.DBus.Properties     interface -         -                                        -
.Get                                method    ss        v                                        -
.GetAll                             method    s         a{sv}                                    -
.Set                                method    ssv       -                                        -
.PropertiesChanged                  signal    sa{sv}as  -                                        -
xyz.openbmc_project.raid.Controller interface -         -                                        -
.FirmwareVersion                    property  s         "5.110.00-2706"                          emits-change
.Health                             property  s         "OK"                                     emits-change
.Id                                 property  u         324                                      emits-change
.Model                              property  s         "AVAGO MegaRAID SAS 9460-16i"            emits-change
.SerialNumber                       property  s         "SPC4408997"                             emits-change
.SupportedRaidLevel                 property  as        8 "RAID0" "RAID1" "RAID5" "RAID6" "RA... emits-change
.SupportedStripSize                 property  at        5 65536 131072 262144 524288 1048576     emits-change
---------------------------------------------------------------------------------------------------
$ busctl introspect xyz.openbmc_project.raid.manager /xyz/openbmc_project/Raid/0/ld

NAME                                TYPE      SIGNATURE RESULT/VALUE FLAGS
org.freedesktop.DBus.Introspectable interface -         -            -
.Introspect                         method    -         s            -
org.freedesktop.DBus.Peer           interface -         -            -
.GetMachineId                       method    -         s            -
.Ping                               method    -         -            -
org.freedesktop.DBus.Properties     interface -         -            -
.Get                                method    ss        v            -
.GetAll                             method    s         a{sv}        -
.Set                                method    ssv       -            -
.PropertiesChanged                  signal    sa{sv}as  -            -
xyz.openbmc_project.raid.LD         interface -         -            -
.Count                              property  u         1            emits-change
------------------------------------------------------------------------------------------------
$ busctl introspect xyz.openbmc_project.raid.manager /xyz/openbmc_project/Raid/0/ld/0

NAME                                  TYPE      SIGNATURE RESULT/VALUE   FLAGS
org.freedesktop.DBus.Introspectable   interface -         -              -
.Introspect                           method    -         s              -
org.freedesktop.DBus.Peer             interface -         -              -
.GetMachineId                         method    -         s              -
.Ping                                 method    -         -              -
org.freedesktop.DBus.Properties       interface -         -              -
.Get                                  method    ss        v              -
.GetAll                               method    s         a{sv}          -
.Set                                  method    ssv       -              -
.PropertiesChanged                    signal    sa{sv}as  -              -
xyz.openbmc_project.raid.LogicalDrive interface -         -              -
.CapacityBytes                        property  t         3999688294400  emits-change
.Health                               property  s         "OK"           emits-change
.Id                                   property  q         0              emits-change
.Name                                 property  s         "AMIRaid5"     emits-change
.PdList                               property  aq        2 3 4          emits-change
.RaidLevel                            property  s         "RAID0"        emits-change
.ReadCachePolicyType                  property  s         "NoReadAhead"  emits-change
.StripSizeBytes                       property  t         262144         emits-change
.WriteCachePolicyType                 property  s         "WriteThrough" emits-change
-----------------------------------------------------------------------------------------------
$ busctl introspect xyz.openbmc_project.raid.manager /xyz/openbmc_project/Raid/0/pd/0

NAME                                   TYPE      SIGNATURE RESULT/VALUE       FLAGS
org.freedesktop.DBus.Introspectable    interface -         -                  -
.Introspect                            method    -         s                  -
org.freedesktop.DBus.Peer              interface -         -                  -
.GetMachineId                          method    -         s                  -
.Ping                                  method    -         -                  -
org.freedesktop.DBus.Properties        interface -         -                  -
.Get                                   method    ss        v                  -
.GetAll                                method    s         a{sv}              -
.Set                                   method    ssv       -                  -
.PropertiesChanged                     signal    sa{sv}as  -                  -
xyz.openbmc_project.raid.PhysicalDrive interface -         -                  -
.BlockSizeBytes                        property  t         512                emits-change
.FailurePredicted                      property  u         0                  emits-change
.Health                                property  s         "OK"               emits-change
.Id                                    property  q         3                  emits-change
.InterfaceType                         property  s         "SATA"             emits-change
.LinkSpeed                             property  s         "6_0Gbps"          emits-change
.Manufacturer                          property  s         "ATA"              emits-change
.ProductId                             property  s         "ST3000NM0033-9ZM" emits-change
.Revision                              property  s         "SN03"             emits-change
.SerialNumber                          property  s         "Z1Y09GQF"         emits-change
.Slot                                  property  s         "2"                emits-change
--------------------------------------------------------------------------------------------
MSCC
-----------------------------------------------------------------------------------------------
$ busctl tree com.ami.storage
`-/com
  `-/com/ami
    `-/com/ami/storage
      `-/com/ami/storage/mscc
        `-/com/ami/storage/mscc/ctrl
          |-/com/ami/storage/mscc/ctrl/0
          | |-/com/ami/storage/mscc/ctrl/0/ld
          | | |-/com/ami/storage/mscc/ctrl/0/ld/0
          | | `-/com/ami/storage/mscc/ctrl/0/ld/1
          | `-/com/ami/storage/mscc/ctrl/0/pd
          |   |-/com/ami/storage/mscc/ctrl/0/pd/16
          |   |-/com/ami/storage/mscc/ctrl/0/pd/17
          |   |-/com/ami/storage/mscc/ctrl/0/pd/18
          |   |-/com/ami/storage/mscc/ctrl/0/pd/19
          |   |-/com/ami/storage/mscc/ctrl/0/pd/20
          |   |-/com/ami/storage/mscc/ctrl/0/pd/21
          |   |-/com/ami/storage/mscc/ctrl/0/pd/22
          |   `-/com/ami/storage/mscc/ctrl/0/pd/23
          `-/com/ami/storage/mscc/ctrl/1
-------------------------------------------------------------------
$ busctl introspect com.ami.storage /com/ami/storage/mscc/ctrl/0

NAME                                    TYPE      SIGNATURE RESULT/VALUE                             FLAGS
com.ami.storage.mscc.ctrl.Configuration interface -         -                                        -
.CreateLogicalDrive                     method    ssqaqttys -                                        -
.DeleteLogicalDrive                     method    q         -                                        -
com.ami.storage.mscc.ctrl.Controller    interface -         -                                        -
.CacheSize                              property  q         3856                                     emits-change
.DriverVersion                          property  s         ""                                       emits-change
.FirmwareVersion                        property  s         "5.32"                                   emits-change
.HardwareRevision                       property  s         "A"                                      emits-change
.Id                                     property  u         0                                        emits-change
.Manufacturer                           property  s         "Adaptec"                                emits-change
.MemorySize                             property  q         4096                                     emits-change
.Mode                                   property  s         "com.ami.storage.mscc.ctrl.Controller... emits-change
.Model                                  property  s         "3154-24i"                               emits-change
.PCI                                    property  a(qq)     2 36869 655 36869 4608                   emits-change
.SerialNumber                           property  s         "8A476331267"                            emits-change
.SupportedMaxLdCount                    property  q         64                                       emits-change
.SupportedMaxPdCount                    property  q         384                                      emits-change
.SupportedMaxPdPerLdCount               property  q         128                                      emits-change
.Temperature                            property  y         51                                       emits-change
.WWN                                    property  s         "50000D1704F5CF80"                       emits-change
org.freedesktop.DBus.Introspectable     interface -         -                                        -
.Introspect                             method    -         s                                        -
org.freedesktop.DBus.Peer               interface -         -                                        -
.GetMachineId                           method    -         s                                        -
.Ping                                   method    -         -                                        -
org.freedesktop.DBus.Properties         interface -         -                                        -
.Get                                    method    ss        v                                        -
.GetAll                                 method    s         a{sv}                                    -
.Set                                    method    ssv       -                                        -
.PropertiesChanged                      signal    sa{sv}as  -                                        -
---------------------------------------------------------------------------------------
$ busctl introspect com.ami.storage /com/ami/storage/mscc/ctrl/0/ld/1

NAME                                   TYPE      SIGNATURE RESULT/VALUE                             FLAGS
com.ami.storage.mscc.ctrl.LogicalDrive interface -         -                                        -
.AcceleratorType                       property  s         "com.ami.storage.mscc.ctrl.LogicalDri... emits-change
.ArrayNumber                           property  q         0                                        emits-change
.CacheLineSize                         property  s         "com.ami.storage.mscc.ctrl.LogicalDri... emits-change
.CapacityBytes                         property  t         534773760                                emits-change
.DataPdList                            property  aq        3 19 20 21                               emits-change
.Id                                    property  q         1                                        emits-change
.LdType                                property  s         "com.ami.storage.mscc.ctrl.LogicalDri... emits-change
.LuCacheAlgorithm                      property  s         "com.ami.storage.mscc.ctrl.LogicalDri... emits-change
.LuCacheInfoActualWritePolicy          property  s         "com.ami.storage.mscc.ctrl.LogicalDri... emits-change
.LuCacheInfoRequestedWritePolicy       property  s         "com.ami.storage.mscc.ctrl.LogicalDri... emits-change
.Name                                  property  s         "RAID TEST 9"                            emits-change
.Progress                              property  y         0                                        emits-change
.RaidLevel                             property  s         "com.ami.storage.mscc.ctrl.LogicalDri... emits-change
.SparePdList                           property  aq        0                                        emits-change
.StatusInfo                            property  s         "com.ami.storage.mscc.ctrl.LogicalDri... emits-change
.StripSizeBytes                        property  t         262144                                   emits-change
org.freedesktop.DBus.Introspectable    interface -         -                                        -
.Introspect                            method    -         s                                        -
org.freedesktop.DBus.Peer              interface -         -                                        -
.GetMachineId                          method    -         s                                        -
.Ping                                  method    -         -                                        -
org.freedesktop.DBus.Properties        interface -         -                                        -
.Get                                   method    ss        v                                        -
.GetAll                                method    s         a{sv}                                    -
.Set                                   method    ssv       -                                        -
.PropertiesChanged                     signal    sa{sv}as  -                                        -
-------------------------------------------------------------------------------------------------------------
$ busctl introspect com.ami.storage /com/ami/storage/mscc/ctrl/0/pd/16

NAME                                    TYPE      SIGNATURE RESULT/VALUE                             FLAGS
com.ami.storage.mscc.ctrl.PhysicalDrive interface -         -                                        -
.ArrayNumber                            property  q         65535                                    emits-change
.BlockCount                             property  t         488397168                                emits-change
.BlockSizeBytes                         property  t         512                                      emits-change
.BootPriority                           property  y         0                                        emits-change
.Flag                                   property  t         18859373195635739                        emits-change
.Id                                     property  q         16                                       emits-change
.InterfaceType                          property  s         "com.ami.storage.mscc.ctrl.PhysicalDr... emits-change
.LinkSpeed                              property  s         "com.ami.storage.mscc.ctrl.PhysicalDr... emits-change
.Manufacturer                           property  s         "ATA     "                               emits-change
.MaxLinkSpeed                           property  s         "com.ami.storage.mscc.ctrl.PhysicalDr... emits-change
.Model                                  property  s         "ATA     ST250DM000-1BD141"              emits-change
.PdType                                 property  s         "com.ami.storage.mscc.ctrl.PhysicalDr... emits-change
.Present                                property  b         true                                     emits-change
.ProductId                              property  s         "ST250DM000-1BD141"                      emits-change
.Revision                               property  s         "KC45"                                   emits-change
.RotationalSpeed                        property  u         7200                                     emits-change
.SerialNumber                           property  s         "Z3TNF3RK"                               emits-change
.Slot                                   property  s         "CN4:1:16"                               emits-change
.StatusInfo                             property  (ss)      "com.ami.storage.mscc.ctrl.PhysicalDr... emits-change
.Temperature                            property  y         40                                       emits-change
.UID                                    property  s         "6D06B3FE33196337"                       emits-change
.UsableBlockCount                       property  t         488331632                                emits-change
.Usage                                  property  s         "com.ami.storage.mscc.ctrl.PhysicalDr... emits-change
com.ami.storage.mscc.ctrl.SmartInfo     interface -         -                                        -
.Attritubes                             property  aay       1 14 0 0 0 0 0 0 0 0 0 0 0 0 0 0         emits-change
.Thresholds                             property  aay       22 12 0 0 0 0 0 0 0 0 0 0 0 0 12 1 6 ... emits-change
org.freedesktop.DBus.Introspectable     interface -         -                                        -
.Introspect                             method    -         s                                        -
org.freedesktop.DBus.Peer               interface -         -                                        -
.GetMachineId                           method    -         s                                        -
.Ping                                   method    -         -                                        -
org.freedesktop.DBus.Properties         interface -         -                                        -
.Get                                    method    ss        v                                        -
.GetAll                                 method    s         a{sv}                                    -
.Set                                    method    ssv       -                                        -
.PropertiesChanged                      signal    sa{sv}as  -                                        -
--------------------------------------------------------------------------------------------------------------------------
Test case:

1) Get RAID and HBA Device count

https://localhost:2443/redfish/v1/Systems/system/Storage
{
    "@odata.id": "/redfish/v1/Systems/system/Storage",
    "@odata.type": "#StorageCollection.StorageCollection",
    "Members": [
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/mscc_0"
        },
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_0"
        },
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_1"
        },
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/HBA_0"
        }
    ],
    "Members@odata.count": 4,
    "Name": "Storage Collection"
}

2) Get RAID instance

https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Raid_0
{
    "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_0",
    "@odata.type": "#Storage.v1_10_1.Storage",
    "Actions": {
        "Oem": {
            "#StorageCollection.CreateDrive": {
                "target": "/redfish/v1/Systems/system/Storage/Raid_0/Actions/StorageLDrive.Create"
            },
            "#StorageCollection.DeleteDrive": {
                "target": "/redfish/v1/Systems/system/Storage/Raid_0/Actions/StorageLDrive.Delete"
            }
        }
    },
    "Description": "Integrated Raid Controller",
    "Drives": [
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_0/Drives/0"
        },
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_0/Drives/1"
        }
    ],
    "Drives@odata.count": 2,
    "Id": "Raid_0",
    "Name": "Local Storage Controller",
    "Oem": {
        "OpenBmc": {
            "@odata.type": "#OemStorage.v1_0_0.OemStorage",
            "configComplete": 0,
            "manageRAIDConfigStatus": 0,
            "setRAIDDeleteLDStatus": 0
        }
    },
    "Status": {
        "Health": "OK",
        "State": "Enabled"
    },
    "StorageControllers": [
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_0#/StorageControllers/0",
            "FirmwareVersion": "5.110.00-2706",
            "MemberId": "0",
            "Model": "AVAGO MegaRAID SAS 9460-16i",
            "Name": "Local Storage Controller",
            "SerialNumber": "SPC4408997",
            "SupportedRAIDTypes": [
                "RAID0",
                "RAID1",
                "RAID5",
                "RAID6",
                "RAID00",
                "RAID10",
                "RAID50",
                "RAID60"
            ]
        }
    ],
    "Volumes": {
        "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_0/Volumes"
    }
}

3) Get Logical Drive Count

https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Raid_0/Volumes
{
    "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_0/Volumes",
    "@odata.type": "#VolumeCollection.VolumeCollection",
    "Description": "The Collection of Volumes",
    "Members": [
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_0/Volumes/0"
        }
    ],
    "Members@odata.count": 1,
    "Name": "Volume Collection"
}

4) Get Logical Drive instance

https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Raid_0/Volumes/0
{
    "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_0/Volumes/0",
    "@odata.type": "#Volume.v1_6_2.Volume",
    "CapacityBytes": 3999688294400,
    "Id": "0",
    "Links": {
        "Drives": [
            {
                "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_0/Drives/0"
            },
            {
                "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_0/Drives/1"
            }
        ],
        "Drives@odata.count": 2
    },
    "Name": "LogicalDrive_0",
    "Oem": {
        "OpenBmc": {
            "@odata.type": "#OemVolume.v1_0_0.Volume",
            "LDeviceId": 0,
            "PdList": [
                3,
                4
            ]
        }
    },
    "RAIDType": "RAID0",
    "ReadCachePolicy": "NoReadAhead",
    "Status": {
        "Health": "OK",
        "State": "Enabled"
    },
    "StripSizeBytes": 262144,
    "WriteCachePolicy": "WriteThrough"
}
5) Get Physical Drive instance

https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Raid_0/Drives/0
{
    "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_0/Drives/0",
    "@odata.type": "#Drive.v1_13_0.Drive",
    "BlockSizeBytes": 512,
    "FailurePredicted": false,
    "Id": "0",
    "Links": {
        "Storage": {
            "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_0"
        },
        "Volumes": [
            {
                "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_0/Volumes/0"
            }
        ],
        "Volumes@odata.count": 1
    },
    "Manufacturer": "ATA",
    "Name": "PhysicalDrive_0",
    "NegotiatedSpeedGbs": 60,
    "Oem": {
        "OpenBmc": {
            "@odata.id": "/redfish/v1/Systems/system/Storage/Raid_0/Drives/0#/Oem/OpenBmc",
            "@odata.type": "#OemDrive.v1_0_0.Drive",
            "PDeviceId": 3,
            "ProductId": "ST3000NM0033-9ZM",
            "Slot": "2"
        }
    },
    "Protocol": "SATA",
    "Revision": "SN03",
    "SerialNumber": "Z1Y09GQF",
    "Status": {
        "Health": "OK",
        "State": "Enabled"
    }
}

6) Get HBA instance

https://localhost:2443/redfish/v1/Systems/system/Storage/HBA_0
{
    "@odata.id": "/redfish/v1/Systems/system/Storage/HBA_0",
    "@odata.type": "#Storage.v1_10_1.Storage",
    "Description": "Integrated HBA Controller",
    "Drives": [
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/HBA_0/Drives/0"
        },
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/HBA_0/Drives/1"
        }
    ],
    "Drives@odata.count": 2,
    "Id": "HBA_0",
    "Name": "Local Storage Controller",
    "Oem": {
        "OpenBmc": {
            "@odata.type": "#OemStorage.v1_0_0.OemStorage"
        }
    },
    "Status": {
        "Health": "OK",
        "State": "Enabled"
    },
    "StorageControllers": [
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/HBA_0#/StorageControllers/0",
            "FirmwareVersion": "22.00.00.00",
            "MemberId": "0",
            "Model": "HBA 9400-16i",
            "Name": "Local Storage Controller",
            "SerialNumber": "SP00534324"
        }
    ]
}

5) Get Logical HBA Drive instance
https://localhost:2443/redfish/v1/Systems/system/Storage/Raid_1/Drives/0
{
    "@odata.id": "/redfish/v1/Systems/system/Storage/HBA_0/Drives/0",
    "@odata.type": "#Drive.v1_13_0.Drive",
    "BlockSizeBytes": 512,
    "Id": "0",
    "Manufacturer": "ATA",
    "Name": "PhysicalDrive_0",
    "NegotiatedSpeedGbs": 60,
    "Oem": {
        "OpenBmc": {
            "@odata.id": "/redfish/v1/Systems/system/Storage/HBA_0/Drives/0#/Oem/OpenBmc",
            "@odata.type": "#OemDrive.v1_0_0.Drive",
            "PDeviceId": 1,
            "ProductId": "ST1000NM0033-9ZM",
            "Slot": "0"
        }
    },
    "Protocol": "SATA",
    "Revision": "SN03",
    "SerialNumber": "Z1W018YB",
    "Status": {
        "Health": "OK",
        "State": "Enabled"
    }
}

6) Create Logical Drive for BRCM RAID

POST Call
https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Raid_0/Actions/StorageLDrive.Create

Sample Json Body
{
    "CmdParm": 1,
    "Prl": 0,
    "StripeSize": 9,
    "InitState": 0,
    "DiskCachePolicy": 0,
    "SizeLow": 0,
    "SizeHigh": 0,
    "Readpolicy": 0,
    "Writepolicy": 0,
    "Iopolicy": 0,
    "Accesspolicy": 0,
    "SpanDepth": 1,
    "NumDrives": 2,
    "Accelerator": 0,
    "ParityGroupCount": 0,
    "ArrayNumber": 0,
    "VDName": [
        65,
        77,
        73,
        82,
        97,
        105,
        100,
        53
    ],
    "SpanID": [
        0,
        0
    ],
    "DeviceID": [
        3,
        4
    ]
}

Response
202

{
    "@odata.id": "/redfish/v1/TaskService/Tasks/1",
    "@odata.type": "#Task.v1_4_3.Task",
    "Id": "1",
    "TaskState": "New",
    "TaskStatus": "OK"
}

Get Call
https://{{BMCIP}}/redfish/v1/TaskService/Tasks/1

Response
{
    "@odata.id": "/redfish/v1/TaskService/Tasks/1",
    "@odata.type": "#Task.v1_4_3.Task",
    "EndTime": "2023-11-23T18:13:11+00:00",
    "HidePayload": false,
    "Id": "1",
    "Messages": [
        {
            "@odata.type": "#Message.v1_1_1.Message",
            "Message": "The task with Id '1' has started.",
            "MessageArgs": [
                "1"
            ],
            "MessageId": "TaskEvent.1.0.3.TaskStarted",
            "MessageSeverity": "OK",
            "Resolution": "None."
        },
        {
            "@odata.type": "#Message.v1_1_1.Message",
            "Message": "The task with Id '1' has completed.",
            "MessageArgs": [
                "1"
            ],
            "MessageId": "TaskEvent.1.0.3.TaskCompletedOK",
            "MessageSeverity": "OK",
            "Resolution": "None."
        }
    ],
    "Name": "Task 1",
    "Payload": {
        "HttpHeaders": [
            "User-Agent: PostmanRuntime/7.35.0",
            "Accept: */*",
            "Host: 172.31.32.58",
            "Accept-Encoding: gzip, deflate, br",
            "Connection: keep-alive",
            "Content-Length: 579"
        ],
        "HttpOperation": "POST",
        "JsonBody": "{\n  \"Accelerator\": 0,\n  \"Accesspolicy\": 0,\n  \"ArrayNumber\": 0,\n  \"CmdParm\": 1,\n  \"DeviceID\": [\n    3,\n    4\n  ],\n  \"DiskCachePolicy\": 0,\n  \"InitState\": 0,\n  \"Iopolicy\": 0,\n  \"NumDrives\": 2,\n  \"ParityGroupCount\": 0,\n  \"Prl\": 0,\n  \"Readpolicy\": 0,\n  \"SizeHigh\": 0,\n  \"SizeLow\": 0,\n  \"SpanDepth\": 1,\n  \"SpanID\": [\n    0,\n    0\n  ],\n  \"StripeSize\": 9,\n  \"VDName\": [\n    65,\n    77,\n    73,\n    82,\n    97,\n    105,\n    100,\n    53\n  ],\n  \"Writepolicy\": 0\n}",
        "TargetUri": "/redfish/v1/Systems/system/Storage/Raid_0/Actions/StorageLDrive.Create"
    },
    "PercentComplete": 100,
    "StartTime": "2023-11-23T18:13:05+00:00",
    "TaskMonitor": "/redfish/v1/TaskService/Tasks/1/Monitor",
    "TaskState": "SUCCESS",
    "TaskStatus": "OK"
}

7) Delete Logical drive BRCM RAID

Post https://{{BMCIP}}/redfish/v1/Systems/system/Storage/Raid_0/Actions/StorageLDrive.Delete

Body

{
    "LDriveId": "0"
}

Respose 202

{
    "@odata.id": "/redfish/v1/TaskService/Tasks/7",
    "@odata.type": "#Task.v1_4_3.Task",
    "Id": "5",
    "TaskState": "New",
    "TaskStatus": "OK"
}

Get https://{{BMCIP}}/redfish/v1/TaskService/Tasks/7

{
    "@odata.id": "/redfish/v1/TaskService/Tasks/7",
    "@odata.type": "#Task.v1_4_3.Task",
    "EndTime": "2023-10-30T19:04:02+00:00",
    "HidePayload": false,
    "Id": "7",
    "Messages": [
        {
            "@odata.type": "#Message.v1_1_1.Message",
            "Message": "The task with Id '7' has started.",
            "MessageArgs": [
                "7"
            ],
            "MessageId": "TaskEvent.1.0.3.TaskStarted",
            "MessageSeverity": "OK",
            "Resolution": "None."
        },
        {
            "@odata.type": "#Message.v1_1_1.Message",
            "Message": "The task with Id '7' has completed.",
            "MessageArgs": [
                "7"
            ],
            "MessageId": "TaskEvent.1.0.3.TaskCompletedOK",
            "MessageSeverity": "OK",
            "Resolution": "None."
        }
    ],
    "Name": "Task 7",
    "Payload": {
        "HttpHeaders": [
            "User-Agent: PostmanRuntime/7.34.0",
            "Accept: */*",
            "Host: 172.31.32.52",
            "Accept-Encoding: gzip, deflate, br",
            "Connection: keep-alive",
            "Content-Length: 25"
        ],
        "HttpOperation": "POST",
        "JsonBody": "{\n  \"LDriveId\": \"0\"\n}",
        "TargetUri": "/redfish/v1/Systems/system/Storage/Raid_0/Actions/StorageLDrive.Delete"
    },
    "PercentComplete": 100,
    "StartTime": "2023-10-30T19:03:56+00:00",
    "TaskMonitor": "/redfish/v1/TaskService/Tasks/7/Monitor",
    "TaskState": "SUCCESS",
    "TaskStatus": "OK"
}

8) Get Storage Instance for MSCC

https://{{BMCIP}}/redfish/v1/Systems/system/Storage/mscc_0
{
    "@odata.id": "/redfish/v1/Systems/system/Storage/mscc_1",
    "@odata.type": "#Storage.v1_10_1.Storage",
    "Actions": {
        "Oem": {
            "#StorageCollection.CreateDrive": {
                "target": "/redfish/v1/Systems/system/Storage/mscc_1/Actions/StorageMSCCLDrive.Create"
            },
            "#StorageCollection.DeleteDrive": {
                "target": "/redfish/v1/Systems/system/Storage/mscc_1/Actions/StorageMSCCLDrive.Delete"
            }
        }
    },
    "Description": "Integrated mscc Controller",
    "Drives": [
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/mscc_1/Drives/16"
        },
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/mscc_1/Drives/17"
        },
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/mscc_1/Drives/18"
        },
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/mscc_1/Drives/19"
        },
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/mscc_1/Drives/20"
        },
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/mscc_1/Drives/21"
        },
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/mscc_1/Drives/22"
        },
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/mscc_1/Drives/23"
        }
    ],
    "Drives@odata.count": 8,
    "Id": "mscc_1",
    "Name": "Local Storage Controller",
    "Oem": {
        "OpenBmc": {
            "@odata.type": "#OemStorage.v1_0_0.OemStorage"
        }
    },
    "StorageControllers": [
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/mscc_1#/StorageControllers/0",
            "FirmwareVersion": "5.32",
            "MemberId": "0",
            "Model": "3154-24i",
            "Name": "Local Storage Controller",
            "SerialNumber": "8A476331267"
        }
    ],
    "Volumes": {
        "@odata.id": "/redfish/v1/Systems/system/Storage/mscc_1/Volumes"
    }
}

9)Get Logical Drive count

https://{{BMCIP}}/redfish/v1/Systems/system/Storage/mscc_0/Volumes
{
    "@odata.id": "/redfish/v1/Systems/system/Storage/mscc_1/Volumes",
    "@odata.type": "#VolumeCollection.VolumeCollection",
    "Description": "The Collection of Volumes",
    "Members": [
        {
            "@odata.id": "/redfish/v1/Systems/system/Storage/mscc_1/Volumes/0"
        }
    ],
    "Members@odata.count": 1,
    "Name": "Volume Collection"
}

10)Get Logical Drive Instance

https://{{BMCIP}}/redfish/v1/Systems/system/Storage/mscc_0/Volumes/0
{
    "@odata.id": "/redfish/v1/Systems/system/Storage/mscc_1/Volumes/0",
    "@odata.type": "#Volume.v1_6_2.Volume",
    "CapacityBytes": 534773760,
    "Id": "0",
    "Links": {
        "Drives": [
            {
                "@odata.id": "/redfish/v1/Systems/system/Storage/mscc_1/Drives/16"
            },
            {
                "@odata.id": "/redfish/v1/Systems/system/Storage/mscc_1/Drives/17"
            },
            {
                "@odata.id": "/redfish/v1/Systems/system/Storage/mscc_1/Drives/18"
            },
            {
                "@odata.id": "/redfish/v1/Systems/system/Storage/mscc_1/Drives/19"
            },
            {
                "@odata.id": "/redfish/v1/Systems/system/Storage/mscc_1/Drives/20"
            },
            {
                "@odata.id": "/redfish/v1/Systems/system/Storage/mscc_1/Drives/21"
            },
            {
                "@odata.id": "/redfish/v1/Systems/system/Storage/mscc_1/Drives/22"
            },
            {
                "@odata.id": "/redfish/v1/Systems/system/Storage/mscc_1/Drives/23"
            }
        ],
        "Drives@odata.count": 8
    },
    "Name": "LogicalDrive_0",
    "Oem": {
        "OpenBmc": {
            "@odata.type": "#OemVolume.v1_0_0.Volume",
            "LDeviceId": 0,
            "PdList": [
                19,
                20,
                21
            ],
            "SparePdList": []
        }
    },
    "RAIDType": "RAID5",
    "StripSizeBytes": 262144
}

11)Get Physical Drive Instance

https://{{BMCIP}}/redfish/v1/Systems/system/Storage/mscc_0/Drives/16
{
    "@odata.id": "/redfish/v1/Systems/system/Storage/mscc_1/Drives/16",
    "@odata.type": "#Drive.v1_13_0.Drive",
    "BlockSizeBytes": 512,
    "Id": "16",
    "Links": {
        "Storage": {
            "@odata.id": "/redfish/v1/Systems/system/Storage/mscc_1"
        },
        "Volumes": [
            {
                "@odata.id": "/redfish/v1/Systems/system/Storage/mscc_1/Volumes/0"
            }
        ],
        "Volumes@odata.count": 1
    },
    "Manufacturer": "ATA     ",
    "Name": "PhysicalDrive_16",
    "NegotiatedSpeedGbs": 60,
    "Oem": {
        "OpenBmc": {
            "@odata.id": "/redfish/v1/Systems/system/Storage/mscc_1/Drives/16#/Oem/OpenBmc",
            "@odata.type": "#OemDrive.v1_0_0.Drive",
            "PDeviceId": 16,
            "ProductId": "ST250DM000-1BD141",
            "Slot": "CN4:1:16"
        }
    },
    "Protocol": "SATA",
    "Revision": "KC45",
    "SerialNumber": "Z3TNF3RK"
}

12) Create Logical Drive for MSCC

POST
https://{{BMCIP}}/redfish/v1/Systems/system/Storage/mscc_0/Actions/StorageMSCCLDrive.Create
{
    "LDName": "RAID TEST 9",
    "RaidLevel": "com.ami.storage.mscc.ctrl.LogicalDrive.RaidType.RAID5",
    "ArrayNumber": 65535,
    "PdList": [
        16,
        17,
        18
    ],
    "StripSize": 262144,
    "Size": 536870912,
    "ParityGroupCount": 0,
    "Accelerator": "com.ami.storage.mscc.ctrl.LogicalDrive.LdAccelerator.ControllerCache"
}

response
{
    "@Message.ExtendedInfo": [
        {
            "@odata.type": "#Message.v1_1_1.Message",
            "Message": "The request completed successfully.",
            "MessageArgs": [],
            "MessageId": "Base.1.16.0.Success",
            "MessageSeverity": "OK",
            "Resolution": "None"
        }
    ]
}
13) Delete Logical Drive for MSCC

POST
https://{{BMCIP}}/redfish/v1/Systems/system/Storage/mscc_0/Actions/StorageMSCCLDrive.Delete
{
    "LogicalDriveId": 0
}
Response
{
    "@Message.ExtendedInfo": [
        {
            "@odata.type": "#Message.v1_1_1.Message",
            "Message": "The request completed successfully.",
            "MessageArgs": [],
            "MessageId": "Base.1.16.0.Success",
            "MessageSeverity": "OK",
            "Resolution": "None"
        }
    ]
}

Signed-off-by: Pranoy Goru <gorumanip@ami.com>
---
 redfish-core/include/redfish.hpp              |    8 +
 redfish-core/include/utils/collection.hpp     |    5 +
 redfish-core/lib/raid.hpp                     |   37 +
 redfish-core/lib/storage.hpp                  |   15 +-
 redfish-core/lib/storage_mscc.hpp             |  169 +++
 redfish-core/lib/storage_raid.hpp             | 1272 +++++++++++++++++
 static/redfish/v1/$metadata/index.xml         |    8 +
 .../v1/JsonSchemas/OemDrive/index.json        |    9 +
 .../v1/JsonSchemas/OemStorage/index.json      |   56 +
 .../v1/JsonSchemas/OemVolume/index.json       |   62 +
 static/redfish/v1/schema/OemDrive_v1.xml      |    5 +
 static/redfish/v1/schema/OemStorage_v1.xml    |   61 +
 static/redfish/v1/schema/OemVolume_v1.xml     |   60 +
 13 files changed, 1766 insertions(+), 1 deletion(-)
 create mode 100644 redfish-core/lib/raid.hpp
 create mode 100644 redfish-core/lib/storage_mscc.hpp
 create mode 100644 redfish-core/lib/storage_raid.hpp
 create mode 100644 static/redfish/v1/JsonSchemas/OemStorage/index.json
 create mode 100644 static/redfish/v1/JsonSchemas/OemVolume/index.json
 create mode 100644 static/redfish/v1/schema/OemStorage_v1.xml
 create mode 100644 static/redfish/v1/schema/OemVolume_v1.xml

diff --git a/redfish-core/include/redfish.hpp b/redfish-core/include/redfish.hpp
index be7f406d..580ce0e6 100644
--- a/redfish-core/include/redfish.hpp
+++ b/redfish-core/include/redfish.hpp
@@ -61,6 +61,7 @@
 #include "sensors.hpp"
 #include "service_root.hpp"
 #include "storage.hpp"
+#include "storage_raid.hpp"
 #include "systems.hpp"
 #include "task.hpp"
 #include "telemetry_service.hpp"
@@ -145,6 +146,13 @@ class RedfishService
         requestRoutesNvmeControllersInstance(app);
         requestRoutesNvmePorts(app);
         requestRoutesNvmePortsInstance(app);
+        requestRoutesRaidLogical(app);
+        requestRoutesRaidLogicalDrive(app);
+        requestRoutesPhysicalDrive(app);
+        requestRoutesCreateLogicalDriveAction(app);
+        requestRoutesDeleteLogicalDriveAction(app);
+        requestRoutesMSCCCreateLogicalDriveAction(app);
+        requestRoutesMSCCDeleteLogicalDriveAction(app);
 
         requestRoutesCable(app);
         requestRoutesCableCollection(app);
diff --git a/redfish-core/include/utils/collection.hpp b/redfish-core/include/utils/collection.hpp
index 027714d3..38b9c64e 100644
--- a/redfish-core/include/utils/collection.hpp
+++ b/redfish-core/include/utils/collection.hpp
@@ -5,6 +5,8 @@
 #include "error_messages.hpp"
 #include "http/utility.hpp"
 #include "human_sort.hpp"
+#include "raid.hpp"
+#include "storage_mscc.hpp"
 #include "storage_nvme.hpp"
 
 #include <boost/url/url.hpp>
@@ -76,6 +78,9 @@ inline void handleCollectionMembers(
         nlohmann::json& count = asyncResp->res.jsonValue[jsonCountKeyName];
         nlohmann::json& storageControllerArray = members;
         getNvmeDevices(asyncResp, count, storageControllerArray);
+        getRaidDevices(asyncResp, count, storageControllerArray);
+        getHBADevices(asyncResp, count, storageControllerArray);
+        getMSCCDevices(asyncResp, count, storageControllerArray);
     }
 }
 
diff --git a/redfish-core/lib/raid.hpp b/redfish-core/lib/raid.hpp
new file mode 100644
index 00000000..bb1bbfe8
--- /dev/null
+++ b/redfish-core/lib/raid.hpp
@@ -0,0 +1,37 @@
+#pragma once
+
+#include "health.hpp"
+#include "openbmc_dbus_rest.hpp"
+#include "redfish_util.hpp"
+#include "utils/json_utils.hpp"
+
+#include <app.hpp>
+#include <registries/privilege_registry.hpp>
+
+namespace redfish
+{
+
+void getLogicalDrives(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
+                      const std::string& raidName, nlohmann::json& storageArray,
+                      nlohmann::json& count, int flag,
+                      const std::string& pdPath,
+                      const std::array<const char*, 1> interfaces);
+
+void getPhysicalDrives(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
+                       const std::string& name, nlohmann::json& storageArray,
+                       nlohmann::json& count, int flag,
+                       const std::string& pdPath,
+                       const std::array<const char*, 1> interfaces);
+
+void getRaidDevices(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
+                    nlohmann::json& count,
+                    nlohmann::json& storageControllerArray);
+
+void getHBADevices(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
+                   nlohmann::json& count,
+                   nlohmann::json& storageControllerArray);
+
+void getStorageInstance(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
+                        const std::string& name);
+
+} // namespace redfish
diff --git a/redfish-core/lib/storage.hpp b/redfish-core/lib/storage.hpp
index 0a7a653e..3cb04be0 100644
--- a/redfish-core/lib/storage.hpp
+++ b/redfish-core/lib/storage.hpp
@@ -25,6 +25,7 @@
 #include "human_sort.hpp"
 #include "openbmc_dbus_rest.hpp"
 #include "query.hpp"
+#include "raid.hpp"
 #include "redfish_util.hpp"
 #include "registries/privilege_registry.hpp"
 #include "storage_nvme.hpp"
@@ -177,7 +178,11 @@ inline void afterSystemsStorageGetSubtree(
     });
     if (storage == subtree.end())
     {
-        if ((storageId == "Nvme"))
+        std::size_t raid = storageId.find("Raid_");
+        std::size_t hba = storageId.find("HBA_");
+        std::size_t mscc = storageId.find("mscc_");
+        if ((storageId == "Nvme") || (raid != std::string::npos) ||
+            (hba != std::string::npos) || (mscc != std::string::npos))
         {
             return;
         }
@@ -221,6 +226,14 @@ inline void
     {
         getStorageNvmeInstance(asyncResp);
     }
+    std::size_t raid = storageId.find("Raid_");
+    std::size_t hba = storageId.find("HBA_");
+    std::size_t mscc = storageId.find("mscc_");
+    if ((raid != std::string::npos) || (hba != std::string::npos) ||
+        (mscc != std::string::npos))
+    {
+        getStorageInstance(asyncResp, storageId);
+    }
     if constexpr (bmcwebEnableMultiHost)
     {
         // Option currently returns no systems.  TBD
diff --git a/redfish-core/lib/storage_mscc.hpp b/redfish-core/lib/storage_mscc.hpp
new file mode 100644
index 00000000..071f5c3d
--- /dev/null
+++ b/redfish-core/lib/storage_mscc.hpp
@@ -0,0 +1,169 @@
+/*
+// Copyright (c) 2023 AMI Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+*/
+#include "raid.hpp"
+
+namespace redfish
+{
+
+inline void getMSCCDevices(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
+                           nlohmann::json& count,
+                           nlohmann::json& storageControllerArray)
+{
+    crow::connections::systemBus->async_method_call(
+        [asyncResp, &count,
+         &storageControllerArray](const boost::system::error_code ec,
+                                  const std::vector<std::string>& storageList) {
+        if (ec)
+        {
+            BMCWEB_LOG_ERROR("DBUS error: no matched iface \n");
+            return;
+        }
+        for (const std::string& objpath : storageList)
+        {
+            std::size_t lastPos = objpath.rfind('/');
+            if (lastPos == std::string::npos || (objpath.size() <= lastPos + 1))
+            {
+                BMCWEB_LOG_ERROR("Failed to find '/' in ", objpath);
+                continue;
+            }
+            storageControllerArray.push_back(
+                {{"@odata.id", "/redfish/v1/Systems/system/Storage/mscc_" +
+                                   objpath.substr(lastPos + 1)}});
+        } // object path loop
+        count = storageControllerArray.size();
+    },
+        "xyz.openbmc_project.ObjectMapper",
+        "/xyz/openbmc_project/object_mapper",
+        "xyz.openbmc_project.ObjectMapper", "GetSubTreePaths",
+        "/com/ami/storage/mscc", 0,
+        std::array<const char*, 1>{"com.ami.storage.mscc.ctrl.Controller"});
+}
+
+inline void
+    errorMessageHandler(const sd_bus_error* e,
+                        const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
+{
+    if (e == nullptr)
+    {
+        messages::internalError(asyncResp->res);
+        return;
+    }
+
+    const char* errorMessage = e->name;
+    if (strcmp(errorMessage,
+               "com.ami.storage.Common.Error.DeviceOrResourceBusy") == 0)
+    {
+        messages::resourceInUse(asyncResp->res);
+    }
+    else if (strcmp(errorMessage,
+                    "com.ami.storage.Common.Error.InternalFailure") == 0)
+    {
+        messages::internalError(asyncResp->res);
+    }
+    else if (strcmp(errorMessage,
+                    "com.ami.storage.Common.Error.InvalidArgument") == 0)
+    {
+        messages::actionParameterUnknown(asyncResp->res, "CreateLD", "");
+    }
+    else
+    {
+        messages::internalError(asyncResp->res);
+    }
+}
+
+inline void requestRoutesMSCCCreateLogicalDriveAction(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/"
+                      "<str>/Actions/StorageMSCCLDrive.Create")
+        .privileges(redfish::privileges::postChassis)
+        .methods(boost::beast::http::verb::post)(
+            [](const crow::Request& req,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& id) {
+        std::string ldName;
+        std::string raidLevel;
+        std::uint16_t arrayNumber;
+        std::vector<uint16_t> pdList;
+        std::uint64_t stripSize;
+        std::uint64_t size;
+        std::uint8_t parityGroupCount;
+        std::string accelerator;
+
+        if (!json_util::readJsonAction(
+                req, asyncResp->res, "LDName", ldName, "RaidLevel", raidLevel,
+                "Accelerator", accelerator, "StripSize", stripSize, "Size",
+                size, "ParityGroupCount", parityGroupCount, "PdList", pdList,
+                "ArrayNumber", arrayNumber))
+        {
+            BMCWEB_LOG_DEBUG("Paramaters are not provided");
+            return;
+        }
+
+        const std::string& ldPath = "/com/ami/storage/mscc/ctrl/" +
+                                    id.substr((id.find("_")) + 1);
+
+        crow::connections::systemBus->async_method_call(
+            [asyncResp](const boost::system::error_code& ec,
+                        sdbusplus::message_t& m) {
+            if (ec)
+            {
+                errorMessageHandler(m.get_error(), asyncResp);
+                return;
+            }
+            messages::success(asyncResp->res);
+        },
+            "com.ami.storage", ldPath,
+            "com.ami.storage.mscc.ctrl.Configuration", "CreateLogicalDrive",
+            ldName, raidLevel, arrayNumber, pdList, stripSize, size,
+            parityGroupCount, accelerator);
+    });
+}
+
+inline void requestRoutesMSCCDeleteLogicalDriveAction(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/"
+                      "<str>/Actions/StorageMSCCLDrive.Delete")
+        .privileges(redfish::privileges::postChassis)
+        .methods(boost::beast::http::verb::post)(
+            [](const crow::Request& req,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& id) {
+        std::uint16_t ldID;
+        if (!json_util::readJsonAction(req, asyncResp->res, "LogicalDriveId",
+                                       ldID))
+        {
+            BMCWEB_LOG_DEBUG("Paramaters are not provided");
+            return;
+        }
+        const std::string& ldPath = "/com/ami/storage/mscc/ctrl/" +
+                                    id.substr((id.find("_")) + 1);
+        crow::connections::systemBus->async_method_call(
+            [asyncResp](const boost::system::error_code& ec,
+                        sdbusplus::message_t& m) {
+            if (ec)
+            {
+                errorMessageHandler(m.get_error(), asyncResp);
+                return;
+            }
+            messages::success(asyncResp->res);
+        },
+            "com.ami.storage", ldPath,
+            "com.ami.storage.mscc.ctrl.Configuration", "DeleteLogicalDrive",
+            ldID);
+    });
+}
+
+} // namespace redfish
diff --git a/redfish-core/lib/storage_raid.hpp b/redfish-core/lib/storage_raid.hpp
new file mode 100644
index 00000000..4449d686
--- /dev/null
+++ b/redfish-core/lib/storage_raid.hpp
@@ -0,0 +1,1272 @@
+/*
+// Copyright (c) 2021 AMI Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+*/
+#include "raid.hpp"
+
+#include <task.hpp>
+
+namespace redfish
+{
+
+void getLogicalDrives(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
+                      const std::string& raidName, nlohmann::json& storageArray,
+                      nlohmann::json& count, int flag,
+                      const std::string& ldPath,
+                      const std::array<const char*, 1> interfaces)
+{
+    crow::connections::systemBus->async_method_call(
+        [asyncResp, raidName, &storageArray, &count,
+         flag](const boost::system::error_code ec,
+               const std::vector<std::string>& storageList) {
+        if (ec)
+        {
+            BMCWEB_LOG_ERROR("Volume mapper call error");
+            return;
+        }
+
+        for (const std::string& objpath : storageList)
+        {
+            std::size_t lastPos = objpath.rfind('/');
+            if (lastPos == std::string::npos || (objpath.size() <= lastPos + 1))
+            {
+                BMCWEB_LOG_ERROR("Failed to find '/' in ", objpath);
+                continue;
+            }
+            if (flag == 1)
+                storageArray.push_back(
+                    {{"@odata.id", "/redfish/v1/Systems/system/Storage/Raid_" +
+                                       raidName + "/Volumes/" +
+                                       objpath.substr(lastPos + 1)}});
+            else if (flag == 2)
+                storageArray.push_back(
+                    {{"@odata.id", "/redfish/v1/Systems/system/Storage/HBA_" +
+                                       raidName + "/Volumes/" +
+                                       objpath.substr(lastPos + 1)}});
+            else if (flag == 3)
+                storageArray.push_back(
+                    {{"@odata.id", "/redfish/v1/Systems/system/Storage/mscc_" +
+                                       raidName + "/Volumes/" +
+                                       objpath.substr(lastPos + 1)}});
+        }
+        count = storageArray.size();
+    },
+        "xyz.openbmc_project.ObjectMapper",
+        "/xyz/openbmc_project/object_mapper",
+        "xyz.openbmc_project.ObjectMapper", "GetSubTreePaths", ldPath, 0,
+        interfaces);
+}
+
+void raidStatusTask(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                    task::Payload&& payload, const std::string& propertyName)
+{
+    std::shared_ptr<task::TaskData> task = task::TaskData::createTask(
+        [propertyName](const boost::system::error_code ec,
+                       sdbusplus::message_t& msg,
+                       const std::shared_ptr<task::TaskData>& taskData) {
+        if (ec)
+        {
+            taskData->messages.emplace_back(messages::internalError());
+            taskData->state = "Cancelled";
+            return task::completed;
+        }
+
+        std::string iface;
+        dbus::utility::DBusPropertiesMap values;
+
+        std::string index = std::to_string(taskData->index);
+        msg.read(iface, values);
+
+        if (iface == "xyz.openbmc_project.raid.Base")
+        {
+            const uint32_t* status = nullptr;
+
+            for (const auto& property : values)
+            {
+                if (property.first == propertyName)
+                {
+                    status = std::get_if<uint32_t>(&property.second);
+                    if (status == nullptr)
+                    {
+                        taskData->messages.emplace_back(
+                            messages::internalError());
+                        return task::completed;
+                    }
+                }
+            }
+
+            if (status == nullptr)
+            {
+                return !task::completed;
+            }
+
+            if (*status == 4294967295)
+            {
+                BMCWEB_LOG_DEBUG("COMMAND_IN_PROGRESS case");
+                taskData->state = "COMMAND_IN_PROGRESS";
+                taskData->messages.emplace_back(messages::taskStarted(index));
+                taskData->extendTimer(std::chrono::minutes(3));
+                return !task::completed;
+            }
+            if (*status == 0)
+            {
+                BMCWEB_LOG_DEBUG("Command SUCCESS case");
+                taskData->state = "SUCCESS";
+                taskData->messages.emplace_back(
+                    messages::taskCompletedOK(index));
+                taskData->percentComplete = 100;
+                return task::completed;
+            }
+            if (*status == 129)
+            {
+                BMCWEB_LOG_DEBUG("RAID_DEVICE_NOT_PRESENT Failed case");
+                taskData->state = "RAID_DEVICE_NOT_PRESENT";
+                taskData->messages.emplace_back(messages::taskAborted(index));
+                taskData->percentComplete = 100;
+                return task::completed;
+            }
+            if (*status == 130)
+            {
+                BMCWEB_LOG_DEBUG("RAID_CTRL_ID_INVALID Failed case");
+                taskData->state = "RAID_CTRL_ID_INVALID";
+                taskData->messages.emplace_back(messages::taskAborted(index));
+                taskData->percentComplete = 100;
+                return task::completed;
+            }
+            if (*status == 131)
+            {
+                BMCWEB_LOG_DEBUG("RAID_CTRL_DEVID_INVALID Failed case");
+                taskData->state = "RAID_CTRL_DEVID_INVALID";
+                taskData->messages.emplace_back(messages::taskAborted(index));
+                taskData->percentComplete = 100;
+                return task::completed;
+            }
+            if (*status == 132)
+            {
+                BMCWEB_LOG_DEBUG("RAID_NO_VIRTUAL_DEVICE_PRESENT Failed case");
+                taskData->state = "RAID_NO_VIRTUAL_DEVICE_PRESENT";
+                taskData->messages.emplace_back(messages::taskAborted(index));
+                taskData->percentComplete = 100;
+                return task::completed;
+            }
+            if (*status == 133)
+            {
+                BMCWEB_LOG_DEBUG("RAID_OPERATION_NOT_PERMITTED case");
+                taskData->state = "RAID_OPERATION_NOT_PERMITTED";
+                taskData->messages.emplace_back(messages::taskAborted(index));
+                taskData->percentComplete = 100;
+                return task::completed;
+            }
+            if (*status == 134)
+            {
+                BMCWEB_LOG_DEBUG("RAID_UNSUPPORTED_LOGICAL_DEV Failed case");
+                taskData->state = "RAID_UNSUPPORTED_LOGICAL_DEV";
+                taskData->messages.emplace_back(messages::taskAborted(index));
+                taskData->percentComplete = 100;
+                return task::completed;
+            }
+            if (*status == 135)
+            {
+                BMCWEB_LOG_DEBUG("RAID_OPERATION_NOT_PERMITTED case");
+                taskData->state = "RAID_OPERATION_NOT_PERMITTED";
+                taskData->messages.emplace_back(messages::taskAborted(index));
+                taskData->percentComplete = 100;
+                return task::completed;
+            }
+            if (*status == 140)
+            {
+                BMCWEB_LOG_DEBUG("RAID_COMMAND_FAILED case");
+                taskData->state = "RAID_COMMAND_FAILED";
+                taskData->messages.emplace_back(messages::taskAborted(index));
+                taskData->percentComplete = 100;
+                return task::completed;
+            }
+            if (*status == 255)
+            {
+                BMCWEB_LOG_DEBUG("UNSPECIFIED_ERR case");
+                taskData->state = "UNSPECIFIED_ERR";
+                taskData->messages.emplace_back(messages::taskAborted(index));
+                taskData->percentComplete = 100;
+                return task::completed;
+            }
+        }
+
+        return !task::completed;
+    },
+        "type='signal',interface='org.freedesktop.DBus.Properties',"
+        "member='PropertiesChanged',path='/xyz/openbmc_project/Raid'");
+    task->startTimer(std::chrono::minutes(3));
+    task->populateResp(asyncResp->res);
+    task->payload.emplace(std::move(payload));
+}
+
+inline void requestRoutesDeleteLogicalDriveAction(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/"
+                      "<str>/Actions/StorageLDrive.Delete")
+        .privileges(redfish::privileges::postChassis)
+        .methods(boost::beast::http::verb::post)(
+            [](const crow::Request& req,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& name) {
+        //            if (!redfish::utils::checkLicenseStatus(asyncResp,
+        //                                                    "StorageLDrive.Delete"))
+        //            {
+        //                return;
+        //            }
+        crow::connections::systemBus->async_method_call(
+            [asyncResp, req, name](const boost::system::error_code ec1,
+                                   const std::variant<uint32_t>& val) {
+            if (ec1)
+            {
+                BMCWEB_LOG_DEBUG("Failed to get property Value  ", ec1);
+                return;
+            }
+
+            const uint32_t* status = std::get_if<uint32_t>(&val);
+
+            if (*status == 0)
+            {
+                std::size_t type = name.find("_");
+                if (type != std::string::npos)
+                {
+                    const std::string& path = "/xyz/openbmc_project/" +
+                                              name.substr(0, type) + "/" +
+                                              name.substr(type + 1);
+
+                    crow::connections::systemBus->async_method_call(
+                        [asyncResp, req, name,
+                         type](const boost::system::error_code ec,
+                               const std::variant<uint32_t> value) {
+                        if (ec)
+                        {
+                            BMCWEB_LOG_DEBUG("failed to get property Value  ",
+                                             ec);
+                            messages::resourceNotFound(asyncResp->res, "",
+                                                       "LDriveId");
+                            return;
+                        }
+
+                        const uint32_t* ctrlId = std::get_if<uint32_t>(&value);
+
+                        std::string ldriveId;
+
+                        if (!json_util::readJsonAction(req, asyncResp->res,
+                                                       "LDriveId", ldriveId))
+                        {
+                            BMCWEB_LOG_DEBUG("Paramaters are not provided");
+                            return;
+                        }
+
+                        const std::string& ldpath =
+                            "/xyz/openbmc_project/" + name.substr(0, type) +
+                            "/" + name.substr(type + 1) + "/ld/" + ldriveId;
+
+                        const uint32_t val = *ctrlId;
+
+                        crow::connections::systemBus->async_method_call(
+                            [asyncResp, req,
+                             val](const boost::system::error_code ec,
+                                  const std::variant<uint16_t> value) {
+                            if (ec)
+                            {
+                                BMCWEB_LOG_DEBUG(
+                                    "failed to get property Value  ", ec);
+                                messages::resourceNotFound(asyncResp->res, "",
+                                                           "LDriveId");
+                                return;
+                            }
+                            const uint16_t* targetId =
+                                std::get_if<uint16_t>(&value);
+
+                            crow::connections::systemBus->async_method_call(
+                                [asyncResp,
+                                 req](const boost::system::error_code ec) {
+                                if (ec)
+                                {
+                                    BMCWEB_LOG_ERROR(
+                                        "Bad D-Bus request error: ", ec);
+                                    messages::resourceNotFound(asyncResp->res,
+                                                               "", "LDriveId");
+                                    return;
+                                }
+                                task::Payload payload(req);
+                                raidStatusTask(asyncResp, std::move(payload),
+                                               "setRAIDDeleteLDStatus");
+                            },
+                                "xyz.openbmc_project.raid.manager",
+                                "/xyz/openbmc_project/Raid",
+                                "xyz.openbmc_project.raid.Base",
+                                "setRAIDDeleteLD", val, *targetId);
+                        },
+                            "xyz.openbmc_project.raid.manager", ldpath,
+                            "org.freedesktop.DBus.Properties", "Get",
+                            "xyz.openbmc_project.raid.LogicalDrive", "Id");
+                    },
+                        "xyz.openbmc_project.raid.manager", path,
+                        "org.freedesktop.DBus.Properties", "Get",
+                        "xyz.openbmc_project.raid.Controller", "Id");
+                }
+                else
+                {
+                    messages::internalError(asyncResp->res);
+                    return;
+                }
+            }
+            else
+            {
+                messages::actionNotSupported(
+                    asyncResp->res,
+                    "StorageLDrive.Delete already running and it");
+                return;
+            }
+        },
+            "xyz.openbmc_project.raid.manager", "/xyz/openbmc_project/Raid",
+            "org.freedesktop.DBus.Properties", "Get",
+            "xyz.openbmc_project.raid.Base", "configComplete");
+    });
+}
+
+inline void requestRoutesCreateLogicalDriveAction(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/"
+                      "<str>/Actions/StorageLDrive.Create")
+        .privileges(redfish::privileges::postChassis)
+        .methods(boost::beast::http::verb::post)(
+            [](const crow::Request& req,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& name) {
+        //                if (!redfish::utils::checkLicenseStatus(asyncResp,
+        //                                                        "StorageLDrive.Create"))
+        //                {
+        //                    return;
+        //                }
+
+        crow::connections::systemBus->async_method_call(
+            [asyncResp, req, name](const boost::system::error_code ec1,
+                                   const std::variant<uint32_t>& val) {
+            if (ec1)
+            {
+                BMCWEB_LOG_DEBUG("Failed to get property Value ", ec1);
+                return;
+            }
+            const uint32_t* status = std::get_if<uint32_t>(&val);
+            if (*status == 0)
+            {
+                std::size_t type = name.find("_");
+                if (type != std::string::npos)
+                {
+                    const std::string& path = "/xyz/openbmc_project/" +
+                                              name.substr(0, type) + "/" +
+                                              name.substr(type + 1);
+
+                    crow::connections::systemBus->async_method_call(
+                        [asyncResp, req](const boost::system::error_code ec,
+                                         const std::variant<uint32_t> value) {
+                        if (ec)
+                        {
+                            BMCWEB_LOG_DEBUG("Failed to get property Value  ",
+                                             ec);
+                            return;
+                        }
+
+                        std::uint8_t cmdParm;
+                        std::uint8_t prl;
+                        std::uint8_t stripeSize;
+                        std::uint8_t initState;
+                        std::uint8_t diskCachePolicy;
+                        std::uint32_t sizeLow;
+                        std::uint32_t sizeHigh;
+                        std::uint8_t readpolicy;
+                        std::uint8_t writepolicy;
+                        std::uint8_t iopolicy;
+                        std::uint8_t accesspolicy;
+                        std::uint8_t spanDepth;
+                        std::uint8_t numDrives;
+                        std::uint8_t Accelerator;
+                        std::uint8_t ParityGroupCount;
+                        std::uint16_t ArrayNumber;
+                        std::vector<uint8_t> VDName;
+                        std::vector<uint8_t> SpanID;
+                        std::vector<uint16_t> deviceID;
+
+                        if (!json_util::readJsonAction(
+                                req, asyncResp->res, "CmdParm", cmdParm, "Prl",
+                                prl, "StripeSize", stripeSize, "InitState",
+                                initState, "DiskCachePolicy", diskCachePolicy,
+                                "SizeLow", sizeLow, "SizeHigh", sizeHigh,
+                                "Readpolicy", readpolicy, "Writepolicy",
+                                writepolicy, "Iopolicy", iopolicy,
+                                "Accesspolicy", accesspolicy, "SpanDepth",
+                                spanDepth, "NumDrives", numDrives,
+                                "Accelerator", Accelerator, "ParityGroupCount",
+                                ParityGroupCount, "ArrayNumber", ArrayNumber,
+                                "VDName", VDName, "SpanID", SpanID, "DeviceID",
+                                deviceID))
+                        {
+                            BMCWEB_LOG_DEBUG("Paramaters are not provided");
+                            return;
+                        }
+
+                        const uint32_t* ctrlId = std::get_if<uint32_t>(&value);
+
+                        crow::connections::systemBus->async_method_call(
+                            [asyncResp,
+                             req](const boost::system::error_code ec) {
+                            if (ec)
+                            {
+                                BMCWEB_LOG_ERROR(
+                                    "Bad Invalid Arguments D-Bus request error:  ",
+                                    ec);
+                                messages::internalError(asyncResp->res);
+                                return;
+                            }
+                            task::Payload payload(req);
+                            raidStatusTask(asyncResp, std::move(payload),
+                                           "manageRAIDConfigStatus");
+                        },
+                            "xyz.openbmc_project.raid.manager",
+                            "/xyz/openbmc_project/Raid",
+                            "xyz.openbmc_project.raid.Base", "manageRAIDConfig",
+                            *ctrlId, cmdParm, prl, stripeSize, initState,
+                            diskCachePolicy, sizeLow, sizeHigh, readpolicy,
+                            writepolicy, iopolicy, accesspolicy, spanDepth,
+                            numDrives, Accelerator, ParityGroupCount,
+                            ArrayNumber, VDName, SpanID, deviceID);
+                    },
+                        "xyz.openbmc_project.raid.manager", path,
+                        "org.freedesktop.DBus.Properties", "Get",
+                        "xyz.openbmc_project.raid.Controller", "Id");
+                }
+                else
+                {
+                    messages::internalError(asyncResp->res);
+                    return;
+                }
+            }
+            else
+            {
+                messages::actionNotSupported(
+                    asyncResp->res,
+                    "StorageLDrive.Create already running and it");
+                return;
+            }
+        },
+            "xyz.openbmc_project.raid.manager", "/xyz/openbmc_project/Raid",
+            "org.freedesktop.DBus.Properties", "Get",
+            "xyz.openbmc_project.raid.Base", "configComplete");
+    });
+}
+
+void getPhysicalDrives(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
+                       const std::string& name, nlohmann::json& storageArray,
+                       nlohmann::json& count, int flag,
+                       const std::string& pdPath,
+                       const std::array<const char*, 1> interfaces)
+{
+    crow::connections::systemBus->async_method_call(
+        [asyncResp, name, &storageArray, &count,
+         flag](const boost::system::error_code ec,
+               const std::vector<std::string>& storageList) {
+        if (ec)
+        {
+            BMCWEB_LOG_ERROR("Drive mapper call error");
+            // messages::internalError(asyncResp->res);
+            return;
+        }
+
+        for (const std::string& objpath : storageList)
+        {
+            std::size_t lastPos = objpath.rfind('/');
+            if (lastPos == std::string::npos || (objpath.size() <= lastPos + 1))
+            {
+                BMCWEB_LOG_ERROR("Failed to find '/' in ", objpath);
+                continue;
+            }
+            if (flag == 1)
+                storageArray.push_back(
+                    {{"@odata.id", "/redfish/v1/Systems/system/Storage/Raid_" +
+                                       name + "/Drives/" +
+                                       objpath.substr(lastPos + 1)}});
+            else if (flag == 2)
+                storageArray.push_back(
+                    {{"@odata.id", "/redfish/v1/Systems/system/Storage/HBA_" +
+                                       name + "/Drives/" +
+                                       objpath.substr(lastPos + 1)}});
+            else if (flag == 3)
+                storageArray.push_back(
+                    {{"@odata.id", "/redfish/v1/Systems/system/Storage/mscc_" +
+                                       name + "/Drives/" +
+                                       objpath.substr(lastPos + 1)}});
+        }
+        count = storageArray.size();
+    },
+        "xyz.openbmc_project.ObjectMapper",
+        "/xyz/openbmc_project/object_mapper",
+        "xyz.openbmc_project.ObjectMapper", "GetSubTreePaths", pdPath, 0,
+        interfaces);
+}
+
+void getRaidDevices(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
+                    nlohmann::json& count,
+                    nlohmann::json& storageControllerArray)
+{
+    crow::connections::systemBus->async_method_call(
+        [asyncResp, &count,
+         &storageControllerArray](const boost::system::error_code ec,
+                                  const std::vector<std::string>& storageList) {
+        if (ec)
+        {
+            BMCWEB_LOG_ERROR("DBUS error: no matched iface \n");
+            return;
+        }
+        for (const std::string& objpath : storageList)
+        {
+            std::size_t lastPos = objpath.rfind('/');
+            if (lastPos == std::string::npos || (objpath.size() <= lastPos + 1))
+            {
+                BMCWEB_LOG_ERROR("Failed to find '/' in ", objpath);
+                continue;
+            }
+            storageControllerArray.push_back(
+                {{"@odata.id", "/redfish/v1/Systems/system/Storage/Raid_" +
+                                   objpath.substr(lastPos + 1)}});
+        } // object path loop
+        count = storageControllerArray.size();
+    },
+        "xyz.openbmc_project.ObjectMapper",
+        "/xyz/openbmc_project/object_mapper",
+        "xyz.openbmc_project.ObjectMapper", "GetSubTreePaths",
+        "/xyz/openbmc_project/Raid", 0,
+        std::array<const char*, 1>{"xyz.openbmc_project.raid.Controller"});
+}
+
+void requestRoutesRaidLogical(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/"
+                      "<str>"
+                      "/Volumes/")
+        .privileges(redfish::privileges::getStorage)
+        .methods(boost::beast::http::verb::get)(
+            [](const crow::Request&,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& name) {
+        //                if (!redfish::utils::checkLicenseStatus(asyncResp,
+        //                                                        "Raid_" +
+        //                                                        raidName))
+        //                {
+        //                    return;
+        //                }
+        asyncResp->res.jsonValue["@odata.type"] =
+            "#VolumeCollection.VolumeCollection";
+        asyncResp->res.jsonValue["@odata.id"] =
+            "/redfish/v1/Systems/system/Storage/" + name + "/Volumes";
+        asyncResp->res.jsonValue["Name"] = "Volume Collection";
+        asyncResp->res.jsonValue["Description"] = "The Collection of Volumes";
+        nlohmann::json& storageControllerArray =
+            asyncResp->res.jsonValue["Members"];
+        storageControllerArray = nlohmann::json::array();
+        auto& count = asyncResp->res.jsonValue["Members@odata.count"];
+        count = 0;
+        std::size_t type = name.find("_");
+        int flag;
+        std::string ldPath;
+        const char* ldInterface;
+        if (name.substr(0, type) == "Raid")
+        {
+            flag = 1;
+            ldPath = "/xyz/openbmc_project/" + name.substr(0, type) + "/" +
+                     name.substr(type + 1) + "/ld";
+            ldInterface = "xyz.openbmc_project.raid.LogicalDrive";
+        }
+        else if (name.substr(0, type) == "mscc")
+        {
+            flag = 3;
+            ldPath = "/com/ami/storage/" + name.substr(0, type) + "/ctrl/" +
+                     name.substr(type + 1) + "/ld";
+            ldInterface = "com.ami.storage.mscc.ctrl.LogicalDrive";
+        }
+        const std::array<const char*, 1> interfaces = {ldInterface};
+        getLogicalDrives(asyncResp, name.substr(type + 1),
+                         storageControllerArray, count, flag, ldPath,
+                         interfaces);
+    });
+}
+
+inline void requestRoutesRaidLogicalDrive(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/"
+                      "<str>"
+                      "/Volumes/"
+                      "<str>")
+        .privileges(redfish::privileges::getStorage)
+        .methods(boost::beast::http::verb::get)(
+            [](const crow::Request&,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& name, const std::string& drive) {
+        //            if (!redfish::utils::checkLicenseStatus(asyncResp,
+        //                                                    "Raid_" +
+        //                                                    raidName))
+        //            {
+        //                return;
+        //            }
+        asyncResp->res.jsonValue["@odata.type"] = "#Volume.v1_6_2.Volume";
+        asyncResp->res.jsonValue["@odata.id"] =
+            "/redfish/v1/Systems/system/Storage/" + name + "/Volumes/" + drive;
+        asyncResp->res.jsonValue["Id"] = drive;
+        // asyncResp->res.jsonValue["Name"] = "LogicalDrive_" + drive;
+        asyncResp->res.jsonValue["Oem"]["OpenBmc"]["@odata.type"] =
+            "#OemVolume.v1_0_0.Volume";
+        std::size_t type = name.find("_");
+        if (type != std::string::npos)
+        {
+            const char* service;
+            const char* ldInterface;
+            std::string ldPath;
+            std::string pdPath;
+            const char* driveInf;
+            int flag;
+            std::string driveName = drive;
+            if (name.substr(0, type) == "Raid")
+            {
+                ldPath = "/xyz/openbmc_project/" + name.substr(0, type) + "/" +
+                         name.substr(type + 1) + "/ld/" + driveName;
+                pdPath = "/xyz/openbmc_project/" + name.substr(0, type) + "/" +
+                         name.substr(type + 1) + "/pd";
+                service = "xyz.openbmc_project.raid.manager";
+                ldInterface = "xyz.openbmc_project.raid.LogicalDrive";
+                driveInf = "xyz.openbmc_project.raid.PhysicalDrive";
+                flag = 1;
+            }
+            else if (name.substr(0, type) == "mscc")
+            {
+                ldPath = "/com/ami/storage/" + name.substr(0, type) + "/ctrl/" +
+                         name.substr(type + 1) + "/ld/" + driveName;
+                pdPath = "/com/ami/storage/" + name.substr(0, type) + "/ctrl/" +
+                         name.substr(type + 1) + "/pd";
+                service = "com.ami.storage";
+                ldInterface = "com.ami.storage.mscc.ctrl.LogicalDrive";
+                driveInf = "com.ami.storage.mscc.ctrl.PhysicalDrive";
+                flag = 3;
+            }
+            crow::connections::systemBus->async_method_call(
+                [asyncResp](
+                    const boost::system::error_code ec2,
+                    const std::vector<std::pair<
+                        std::string,
+                        std::variant<std::string, uint64_t, uint32_t, uint16_t,
+                                     std::vector<uint16_t>>>>& propertiesList) {
+                if (ec2)
+                {
+                    return;
+                }
+                for (const std::pair<
+                         std::string,
+                         std::variant<std::string, uint64_t, uint32_t, uint16_t,
+                                      std::vector<uint16_t>>>& property :
+                     propertiesList)
+                {
+                    const std::string& propertyName = property.first;
+
+                    if ((propertyName == "StripSizeBytes") ||
+                        (propertyName == "CapacityBytes"))
+                    {
+                        const uint64_t* value =
+                            std::get_if<uint64_t>(&property.second);
+                        if (value != nullptr)
+                        {
+                            asyncResp->res.jsonValue[propertyName] = *value;
+                        }
+                    }
+                    if ((propertyName == "RaidLevel") ||
+                        (propertyName == "ReadCachePolicyType") ||
+                        (propertyName == "WriteCachePolicyType") ||
+                        (propertyName == "Health") || (propertyName == "Name"))
+                    {
+                        const std::string* value =
+                            std::get_if<std::string>(&property.second);
+                        if (value != nullptr)
+                        {
+                            if (propertyName == "ReadCachePolicyType")
+                            {
+                                asyncResp->res.jsonValue["ReadCachePolicy"] =
+                                    *value;
+                            }
+                            else if (propertyName == "WriteCachePolicyType")
+                            {
+                                asyncResp->res.jsonValue["WriteCachePolicy"] =
+                                    *value;
+                            }
+                            else if (propertyName == "RaidLevel")
+                            {
+                                asyncResp->res.jsonValue["RAIDType"] =
+                                    value->substr(value->find_last_of(".") + 1);
+                            }
+                            else if (propertyName == "Health")
+                            {
+                                if (*value == "OK")
+                                {
+                                    asyncResp->res
+                                        .jsonValue["Status"][propertyName] =
+                                        *value;
+                                    asyncResp->res
+                                        .jsonValue["Status"]["State"] =
+                                        "Enabled";
+                                }
+                                else
+                                {
+                                    asyncResp->res
+                                        .jsonValue["Status"][propertyName] =
+                                        *value;
+                                    asyncResp->res
+                                        .jsonValue["Status"]["State"] =
+                                        "Disabled";
+                                }
+                            }
+                            else
+                                asyncResp->res.jsonValue[propertyName] = *value;
+                        }
+                    }
+                    if (propertyName == "PdList" ||
+                        propertyName == "DataPdList" ||
+                        propertyName == "SparePdList")
+                    {
+                        const std::vector<uint16_t>* value =
+                            std::get_if<std::vector<uint16_t>>(
+                                &property.second);
+                        if (value != nullptr)
+                        {
+                            if (propertyName == "DataPdList")
+                            {
+                                asyncResp->res.jsonValue["Oem"]["OpenBmc"]
+                                                        ["PdList"] = *value;
+                            }
+                            else
+                            {
+                                asyncResp->res.jsonValue["Oem"]["OpenBmc"]
+                                                        [propertyName] = *value;
+                            }
+                        }
+                    }
+                    if ((propertyName == "Id"))
+                    {
+                        const uint16_t* value =
+                            std::get_if<uint16_t>(&property.second);
+
+                        if (value != nullptr)
+                        {
+                            asyncResp->res.jsonValue["Oem"]["OpenBmc"]
+                                                    ["LDeviceId"] = *value;
+                        }
+                    }
+                }
+            },
+                service, ldPath, "org.freedesktop.DBus.Properties", "GetAll",
+                ldInterface);
+            nlohmann::json& storageControllerArray =
+                asyncResp->res.jsonValue["Links"]["Drives"];
+            storageControllerArray = nlohmann::json::array();
+            auto& count =
+                asyncResp->res.jsonValue["Links"]["Drives@odata.count"];
+            count = 0;
+            const std::array<const char*, 1> interfaces = {driveInf};
+            getPhysicalDrives(asyncResp, name.substr(type + 1),
+                              storageControllerArray, count, flag, pdPath,
+                              interfaces);
+        }
+    });
+}
+
+void getHBADevices(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
+                   nlohmann::json& count,
+                   nlohmann::json& storageControllerArray)
+{
+    crow::connections::systemBus->async_method_call(
+        [asyncResp, &count,
+         &storageControllerArray](const boost::system::error_code ec,
+                                  const std::vector<std::string>& storageList) {
+        if (ec)
+        {
+            BMCWEB_LOG_ERROR("DBUS error: no matched iface \n");
+            return;
+        }
+        for (const std::string& objpath : storageList)
+        {
+            std::size_t lastPos = objpath.rfind('/');
+            if (lastPos == std::string::npos || (objpath.size() <= lastPos + 1))
+            {
+                BMCWEB_LOG_ERROR("Failed to find '/' in ", objpath);
+                continue;
+            }
+            storageControllerArray.push_back(
+                {{"@odata.id", "/redfish/v1/Systems/system/Storage/HBA_" +
+                                   objpath.substr(lastPos + 1)}});
+        } // object path loop
+        count = storageControllerArray.size();
+    },
+        "xyz.openbmc_project.ObjectMapper",
+        "/xyz/openbmc_project/object_mapper",
+        "xyz.openbmc_project.ObjectMapper", "GetSubTreePaths",
+        "/xyz/openbmc_project/HBA", 0,
+        std::array<const char*, 1>{"xyz.openbmc_project.hba.Controller"});
+}
+
+void getStorageInstance(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
+                        const std::string& name)
+{
+    asyncResp->res.jsonValue["@odata.type"] = "#Storage.v1_10_1.Storage";
+    asyncResp->res.jsonValue["@odata.id"] =
+        "/redfish/v1/Systems/system/Storage/" + name;
+    asyncResp->res.jsonValue["Name"] = "Local Storage Controller";
+
+    asyncResp->res.jsonValue["Id"] = name;
+
+    std::size_t type = name.find("_");
+    if (type != std::string::npos)
+    {
+        asyncResp->res.jsonValue["Description"] =
+            "Integrated " + name.substr(0, type) + " Controller";
+        const char* service;
+        const char* inf;
+        const char* driveInf;
+        int flag;
+        std::string path;
+        std::string pdPath;
+
+        if (name.substr(0, type) == "mscc")
+        {
+            path = "/com/ami/storage/" + name.substr(0, type) + "/ctrl/" +
+                   name.substr(type + 1);
+
+            pdPath = "/com/ami/storage/" + name.substr(0, type) + "/ctrl/" +
+                     name.substr(type + 1) + "/pd";
+        }
+        else
+        {
+            path = "/xyz/openbmc_project/" + name.substr(0, type) + "/" +
+                   name.substr(type + 1);
+
+            pdPath = "/xyz/openbmc_project/" + name.substr(0, type) + "/" +
+                     name.substr(type + 1) + "/pd";
+        }
+
+        if (name.substr(0, type) == "HBA")
+        {
+            service = "xyz.openbmc_project.hba.manager";
+            inf = "xyz.openbmc_project.hba.Controller";
+            driveInf = "xyz.openbmc_project.hba.PhysicalDrive";
+            flag = 2;
+        }
+        else if (name.substr(0, type) == "Raid")
+        {
+            service = "xyz.openbmc_project.raid.manager";
+            inf = "xyz.openbmc_project.raid.Controller";
+            driveInf = "xyz.openbmc_project.raid.PhysicalDrive";
+            flag = 1;
+        }
+        else if (name.substr(0, type) == "mscc")
+        {
+            service = "com.ami.storage";
+            inf = "com.ami.storage.mscc.ctrl.Controller";
+            driveInf = "com.ami.storage.mscc.ctrl.PhysicalDrive";
+            flag = 3;
+            asyncResp->res.jsonValue["Volumes"] = {
+                {"@odata.id",
+                 "/redfish/v1/Systems/system/Storage/" + name + "/Volumes"}};
+            asyncResp->res.jsonValue["Actions"]["Oem"]
+                                    ["#StorageCollection.CreateDrive"] = {
+                {"target", "/redfish/v1/Systems/system/Storage/" + name +
+                               "/Actions/StorageMSCCLDrive.Create"}};
+
+            asyncResp->res.jsonValue["Actions"]["Oem"]
+                                    ["#StorageCollection.DeleteDrive"] = {
+                {"target", "/redfish/v1/Systems/system/Storage/" + name +
+                               "/Actions/StorageMSCCLDrive.Delete"}};
+        }
+        else
+        {
+            // messages::internalError(asyncResp->res);
+            return;
+        }
+
+        if ((name.substr(0, type) == "Raid"))
+        {
+            asyncResp->res.jsonValue["Volumes"] = {
+                {"@odata.id",
+                 "/redfish/v1/Systems/system/Storage/" + name + "/Volumes"}};
+            asyncResp->res.jsonValue["Actions"]["Oem"]
+                                    ["#StorageCollection.CreateDrive"] = {
+                {"target", "/redfish/v1/Systems/system/Storage/" + name +
+                               "/Actions/StorageLDrive.Create"}};
+
+            asyncResp->res.jsonValue["Actions"]["Oem"]
+                                    ["#StorageCollection.DeleteDrive"] = {
+                {"target", "/redfish/v1/Systems/system/Storage/" + name +
+                               "/Actions/StorageLDrive.Delete"}};
+        }
+
+        nlohmann::json& storageControllerArray =
+            asyncResp->res.jsonValue["Drives"];
+        storageControllerArray = nlohmann::json::array();
+        auto& count = asyncResp->res.jsonValue["Drives@odata.count"];
+        count = 0;
+        const std::array<const char*, 1> interfaces = {driveInf};
+        getPhysicalDrives(asyncResp, name.substr(type + 1),
+                          storageControllerArray, count, flag, pdPath,
+                          (interfaces));
+        asyncResp->res.jsonValue["Oem"]["OpenBmc"]["@odata.type"] =
+            "#OemStorage.v1_0_0.OemStorage";
+        if ((name.substr(0, type) == "Raid"))
+        {
+            crow::connections::systemBus->async_method_call(
+                [asyncResp](
+                    const boost::system::error_code ec2,
+                    const std::vector<
+                        std::pair<std::string, std::variant<bool, uint32_t>>>&
+                        propertiesList) {
+                if (ec2)
+                {
+                    return;
+                }
+                for (const std::pair<std::string, std::variant<bool, uint32_t>>&
+                         property : propertiesList)
+                {
+                    const std::string& propertyName = property.first;
+                    if ((propertyName == "manageRAIDConfigStatus") ||
+                        (propertyName == "setRAIDDeleteLDStatus") ||
+                        (propertyName == "configComplete"))
+                    {
+                        const uint32_t* value =
+                            std::get_if<uint32_t>(&property.second);
+                        if (value != nullptr)
+                        {
+                            asyncResp->res.jsonValue["Oem"]["OpenBmc"]
+                                                    [propertyName] = *value;
+                        }
+                    }
+                }
+            },
+                "xyz.openbmc_project.raid.manager", "/xyz/openbmc_project/Raid",
+                "org.freedesktop.DBus.Properties", "GetAll",
+                "xyz.openbmc_project.raid.Base");
+        }
+        crow::connections::systemBus->async_method_call(
+            [asyncResp, name, type](
+                const boost::system::error_code ec2,
+                const std::vector<std::pair<
+                    std::string,
+                    std::variant<bool, std::string, uint32_t, uint16_t,
+                                 std::vector<std::string>>>>& propertiesList) {
+            if (ec2)
+            {
+                messages::resourceNotFound(asyncResp->res,
+                                           "#Storage.v1_13_0.Storage", name);
+                return;
+            }
+
+            nlohmann::json& controllerArray =
+                asyncResp->res.jsonValue["StorageControllers"];
+            controllerArray = nlohmann::json::array();
+
+            nlohmann::json& storageController =
+                controllerArray.emplace_back(nlohmann::json::object());
+
+            storageController["@odata.id"] =
+                "/redfish/v1/Systems/system/Storage/" + name +
+                "#/StorageControllers/0";
+            storageController["MemberId"] = "0";
+
+            storageController["Name"] = "Local Storage Controller";
+
+            for (const std::pair<
+                     std::string,
+                     std::variant<bool, std::string, uint32_t, uint16_t,
+                                  std::vector<std::string>>>& property :
+                 propertiesList)
+            {
+                const std::string& propertyName = property.first;
+
+                if ((propertyName == "Model") ||
+                    (propertyName == "SerialNumber") ||
+                    (propertyName == "FirmwareVersion"))
+                {
+                    const std::string* value =
+                        std::get_if<std::string>(&property.second);
+
+                    if (value != nullptr)
+                    {
+                        storageController[propertyName] = *value;
+                    }
+                }
+
+                if (propertyName == "Health")
+                {
+                    const std::string* value =
+                        std::get_if<std::string>(&property.second);
+                    if (value != nullptr)
+                    {
+                        if (*value == "OK")
+                        {
+                            asyncResp->res.jsonValue["Status"][propertyName] =
+                                *value;
+                            asyncResp->res.jsonValue["Status"]["State"] =
+                                "Enabled";
+                        }
+                        else
+                        {
+                            asyncResp->res.jsonValue["Status"][propertyName] =
+                                *value;
+                            asyncResp->res.jsonValue["Status"]["State"] =
+                                "Disabled";
+                        }
+                    }
+                }
+
+                if (propertyName == "SupportedRaidLevel")
+                {
+                    const std::vector<std::string>* value =
+                        std::get_if<std::vector<std::string>>(&property.second);
+                    if (value != nullptr)
+                    {
+                        storageController["SupportedRAIDTypes"] = *value;
+                    }
+                }
+            }
+        },
+            service, path, "org.freedesktop.DBus.Properties", "GetAll", inf);
+    }
+    else
+    {
+        messages::internalError(asyncResp->res);
+        return;
+    }
+}
+
+inline void requestRoutesPhysicalDrive(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Storage/"
+                      "<str>"
+                      "/Drives/"
+                      "<str>")
+        .privileges(redfish::privileges::getStorage)
+        .methods(boost::beast::http::verb::get)(
+            [](const crow::Request&,
+               const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+               const std::string& name, const std::string& drive) {
+        //            if (!redfish::utils::checkLicenseStatus(asyncResp, name))
+        //            {
+        //                return;
+        //            }
+        asyncResp->res.jsonValue["@odata.type"] = "#Drive.v1_13_0.Drive";
+        asyncResp->res.jsonValue["@odata.id"] =
+            "/redfish/v1/Systems/system/Storage/" + name + "/Drives/" + drive;
+        asyncResp->res.jsonValue["Id"] = drive;
+        asyncResp->res.jsonValue["Name"] = "PhysicalDrive_" + drive;
+        asyncResp->res.jsonValue["Oem"]["OpenBmc"]["@odata.type"] =
+            "#OemDrive.v1_0_0.Drive";
+        asyncResp->res.jsonValue["Oem"]["OpenBmc"]["@odata.id"] =
+            "/redfish/v1/Systems/system/Storage/" + name + "/Drives/" + drive +
+            "#/Oem/OpenBmc";
+        std::size_t type = name.find("_");
+        if (type != std::string::npos)
+        {
+            const char* service;
+            const char* interface;
+            const char* ldInterface;
+            std::string pdPath;
+            std::string ldPath;
+            std::string driveName = drive;
+            int flag;
+            if ((name.substr(0, type) == "Raid") ||
+                (name.substr(0, type) == "HBA"))
+            {
+                pdPath = "/xyz/openbmc_project/" + name.substr(0, type) + "/" +
+                         name.substr(type + 1) + "/pd/" + driveName;
+                ldPath = "/xyz/openbmc_project/" + name.substr(0, type) + "/" +
+                         name.substr(type + 1) + "/ld";
+            }
+
+            if (name.substr(0, type) == "Raid")
+            {
+                service = "xyz.openbmc_project.raid.manager";
+                interface = "xyz.openbmc_project.raid.PhysicalDrive";
+                ldInterface = "xyz.openbmc_project.raid.LogicalDrive";
+                flag = 1;
+            }
+            else if (name.substr(0, type) == "HBA")
+            {
+                service = "xyz.openbmc_project.hba.manager";
+                interface = "xyz.openbmc_project.hba.PhysicalDrive";
+            }
+            else if (name.substr(0, type) == "mscc")
+            {
+                service = "com.ami.storage";
+                interface = "com.ami.storage.mscc.ctrl.PhysicalDrive";
+                ldInterface = "com.ami.storage.mscc.ctrl.LogicalDrive";
+                pdPath = "/com/ami/storage/" + name.substr(0, type) + "/ctrl/" +
+                         name.substr(type + 1) + "/pd/" + driveName;
+                ldPath = "/com/ami/storage/" + name.substr(0, type) + "/ctrl/" +
+                         name.substr(type + 1) + "/ld";
+                flag = 3;
+            }
+            else
+            {
+                messages::internalError(asyncResp->res);
+                return;
+            }
+
+            if ((name.substr(0, type) == "mscc") ||
+                (name.substr(0, type) == "Raid"))
+            {
+                nlohmann::json& storageControllerArray =
+                    asyncResp->res.jsonValue["Links"]["Volumes"];
+                storageControllerArray = nlohmann::json::array();
+                nlohmann::json& count =
+                    asyncResp->res.jsonValue["Links"]["Volumes@odata.count"];
+                const std::array<const char*, 1> interfaces = {ldInterface};
+                getLogicalDrives(asyncResp, name.substr(type + 1),
+                                 storageControllerArray, count, flag, ldPath,
+                                 interfaces);
+                asyncResp->res.jsonValue["Links"]["Storage"]["@odata.id"] =
+                    "/redfish/v1/Systems/system/Storage/" + name;
+            }
+
+            crow::connections::systemBus->async_method_call(
+                [asyncResp](
+                    const boost::system::error_code ec2,
+                    const std::vector<std::pair<
+                        std::string,
+                        std::variant<std::string, uint32_t, uint64_t, uint16_t,
+                                     double, uint8_t>>>& propertiesList) {
+                if (ec2)
+                {
+                    // messages::internalError(asyncResp->res);
+                    return;
+                }
+                for (const std::pair<
+                         std::string,
+                         std::variant<std::string, uint32_t, uint64_t, uint16_t,
+                                      double, uint8_t>>& property :
+                     propertiesList)
+                {
+                    const std::string& propertyName = property.first;
+                    if (propertyName == "Id")
+                    {
+                        const uint16_t* value =
+                            std::get_if<uint16_t>(&property.second);
+                        if (value != nullptr)
+                        {
+                            asyncResp->res.jsonValue["Oem"]["OpenBmc"]
+                                                    ["PDeviceId"] = *value;
+                        }
+                    }
+
+                    if ((propertyName == "FailurePredicted"))
+                    {
+                        const uint32_t* value =
+                            std::get_if<uint32_t>(&property.second);
+                        if (value != nullptr)
+                        {
+                            if (*value == 0)
+                                asyncResp->res.jsonValue[propertyName] = false;
+                            else
+                                asyncResp->res.jsonValue[propertyName] = true;
+                        }
+                    }
+
+                    if ((propertyName == "BlockSizeBytes"))
+                    {
+                        const uint64_t* value =
+                            std::get_if<uint64_t>(&property.second);
+                        if (value != nullptr)
+                        {
+                            asyncResp->res.jsonValue[propertyName] = *value;
+                        }
+                    }
+
+                    if ((propertyName == "Manufacturer") ||
+                        (propertyName == "Revision") ||
+                        (propertyName == "SerialNumber") ||
+                        (propertyName == "LinkSpeed") ||
+                        (propertyName == "ProductId") ||
+                        (propertyName == "Slot") ||
+                        (propertyName == "InterfaceType"))
+                    {
+                        const std::string* value =
+                            std::get_if<std::string>(&property.second);
+                        if (value != nullptr)
+                        {
+                            if ((propertyName == "ProductId"))
+                                asyncResp->res.jsonValue["Oem"]["OpenBmc"]
+                                                        [propertyName] = *value;
+                            else if (propertyName == "LinkSpeed")
+                            {
+                                std::string gbs_value;
+                                std::string gbs =
+                                    value->substr(value->find_last_of(".") + 1);
+                                for (auto c : gbs)
+                                {
+                                    if (std::isdigit(c))
+                                        gbs_value += c;
+                                }
+                                asyncResp->res.jsonValue["NegotiatedSpeedGbs"] =
+                                    std::stoi(gbs_value);
+                            }
+                            else if (propertyName == "Slot")
+                                asyncResp->res.jsonValue["Oem"]["OpenBmc"]
+                                                        [propertyName] = *value;
+                            else if (propertyName == "InterfaceType")
+                            {
+                                asyncResp->res.jsonValue["Protocol"] =
+                                    value->substr(value->find_last_of(".") + 1);
+                            }
+                            else
+                                asyncResp->res.jsonValue[propertyName] = *value;
+                        }
+                    }
+                    if (propertyName == "Health")
+                    {
+                        const std::string* value =
+                            std::get_if<std::string>(&property.second);
+                        if (*value == "OK")
+                        {
+                            asyncResp->res.jsonValue["Status"][propertyName] =
+                                *value;
+                            asyncResp->res.jsonValue["Status"]["State"] =
+                                "Enabled";
+                        }
+                        else
+                        {
+                            asyncResp->res.jsonValue["Status"][propertyName] =
+                                *value;
+                            asyncResp->res.jsonValue["Status"]["State"] =
+                                "Disabled";
+                        }
+                    }
+                }
+            },
+                service, pdPath, "org.freedesktop.DBus.Properties", "GetAll",
+                interface);
+        }
+        else
+        {
+            messages::actionParameterUnknown(asyncResp->res, "Raid/HBA/MSCC",
+                                             name);
+
+            return;
+        }
+    });
+}
+
+} // namespace redfish
diff --git a/static/redfish/v1/$metadata/index.xml b/static/redfish/v1/$metadata/index.xml
index 156b5f04..887e6da3 100644
--- a/static/redfish/v1/$metadata/index.xml
+++ b/static/redfish/v1/$metadata/index.xml
@@ -3635,5 +3635,13 @@
         <edmx:Include Namespace="OemDrive"/>
         <edmx:Include Namespace="OemDrive.v1_0_0"/>
     </edmx:Reference>
+    <edmx:Reference Uri="/redfish/v1/schema/OemVolume_v1.xml">
+        <edmx:Include Namespace="OemVolume"/>
+        <edmx:Include Namespace="OemVolume.v1_0_0"/>
+    </edmx:Reference>
+    <edmx:Reference Uri="/redfish/v1/schema/OemStorage_v1.xml">
+        <edmx:Include Namespace="OemStorage"/>
+        <edmx:Include Namespace="OemStorage.v1_0_0"/>
+    </edmx:Reference>
 
 </edmx:Edmx>
diff --git a/static/redfish/v1/JsonSchemas/OemDrive/index.json b/static/redfish/v1/JsonSchemas/OemDrive/index.json
index 9c3a6f08..be754a9f 100644
--- a/static/redfish/v1/JsonSchemas/OemDrive/index.json
+++ b/static/redfish/v1/JsonSchemas/OemDrive/index.json
@@ -59,6 +59,15 @@
                     ]
                 }
             },
+            "PDeviceId": {
+                "description": "Physical DeviceId.",
+                "longDescription": "This value indicates Physical DeviceId.",
+                "readonly": true,
+                "type": [
+                    "number",
+                    "null"
+                ]
+            },
             "type": "object"
         }
     },
diff --git a/static/redfish/v1/JsonSchemas/OemStorage/index.json b/static/redfish/v1/JsonSchemas/OemStorage/index.json
new file mode 100644
index 00000000..c68253ab
--- /dev/null
+++ b/static/redfish/v1/JsonSchemas/OemStorage/index.json
@@ -0,0 +1,56 @@
+{
+    "$id": "http://redfish.dmtf.org/schemas/v1/OemStorage.v1_0_0.json",
+    "$schema": "http://redfish.dmtf.org/schemas/v1/redfish-schema-v1.json",
+    "copyright": "Copyright 2014-2019 DMTF. For the full DMTF copyright policy, see http://www.dmtf.org/about/policies/copyright",
+    "definitions": {
+        "OpenBmc": {
+            "additionalProperties": false,
+            "description": "OEM Extension for Storage",
+            "longDescription": "OEM Extension for Storage",
+            "patternProperties": {
+                "^([a-zA-Z_][a-zA-Z0-9_]*)?@(odata|Redfish|Message)\\.[a-zA-Z_][a-zA-Z0-9_]*$": {
+                    "description": "This property shall specify a valid odata or Redfish property.",
+                    "type": [
+                        "array",
+                        "boolean",
+                        "integer",
+                        "number",
+                        "null",
+                        "object",
+                        "string"
+                    ]
+                }
+            },
+            "properties": {
+                "configComplete": {
+                    "description": "This indicates whether configuration information is ready.",
+                    "longDescription": "The value of this property  used to indicateconfiguration information is ready.",
+                     "type": [
+                            "number",
+                            "null"
+                        ]         
+                },
+		"manageRAIDConfigStatus": {
+                    "description": "The status of calling manageRAIDConfig method.",
+                    "longDescription": "The value of this property is used to indicate the status of calling manageRAIDConfig method.",
+                     "type": [
+                            "number",
+                            "null"
+                        ]
+                },
+                "setRAIDDeleteLDStatus": {
+                    "description": "The status of calling setRAIDDelete method.",
+                    "longDescription": "The value of this property is used to indicate the status of calling setRAIDDelete method.",
+                     "type": [
+                            "number",
+                            "null"
+                        ]
+                },
+		"type": "object"
+           }
+    },
+    "owningEntity": "Oem",
+    "release": "1.0",
+    "title": "#OemStorage.v1_0_0"
+}
+
diff --git a/static/redfish/v1/JsonSchemas/OemVolume/index.json b/static/redfish/v1/JsonSchemas/OemVolume/index.json
new file mode 100644
index 00000000..26232fb8
--- /dev/null
+++ b/static/redfish/v1/JsonSchemas/OemVolume/index.json
@@ -0,0 +1,62 @@
+{
+    "$id": "http://redfish.dmtf.org/schemas/v1/OemVolume.v1_0_0.json",
+    "$schema": "http://redfish.dmtf.org/schemas/v1/redfish-schema-v1.json",
+    "copyright": "Copyright 2014-2019 DMTF. For the full DMTF copyright policy, see http://www.dmtf.org/about/policies/copyright",
+    "definitions": {
+        "OpenBmc": {
+            "additionalProperties": false,
+            "description": "OEM Extension for Volume",
+            "longDescription": "OEM Extension for Volume",
+            "patternProperties": {
+                "^([a-zA-Z_][a-zA-Z0-9_]*)?@(odata|Redfish|Message)\\.[a-zA-Z_][a-zA-Z0-9_]*$": {
+                    "description": "This property shall specify a valid odata or Redfish property.",
+                    "type": [
+                        "array",
+                        "boolean",
+                        "integer",
+                        "number",
+                        "null",
+                        "object",
+                        "string"
+                    ]
+                }
+            },
+            "properties": {
+                "pdList": {
+                    "description": "Physical Drive List",
+                    "longDescription": "Physical Drive List",
+                    "items": {
+                        "type": [
+                            "number",
+                            "null"
+                        ]
+                    },
+		    "type": "array"
+                },
+                "SparePdList": {
+                    "description": "Spare Physical Drive List",
+                    "longDescription": "Spare Physical Drive List",
+                      "items": {
+                        "type": [
+                            "number",
+                            "null"
+                        ]
+                    },
+                    "type": "array"
+            },
+            "LDeviceId": {
+                "description": "Logical DeviceId.",
+                "longDescription": "This value indicates Logical DeviceId.",
+                "readonly": true,
+                "type": [
+                    "number",
+                    "null"
+                ]
+            },
+            "type": "object"
+        }
+    },
+    "owningEntity": "Oem",
+    "release": "1.0",
+    "title": "#OemVolume.v1_0_0"
+}
diff --git a/static/redfish/v1/schema/OemDrive_v1.xml b/static/redfish/v1/schema/OemDrive_v1.xml
index 8ab7ec18..1341da06 100644
--- a/static/redfish/v1/schema/OemDrive_v1.xml
+++ b/static/redfish/v1/schema/OemDrive_v1.xml
@@ -48,6 +48,11 @@
           <Annotation Term="OData.Description" String="The slot number the drive connected."/>
           <Annotation Term="OData.LongDescription" String="The slot number the drive connected.."/>
         </Property>
+         <Property Name="PDeviceId" Type="Edm.Decimal">
+          <Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+          <Annotation Term="OData.Description" String="Physical DeviceId."/>
+          <Annotation Term="OData.LongDescription" String="This value indicates Physical DeviceId."/>
+        </Property>
       </EntityType>
     </Schema>
 
diff --git a/static/redfish/v1/schema/OemStorage_v1.xml b/static/redfish/v1/schema/OemStorage_v1.xml
new file mode 100644
index 00000000..7066834d
--- /dev/null
+++ b/static/redfish/v1/schema/OemStorage_v1.xml
@@ -0,0 +1,61 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<edmx:Edmx xmlns:edmx="http://docs.oasis-open.org/odata/ns/edmx" Version="4.0">
+    <edmx:Reference Uri="http://docs.oasis-open.org/odata/odata/v4.0/errata03/csd01/complete/vocabularies/Org.OData.Core.V1.xml">
+        <edmx:Include Namespace="Org.OData.Core.V1" Alias="OData" />
+    </edmx:Reference>
+    <edmx:Reference Uri="http://redfish.dmtf.org/schemas/v1/RedfishExtensions_v1.xml">
+        <edmx:Include Namespace="Validation.v1_0_0" Alias="Validation"/>
+        <edmx:Include Namespace="RedfishExtensions.v1_0_0" Alias="Redfish"/>
+    </edmx:Reference>
+    <edmx:Reference Uri="http://redfish.dmtf.org/schemas/v1/Storage_v1.xml">
+        <edmx:Include Namespace="Storage"/>
+        <edmx:Include Namespace="Storage.v1_10_1"/>
+    </edmx:Reference>
+    <edmx:Reference Uri="http://redfish.dmtf.org/schemas/v1/Resource_v1.xml">
+        <edmx:Include Namespace="Resource"/>
+        <edmx:Include Namespace="Resource.v1_0_0"/>
+    </edmx:Reference>
+
+    <edmx:DataServices>
+
+     <Schema xmlns="http://docs.oasis-open.org/odata/ns/edm" Namespace="OemStorage">
+      <Annotation Term="Redfish.OwningEntity" String="OpenBMC"/>
+      </Schema>
+
+         <Schema xmlns="http://docs.oasis-open.org/odata/ns/edm" Namespace="OemStorage.v1_0_0">
+            <Annotation Term="Redfish.OwningEntity" String="OpenBMC"/>
+              <Annotation Term="Redfish.Release" String="1.0"/>
+
+            <ComplexType Name="Oem" BaseType="Resource.OemObject">
+                <Annotation Term="OData.AdditionalProperties" Bool="true" />
+                <Annotation Term="OData.Description" String="OemVolumes Oem properties." />
+                <Annotation Term="OData.AutoExpand"/>
+                <Property Name="OpenBmc" Type="OemStorage.v1_0_0.OpenBmc"/>
+            </ComplexType>
+
+            <ComplexType Name="OpenBmc" BaseType="Resource.OemObject">
+                <Annotation Term="OData.AdditionalProperties" Bool="false" />
+                <Annotation Term="OData.Description" String="OpenBmc ." />
+                <Annotation Term="OData.AutoExpand"/>
+
+                <Property Name="configComplete" Type="Edm.Decimal">
+                    <Annotation Term="OData.Permissions" EnumMember="OData.Permission/ReadWrite"/>
+		    <Annotation Term="OData.Description" String="This indicates whether configuration information is ready."/>
+                    <Annotation Term="OData.LongDescription" String="The value of this property  used to indicateconfiguration information is ready."/>
+                </Property>
+                <Property Name="manageRAIDConfigStatus" Type="Edm.Decimal">	
+                    <Annotation Term="OData.Permissions" EnumMember="OData.Permission/ReadWrite"/>
+                    <Annotation Term="OData.Description" String="The status of calling manageRAIDConfig method."/>
+                    <Annotation Term="OData.LongDescription" String="The value of this property is used to indicate the status of calling manageRAIDConfig method."/>
+                </Property>
+                <Property Name="setRAIDDeleteLDStatus" Type="Edm.Decimal">
+                    <Annotation Term="OData.Permissions" EnumMember="OData.Permission/ReadWrite"/>
+                    <Annotation Term="OData.Description" String="The status of calling setRAIDDelete method."/>
+                    <Annotation Term="OData.LongDescription" String="The value of this property is used to indicate the status of calling setRAIDDelete method."/>
+                </Property>
+            </ComplexType>
+
+        </Schema>
+    </edmx:DataServices>
+</edmx:Edmx>
+
diff --git a/static/redfish/v1/schema/OemVolume_v1.xml b/static/redfish/v1/schema/OemVolume_v1.xml
new file mode 100644
index 00000000..7e52c774
--- /dev/null
+++ b/static/redfish/v1/schema/OemVolume_v1.xml
@@ -0,0 +1,60 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<edmx:Edmx xmlns:edmx="http://docs.oasis-open.org/odata/ns/edmx" Version="4.0">
+    <edmx:Reference Uri="http://docs.oasis-open.org/odata/odata/v4.0/errata03/csd01/complete/vocabularies/Org.OData.Core.V1.xml">
+        <edmx:Include Namespace="Org.OData.Core.V1" Alias="OData" />
+    </edmx:Reference>
+    <edmx:Reference Uri="http://redfish.dmtf.org/schemas/v1/RedfishExtensions_v1.xml">
+        <edmx:Include Namespace="Validation.v1_0_0" Alias="Validation"/>
+        <edmx:Include Namespace="RedfishExtensions.v1_0_0" Alias="Redfish"/>
+    </edmx:Reference>
+    <edmx:Reference Uri="http://redfish.dmtf.org/schemas/v1/Volume_v1.xml">
+        <edmx:Include Namespace="Volume"/>
+        <edmx:Include Namespace="Volume.v1_10_0"/>
+    </edmx:Reference>
+    <edmx:Reference Uri="http://redfish.dmtf.org/schemas/v1/Resource_v1.xml">
+        <edmx:Include Namespace="Resource"/>
+        <edmx:Include Namespace="Resource.v1_0_0"/>
+    </edmx:Reference>
+
+    <edmx:DataServices>
+	   
+     <Schema xmlns="http://docs.oasis-open.org/odata/ns/edm" Namespace="OemVolume">
+      <Annotation Term="Redfish.OwningEntity" String="OpenBMC"/>
+      </Schema>
+
+         <Schema xmlns="http://docs.oasis-open.org/odata/ns/edm" Namespace="OemVolume.v1_0_0">
+            <Annotation Term="Redfish.OwningEntity" String="OpenBMC"/>
+              <Annotation Term="Redfish.Release" String="1.0"/>
+
+            <ComplexType Name="Oem" BaseType="Resource.OemObject">
+                <Annotation Term="OData.AdditionalProperties" Bool="true" />
+                <Annotation Term="OData.Description" String="OemVolumes Oem properties." />
+                <Annotation Term="OData.AutoExpand"/>
+                <Property Name="OpenBmc" Type="OemVolume.v1_0_0.OpenBmc"/>
+            </ComplexType>
+
+            <ComplexType Name="OpenBmc" BaseType="Resource.OemObject">
+                <Annotation Term="OData.AdditionalProperties" Bool="false" />
+		<Annotation Term="OData.Description" String="OpenBmc ." />
+		<Annotation Term="OData.AutoExpand"/>
+
+                <Property Name="pdList" Type="Collection(Edm.Decimal)">
+                    <Annotation Term="OData.Permissions" EnumMember="OData.Permission/ReadWrite"/>
+                    <Annotation Term="OData.Description" String="Physical Drive List."/>
+                    <Annotation Term="OData.LongDescription" String="The value of this property is used to indicate the physical Drive list."/>
+                </Property>
+                <Property Name="SparePdList" Type="Collection(Edm.Decimal)">
+                    <Annotation Term="OData.Permissions" EnumMember="OData.Permission/ReadWrite"/>
+                    <Annotation Term="OData.Description" String="Spare Physical Drive List"/>
+                    <Annotation Term="OData.LongDescription" String="The value of this property is used to indicate the Spare Physical Drive List."/>
+                </Property>
+                <Property Name="LDeviceId" Type="Edm.Decimal">
+                    <Annotation Term="OData.Permissions" EnumMember="OData.Permission/ReadWrite"/>
+                    <Annotation Term="OData.Description" String="Logical Device ID"/>
+                    <Annotation Term="OData.LongDescription" String="The value of this property is used to indicate the Logical Device ID."/>
+                </Property>
+            </ComplexType>
+
+        </Schema>
+    </edmx:DataServices>
+</edmx:Edmx>
-- 
2.34.1

