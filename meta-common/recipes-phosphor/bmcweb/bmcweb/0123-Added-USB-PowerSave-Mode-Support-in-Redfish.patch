From 51707a8a44cd676917eb5b35199891128d110df3 Mon Sep 17 00:00:00 2001
From: Abinaya L <abinayal@ami.com>
Date: Fri, 3 Nov 2023 17:00:37 +0530
Subject: [PATCH 123/123] Added-USB-PowerSave-Mode-Support-in-Redfish

---
 redfish-core/lib/managers.hpp         | 514 +++++++++++++-------------
 static/redfish/v1/$metadata/index.xml |   4 +
 2 files changed, 261 insertions(+), 257 deletions(-)

diff --git a/redfish-core/lib/managers.hpp b/redfish-core/lib/managers.hpp
index 3ae1e8e1..049a9838 100644
--- a/redfish-core/lib/managers.hpp
+++ b/redfish-core/lib/managers.hpp
@@ -31,6 +31,7 @@
 
 #include <boost/system/error_code.hpp>
 #include <boost/url/format.hpp>
+#include <led.hpp>
 #include <sdbusplus/asio/property.hpp>
 #include <sdbusplus/unpack_properties.hpp>
 #include <task.hpp>
@@ -2219,287 +2220,286 @@ inline void
     });
 }
 
-inline void requestRoutesManager(App& app)
+inline void handleManagersInstanceGet(
+    App& app, const crow::Request& req,
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
 {
     std::string uuid = persistent_data::getConfig().systemUuid;
 
-    BMCWEB_ROUTE(app, "/redfish/v1/Managers/bmc/")
-        .privileges(redfish::privileges::getManager)
-        .methods(boost::beast::http::verb::get)(
-            [&app, uuid](const crow::Request& req,
-                         const std::shared_ptr<bmcweb::AsyncResp>& asyncResp) {
-        if (!redfish::setUpRedfishRoute(app, req, asyncResp))
-        {
-            return;
-        }
-        asyncResp->res.jsonValue["@odata.id"] = "/redfish/v1/Managers/bmc";
-        asyncResp->res.jsonValue["@odata.type"] = "#Manager.v1_14_0.Manager";
-        asyncResp->res.jsonValue["Id"] = "bmc";
-        asyncResp->res.jsonValue["Name"] = "OpenBmc Manager";
-        asyncResp->res.jsonValue["Description"] =
-            "Baseboard Management Controller";
-        asyncResp->res.jsonValue["PowerState"] = "On";
-
-        asyncResp->res.jsonValue["ManagerType"] = "BMC";
-        asyncResp->res.jsonValue["UUID"] = systemd_utils::getUuid();
-        asyncResp->res.jsonValue["ServiceEntryPointUUID"] = uuid;
-        asyncResp->res.jsonValue["Model"] = "OpenBmc"; // TODO(ed), get model
-
-        asyncResp->res.jsonValue["LogServices"]["@odata.id"] =
-            "/redfish/v1/Managers/bmc/LogServices";
-        asyncResp->res.jsonValue["NetworkProtocol"]["@odata.id"] =
-            "/redfish/v1/Managers/bmc/NetworkProtocol";
-        asyncResp->res.jsonValue["EthernetInterfaces"]["@odata.id"] =
-            "/redfish/v1/Managers/bmc/EthernetInterfaces";
+    if (!redfish::setUpRedfishRoute(app, req, asyncResp))
+    {
+        return;
+    }
+    asyncResp->res.jsonValue["@odata.id"] = "/redfish/v1/Managers/bmc";
+    asyncResp->res.jsonValue["@odata.type"] = "#Manager.v1_14_0.Manager";
+    asyncResp->res.jsonValue["Id"] = "bmc";
+    asyncResp->res.jsonValue["Name"] = "OpenBmc Manager";
+    asyncResp->res.jsonValue["Description"] = "Baseboard Management Controller";
+    asyncResp->res.jsonValue["PowerState"] = "On";
+
+    asyncResp->res.jsonValue["ManagerType"] = "BMC";
+    asyncResp->res.jsonValue["UUID"] = systemd_utils::getUuid();
+    asyncResp->res.jsonValue["ServiceEntryPointUUID"] = uuid;
+    asyncResp->res.jsonValue["Model"] = "OpenBmc"; // TODO(ed), get model
+
+    asyncResp->res.jsonValue["LogServices"]["@odata.id"] =
+        "/redfish/v1/Managers/bmc/LogServices";
+    asyncResp->res.jsonValue["NetworkProtocol"]["@odata.id"] =
+        "/redfish/v1/Managers/bmc/NetworkProtocol";
+    asyncResp->res.jsonValue["EthernetInterfaces"]["@odata.id"] =
+        "/redfish/v1/Managers/bmc/EthernetInterfaces";
 
 #ifdef BMCWEB_ENABLE_VM_NBDPROXY
-        asyncResp->res.jsonValue["VirtualMedia"]["@odata.id"] =
-            "/redfish/v1/Managers/bmc/VirtualMedia";
+    asyncResp->res.jsonValue["VirtualMedia"]["@odata.id"] =
+        "/redfish/v1/Managers/bmc/VirtualMedia";
 #endif // BMCWEB_ENABLE_VM_NBDPROXY
 
-        // default oem data
-        nlohmann::json& oem = asyncResp->res.jsonValue["Oem"];
-        nlohmann::json& oemOpenbmc = oem["OpenBmc"];
-        nlohmann::json& oemIntel = oem["Intel"];
-        oemIntel["@odata.type"] = "#OemManager.Intel";
-        oemIntel["@odata.id"] = "/redfish/v1/Managers/bmc#/Oem/Intel";
-        oemIntel["NodeManager"] = {
-            {"@odata.id", "/redfish/v1/Managers/bmc/Oem/Intel/NodeManager"}};
-
-        oem["@odata.type"] = "#OemManager.Oem";
-        oem["@odata.id"] = "/redfish/v1/Managers/bmc#/Oem";
-        oemOpenbmc["@odata.type"] = "#OemManager.OpenBmc";
-        oemOpenbmc["@odata.id"] = "/redfish/v1/Managers/bmc#/Oem/OpenBmc";
-        oemOpenbmc["@odata.id"] = "/redfish/v1/Managers/bmc/Oem/OpenBmc/Jpeg";
-
-        nlohmann::json::object_t certificates;
-        certificates["@odata.id"] =
-            "/redfish/v1/Managers/bmc/Truststore/Certificates";
-        oemOpenbmc["Certificates"] = std::move(certificates);
-
-        // Manager.Reset (an action) can be many values, OpenBMC only
-        // supports BMC reboot.
-        nlohmann::json& managerReset =
-            asyncResp->res.jsonValue["Actions"]["#Manager.Reset"];
-        managerReset["target"] =
-            "/redfish/v1/Managers/bmc/Actions/Manager.Reset";
-        managerReset["@Redfish.ActionInfo"] =
-            "/redfish/v1/Managers/bmc/ResetActionInfo";
+    // default oem data
+    nlohmann::json& oem = asyncResp->res.jsonValue["Oem"];
+    nlohmann::json& oemOpenbmc = oem["OpenBmc"];
+    nlohmann::json& oemIntel = oem["Intel"];
+    oemIntel["@odata.type"] = "#OemManager.Intel";
+    oemIntel["@odata.id"] = "/redfish/v1/Managers/bmc#/Oem/Intel";
+    oemIntel["NodeManager"] = {
+        {"@odata.id", "/redfish/v1/Managers/bmc/Oem/Intel/NodeManager"}};
+
+    oem["@odata.type"] = "#OemManager.Oem";
+    oem["@odata.id"] = "/redfish/v1/Managers/bmc#/Oem";
+    oemOpenbmc["@odata.type"] = "#OemManager.OpenBmc";
+    oemOpenbmc["@odata.id"] = "/redfish/v1/Managers/bmc#/Oem/OpenBmc";
+    oemOpenbmc["@odata.id"] = "/redfish/v1/Managers/bmc/Oem/OpenBmc/Jpeg";
+
+    nlohmann::json::object_t certificates;
+    certificates["@odata.id"] =
+        "/redfish/v1/Managers/bmc/Truststore/Certificates";
+    oemOpenbmc["Certificates"] = std::move(certificates);
+
+    // Manager.Reset (an action) can be many values, OpenBMC only
+    // supports BMC reboot.
+    nlohmann::json& managerReset =
+        asyncResp->res.jsonValue["Actions"]["#Manager.Reset"];
+    managerReset["target"] = "/redfish/v1/Managers/bmc/Actions/Manager.Reset";
+    managerReset["@Redfish.ActionInfo"] =
+        "/redfish/v1/Managers/bmc/ResetActionInfo";
+
+    // ResetToDefaults (Factory Reset) has values like
+    // PreserveNetworkAndUsers and PreserveNetwork that aren't supported
+    // on OpenBMC
+    nlohmann::json& resetToDefaults =
+        asyncResp->res.jsonValue["Actions"]["#Manager.ResetToDefaults"];
+    resetToDefaults["target"] =
+        "/redfish/v1/Managers/bmc/Actions/Manager.ResetToDefaults";
+    resetToDefaults["ResetType@Redfish.AllowableValues"] = {
+        "ResetAll", "ResetToDefaultButKeepReservedSettings"};
+
+    std::pair<std::string, std::string> redfishDateTimeOffset =
+        crow::utility::getDateTimeOffsetNow();
+
+    asyncResp->res.jsonValue["DateTime"] = redfishDateTimeOffset.first;
+    asyncResp->res.jsonValue["DateTimeLocalOffset"] =
+        redfishDateTimeOffset.second;
+
+    // TODO (Gunnar): Remove these one day since moved to ComputerSystem
+    // Still used by OCP profiles
+    // https://github.com/opencomputeproject/OCP-Profiles/issues/23
+    // Fill in SerialConsole info
+    asyncResp->res.jsonValue["SerialConsole"]["ServiceEnabled"] = true;
+    asyncResp->res.jsonValue["SerialConsole"]["MaxConcurrentSessions"] = 15;
+    asyncResp->res.jsonValue["SerialConsole"]["ConnectTypesSupported"] = {
+        "IPMI", "SSH"};
+
+    // Fill in CommandShell info
+    asyncResp->res.jsonValue["CommandShell"]["ServiceEnabled"] = true;
+    asyncResp->res.jsonValue["CommandShell"]["MaxConcurrentSessions"] = 4;
+    asyncResp->res.jsonValue["CommandShell"]["ConnectTypesSupported"] = {
+        "SSH", "IPMI"};
+
+    if constexpr (!bmcwebEnableMultiHost)
+    {
+        asyncResp->res.jsonValue["Links"]["ManagerForServers@odata.count"] = 1;
 
-        // ResetToDefaults (Factory Reset) has values like
-        // PreserveNetworkAndUsers and PreserveNetwork that aren't supported
-        // on OpenBMC
-        nlohmann::json& resetToDefaults =
-            asyncResp->res.jsonValue["Actions"]["#Manager.ResetToDefaults"];
-        resetToDefaults["target"] =
-            "/redfish/v1/Managers/bmc/Actions/Manager.ResetToDefaults";
-        resetToDefaults["ResetType@Redfish.AllowableValues"] = {
-            "ResetAll", "ResetToDefaultButKeepReservedSettings"};
-
-        std::pair<std::string, std::string> redfishDateTimeOffset =
-            crow::utility::getDateTimeOffsetNow();
-
-        asyncResp->res.jsonValue["DateTime"] = redfishDateTimeOffset.first;
-        asyncResp->res.jsonValue["DateTimeLocalOffset"] =
-            redfishDateTimeOffset.second;
-
-        // TODO (Gunnar): Remove these one day since moved to ComputerSystem
-        // Still used by OCP profiles
-        // https://github.com/opencomputeproject/OCP-Profiles/issues/23
-        // Fill in SerialConsole info
-        asyncResp->res.jsonValue["SerialConsole"]["ServiceEnabled"] = true;
-        asyncResp->res.jsonValue["SerialConsole"]["MaxConcurrentSessions"] = 15;
-        asyncResp->res.jsonValue["SerialConsole"]["ConnectTypesSupported"] = {
-            "IPMI", "SSH"};
-
-        // Fill in CommandShell info
-        asyncResp->res.jsonValue["CommandShell"]["ServiceEnabled"] = true;
-        asyncResp->res.jsonValue["CommandShell"]["MaxConcurrentSessions"] = 4;
-        asyncResp->res.jsonValue["CommandShell"]["ConnectTypesSupported"] = {
-            "SSH", "IPMI"};
-
-        if constexpr (!bmcwebEnableMultiHost)
-        {
-            asyncResp->res.jsonValue["Links"]["ManagerForServers@odata.count"] =
-                1;
-
-            nlohmann::json::array_t managerForServers;
-            nlohmann::json::object_t manager;
-            manager["@odata.id"] = "/redfish/v1/Systems/system";
-            managerForServers.emplace_back(std::move(manager));
-
-            asyncResp->res.jsonValue["Links"]["ManagerForServers"] =
-                std::move(managerForServers);
-        }
-        if constexpr (bmcwebEnableHealthPopulate)
-        {
-            auto health = std::make_shared<HealthPopulate>(asyncResp);
-            health->isManagersHealth = true;
-            health->populate();
-        }
-
-        sw_util::populateSoftwareInformation(asyncResp, sw_util::bmcPurpose,
-                                             "FirmwareVersion", true);
-
-        managerGetLastResetTime(asyncResp);
-        getLocationIndicatorActive(asyncResp);
-
-        // ManagerDiagnosticData is added for all BMCs.
-        nlohmann::json& managerDiagnosticData =
-            asyncResp->res.jsonValue["ManagerDiagnosticData"];
-        managerDiagnosticData["@odata.id"] =
-            "/redfish/v1/Managers/bmc/ManagerDiagnosticData";
-
-        // #ifdef BMCWEB_ENABLE_REDFISH_OEM_MANAGER_FAN_DATA
-        //         auto pids = std::make_shared<GetPIDValues>(asyncResp);
-        //         pids->run();
-        // #endif
-
-        getMainChassisId(asyncResp,
-                         [](const std::string& chassisId,
-                            const std::shared_ptr<bmcweb::AsyncResp>& aRsp) {
-            aRsp->res.jsonValue["Links"]["ManagerForChassis@odata.count"] = 1;
-            nlohmann::json::array_t managerForChassis;
-            nlohmann::json::object_t managerObj;
-            boost::urls::url chassiUrl =
-                boost::urls::format("/redfish/v1/Chassis/{}", chassisId);
-            managerObj["@odata.id"] = chassiUrl;
-            managerForChassis.emplace_back(std::move(managerObj));
-            aRsp->res.jsonValue["Links"]["ManagerForChassis"] =
-                std::move(managerForChassis);
-            aRsp->res.jsonValue["Links"]["ManagerInChassis"]["@odata.id"] =
-                chassiUrl;
-        });
+        nlohmann::json::array_t managerForServers;
+        nlohmann::json::object_t manager;
+        manager["@odata.id"] = "/redfish/v1/Systems/system";
+        managerForServers.emplace_back(std::move(manager));
 
-        sdbusplus::asio::getProperty<double>(
-            *crow::connections::systemBus, "org.freedesktop.systemd1",
-            "/org/freedesktop/systemd1", "org.freedesktop.systemd1.Manager",
-            "Progress",
-            [asyncResp](const boost::system::error_code& ec, double val) {
-            if (ec)
-            {
-                BMCWEB_LOG_ERROR("Error while getting progress");
-                messages::internalError(asyncResp->res);
-                return;
-            }
-            if (val < 1.0)
-            {
-                asyncResp->res.jsonValue["Status"]["Health"] = "OK";
-                asyncResp->res.jsonValue["Status"]["State"] = "Starting";
-                return;
-            }
-            checkForQuiesced(asyncResp);
-        });
+        asyncResp->res.jsonValue["Links"]["ManagerForServers"] =
+            std::move(managerForServers);
+    }
+    if constexpr (bmcwebEnableHealthPopulate)
+    {
+        auto health = std::make_shared<HealthPopulate>(asyncResp);
+        health->isManagersHealth = true;
+        health->populate();
+    }
 
-        constexpr std::array<std::string_view, 1> interfaces = {
-            "xyz.openbmc_project.Inventory.Item.Bmc"};
-        dbus::utility::getSubTree(
-            "/xyz/openbmc_project/inventory", 0, interfaces,
-            [asyncResp](
-                const boost::system::error_code& ec,
-                const dbus::utility::MapperGetSubTreeResponse& subtree) {
-            if (ec)
-            {
-                BMCWEB_LOG_DEBUG("D-Bus response error on GetSubTree {}", ec);
-                return;
-            }
-            if (subtree.empty())
-            {
-                BMCWEB_LOG_DEBUG("Can't find bmc D-Bus object!");
-                return;
-            }
-            // Assume only 1 bmc D-Bus object
-            // Throw an error if there is more than 1
-            if (subtree.size() > 1)
-            {
-                BMCWEB_LOG_DEBUG("Found more than 1 bmc D-Bus object!");
-                messages::internalError(asyncResp->res);
-                return;
-            }
+    sw_util::populateSoftwareInformation(asyncResp, sw_util::bmcPurpose,
+                                         "FirmwareVersion", true);
+
+    managerGetLastResetTime(asyncResp);
+    getLocationIndicatorActive(asyncResp);
+
+    // ManagerDiagnosticData is added for all BMCs.
+    nlohmann::json& managerDiagnosticData =
+        asyncResp->res.jsonValue["ManagerDiagnosticData"];
+    managerDiagnosticData["@odata.id"] =
+        "/redfish/v1/Managers/bmc/ManagerDiagnosticData";
+
+    // #ifdef BMCWEB_ENABLE_REDFISH_OEM_MANAGER_FAN_DATA
+    //         auto pids = std::make_shared<GetPIDValues>(asyncResp);
+    //         pids->run();
+    // #endif
+
+    getMainChassisId(asyncResp,
+                     [](const std::string& chassisId,
+                        const std::shared_ptr<bmcweb::AsyncResp>& aRsp) {
+        aRsp->res.jsonValue["Links"]["ManagerForChassis@odata.count"] = 1;
+        nlohmann::json::array_t managerForChassis;
+        nlohmann::json::object_t managerObj;
+        boost::urls::url chassiUrl =
+            boost::urls::format("/redfish/v1/Chassis/{}", chassisId);
+        managerObj["@odata.id"] = chassiUrl;
+        managerForChassis.emplace_back(std::move(managerObj));
+        aRsp->res.jsonValue["Links"]["ManagerForChassis"] =
+            std::move(managerForChassis);
+        aRsp->res.jsonValue["Links"]["ManagerInChassis"]["@odata.id"] =
+            chassiUrl;
+    });
 
-            if (subtree[0].first.empty() || subtree[0].second.size() != 1)
-            {
-                BMCWEB_LOG_DEBUG("Error getting bmc D-Bus object!");
-                messages::internalError(asyncResp->res);
-                return;
-            }
+    sdbusplus::asio::getProperty<double>(
+        *crow::connections::systemBus, "org.freedesktop.systemd1",
+        "/org/freedesktop/systemd1", "org.freedesktop.systemd1.Manager",
+        "Progress",
+        [asyncResp](const boost::system::error_code& ec, double val) {
+        if (ec)
+        {
+            BMCWEB_LOG_ERROR("Error while getting progress");
+            messages::internalError(asyncResp->res);
+            return;
+        }
+        if (val < 1.0)
+        {
+            asyncResp->res.jsonValue["Status"]["Health"] = "OK";
+            asyncResp->res.jsonValue["Status"]["State"] = "Starting";
+            return;
+        }
+        checkForQuiesced(asyncResp);
+    });
 
-            const std::string& path = subtree[0].first;
-            const std::string& connectionName = subtree[0].second[0].first;
+    constexpr std::array<std::string_view, 1> interfaces = {
+        "xyz.openbmc_project.Inventory.Item.Bmc"};
+    dbus::utility::getSubTree(
+        "/xyz/openbmc_project/inventory", 0, interfaces,
+        [asyncResp](const boost::system::error_code& ec,
+                    const dbus::utility::MapperGetSubTreeResponse& subtree) {
+        if (ec)
+        {
+            BMCWEB_LOG_DEBUG("D-Bus response error on GetSubTree {}", ec);
+            return;
+        }
+        if (subtree.empty())
+        {
+            BMCWEB_LOG_DEBUG("Can't find bmc D-Bus object!");
+            return;
+        }
+        // Assume only 1 bmc D-Bus object
+        // Throw an error if there is more than 1
+        if (subtree.size() > 1)
+        {
+            BMCWEB_LOG_DEBUG("Found more than 1 bmc D-Bus object!");
+            messages::internalError(asyncResp->res);
+            return;
+        }
+
+        if (subtree[0].first.empty() || subtree[0].second.size() != 1)
+        {
+            BMCWEB_LOG_DEBUG("Error getting bmc D-Bus object!");
+            messages::internalError(asyncResp->res);
+            return;
+        }
 
-            for (const auto& interfaceName : subtree[0].second[0].second)
+        const std::string& path = subtree[0].first;
+        const std::string& connectionName = subtree[0].second[0].first;
+
+        for (const auto& interfaceName : subtree[0].second[0].second)
+        {
+            if (interfaceName ==
+                "xyz.openbmc_project.Inventory.Decorator.Asset")
             {
-                if (interfaceName ==
-                    "xyz.openbmc_project.Inventory.Decorator.Asset")
-                {
-                    sdbusplus::asio::getAllProperties(
-                        *crow::connections::systemBus, connectionName, path,
-                        "xyz.openbmc_project.Inventory.Decorator.Asset",
-                        [asyncResp](const boost::system::error_code& ec2,
-                                    const dbus::utility::DBusPropertiesMap&
-                                        propertiesList) {
-                        if (ec2)
-                        {
-                            BMCWEB_LOG_DEBUG("Can't get bmc asset!");
-                            return;
-                        }
+                sdbusplus::asio::getAllProperties(
+                    *crow::connections::systemBus, connectionName, path,
+                    "xyz.openbmc_project.Inventory.Decorator.Asset",
+                    [asyncResp](const boost::system::error_code& ec2,
+                                const dbus::utility::DBusPropertiesMap&
+                                    propertiesList) {
+                    if (ec2)
+                    {
+                        BMCWEB_LOG_DEBUG("Can't get bmc asset!");
+                        return;
+                    }
 
-                        const std::string* partNumber = nullptr;
-                        const std::string* serialNumber = nullptr;
-                        const std::string* manufacturer = nullptr;
-                        const std::string* model = nullptr;
-                        const std::string* sparePartNumber = nullptr;
+                    const std::string* partNumber = nullptr;
+                    const std::string* serialNumber = nullptr;
+                    const std::string* manufacturer = nullptr;
+                    const std::string* model = nullptr;
+                    const std::string* sparePartNumber = nullptr;
 
-                        const bool success = sdbusplus::unpackPropertiesNoThrow(
-                            dbus_utils::UnpackErrorPrinter(), propertiesList,
-                            "PartNumber", partNumber, "SerialNumber",
-                            serialNumber, "Manufacturer", manufacturer, "Model",
-                            model, "SparePartNumber", sparePartNumber);
+                    const bool success = sdbusplus::unpackPropertiesNoThrow(
+                        dbus_utils::UnpackErrorPrinter(), propertiesList,
+                        "PartNumber", partNumber, "SerialNumber", serialNumber,
+                        "Manufacturer", manufacturer, "Model", model,
+                        "SparePartNumber", sparePartNumber);
 
-                        if (!success)
-                        {
-                            messages::internalError(asyncResp->res);
-                            return;
-                        }
+                    if (!success)
+                    {
+                        messages::internalError(asyncResp->res);
+                        return;
+                    }
 
-                        if (partNumber != nullptr)
-                        {
-                            asyncResp->res.jsonValue["PartNumber"] =
-                                *partNumber;
-                        }
+                    if (partNumber != nullptr)
+                    {
+                        asyncResp->res.jsonValue["PartNumber"] = *partNumber;
+                    }
 
-                        if (serialNumber != nullptr)
-                        {
-                            asyncResp->res.jsonValue["SerialNumber"] =
-                                *serialNumber;
-                        }
+                    if (serialNumber != nullptr)
+                    {
+                        asyncResp->res.jsonValue["SerialNumber"] =
+                            *serialNumber;
+                    }
 
-                        if (manufacturer != nullptr)
-                        {
-                            asyncResp->res.jsonValue["Manufacturer"] =
-                                *manufacturer;
-                        }
+                    if (manufacturer != nullptr)
+                    {
+                        asyncResp->res.jsonValue["Manufacturer"] =
+                            *manufacturer;
+                    }
 
-                        if (model != nullptr)
-                        {
-                            asyncResp->res.jsonValue["Model"] = *model;
-                        }
+                    if (model != nullptr)
+                    {
+                        asyncResp->res.jsonValue["Model"] = *model;
+                    }
 
-                        if (sparePartNumber != nullptr)
-                        {
-                            asyncResp->res.jsonValue["SparePartNumber"] =
-                                *sparePartNumber;
-                        }
-                    });
-                }
-                else if (interfaceName ==
-                         "xyz.openbmc_project.Inventory.Decorator.LocationCode")
-                {
-                    getLocation(asyncResp, connectionName, path);
-                }
+                    if (sparePartNumber != nullptr)
+                    {
+                        asyncResp->res.jsonValue["SparePartNumber"] =
+                            *sparePartNumber;
+                    }
+                });
             }
-        });
+            else if (interfaceName ==
+                     "xyz.openbmc_project.Inventory.Decorator.LocationCode")
+            {
+                getLocation(asyncResp, connectionName, path);
+            }
+        }
     });
+}
+
+inline void requestRoutesManager(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Managers/bmc/")
+        .privileges(redfish::privileges::getManager)
+        .methods(boost::beast::http::verb::get)(
+            std::bind_front(handleManagersInstanceGet, std::ref(app)));
 
     BMCWEB_ROUTE(app, "/redfish/v1/Managers/bmc/")
         .privileges(redfish::privileges::patchManager)
diff --git a/static/redfish/v1/$metadata/index.xml b/static/redfish/v1/$metadata/index.xml
index 72397ad7..d710f65a 100644
--- a/static/redfish/v1/$metadata/index.xml
+++ b/static/redfish/v1/$metadata/index.xml
@@ -3468,4 +3468,8 @@
         <edmx:Include Namespace="OemDrive"/>
         <edmx:Include Namespace="OemDrive.v1_0_0"/>
     </edmx:Reference>
+    <edmx:Reference Uri="/redfish/v1/schema/AMIManager_v1.xml">
+        <edmx:Include Namespace="AMIManager"/>
+        <edmx:Include Namespace="AMIManager.v1_0_0"/>
+    </edmx:Reference>
 </edmx:Edmx>
-- 
2.25.1

