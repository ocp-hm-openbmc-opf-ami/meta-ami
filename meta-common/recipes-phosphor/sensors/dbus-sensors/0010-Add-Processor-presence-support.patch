From 0c77a6bef200896bfaa0977b987d7c6ecd60fe9a Mon Sep 17 00:00:00 2001
From: vipinc <vipinc@ami.com>
Date: Sun, 16 Jul 2023 16:47:57 +0530
Subject: [PATCH] Dbus-sensor patch recreate : Add Processor presence support

This patch consist of dbus-sensors commits for below MR

1)Add processor presence discrete sensor
https://git.ami.com/core/oe/common/meta-ami/-/merge_requests/83/diffs#69c3f1c5c8fc44f317d6232a84fba0b0b5873a9b

2)Add discrete sensor event log support
https://git.ami.com/core/oe/common/meta-ami/-/merge_requests/165/diffs#d244e2d4b3c54b7d917649a814742269a441fc50

3)Align source structure away from anit-patterns
https://github.com/openbmc/docs/blob/master/anti-patterns.md#placing-internal-headers-in-a-parallel-subtree

Signed-off-by: vipinc <vipinc@ami.com>
---
 meson_options.txt                             |   2 +
 service_files/meson.build                     |   1 +
 ...yz.openbmc_project.processorstatus.service |  13 ++
 src/ProcessorStatus.cpp                       | 126 +++++++++++++
 src/ProcessorStatus.hpp                       |  59 ++++++
 src/ProcessorStatusMain.cpp                   | 174 ++++++++++++++++++
 src/Utils.cpp                                 |  39 ++++
 src/Utils.hpp                                 |  21 +++
 src/meson.build                               |  16 ++
 9 files changed, 451 insertions(+)
 create mode 100644 service_files/xyz.openbmc_project.processorstatus.service
 create mode 100644 src/ProcessorStatus.cpp
 create mode 100644 src/ProcessorStatus.hpp
 create mode 100644 src/ProcessorStatusMain.cpp

diff --git a/meson_options.txt b/meson_options.txt
index d6a8b96..5e6fa77 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -12,3 +12,5 @@ option('external', type: 'feature', value: 'enabled', description: 'Enable Exter
 option('tests', type: 'feature', value: 'enabled', description: 'Build tests.',)
 option('validate-unsecure-feature', type : 'feature', value : 'disabled', description : 'Enables unsecure features required by validation. Note: mustbe turned off for production images.',)
 option('insecure-sensor-override', type : 'feature', value : 'disabled', description : 'Enables Sensor override feature without any check.',)
+option('procstatus', type: 'feature', value: 'enabled', description: 'Enable processor status sensor.',)
+
diff --git a/service_files/meson.build b/service_files/meson.build
index 5f5b78c..f7ccd6d 100644
--- a/service_files/meson.build
+++ b/service_files/meson.build
@@ -10,6 +10,7 @@ unit_files = [
     ['nvme', 'xyz.openbmc_project.nvmesensor.service'],
     ['psu', 'xyz.openbmc_project.psusensor.service'],
     ['external', 'xyz.openbmc_project.externalsensor.service'],
+    ['procstatus', 'xyz.openbmc_project.processorstatus.service'],
 ]
 
 foreach tuple : unit_files
diff --git a/service_files/xyz.openbmc_project.processorstatus.service b/service_files/xyz.openbmc_project.processorstatus.service
new file mode 100644
index 0000000..faf5123
--- /dev/null
+++ b/service_files/xyz.openbmc_project.processorstatus.service
@@ -0,0 +1,13 @@
+[Unit]
+Description=Processor Status
+StopWhenUnneeded=false
+Requires=xyz.openbmc_project.EntityManager.service
+After=xyz.openbmc_project.EntityManager.service
+
+[Service]
+Restart=always
+RestartSec=5
+ExecStart=/usr/bin/processorstatus
+
+[Install]
+WantedBy=multi-user.target
diff --git a/src/ProcessorStatus.cpp b/src/ProcessorStatus.cpp
new file mode 100644
index 0000000..514488a
--- /dev/null
+++ b/src/ProcessorStatus.cpp
@@ -0,0 +1,126 @@
+#include <unistd.h>
+
+#include <ProcessorStatus.hpp>
+
+#include <exception>
+#include <fstream>
+#include <iostream>
+#include <optional>
+#include <string>
+#include <vector>
+
+ProcessorStatus::ProcessorStatus(
+    sdbusplus::asio::object_server& objectServer,
+    std::shared_ptr<sdbusplus::asio::connection>& conn,
+    boost::asio::io_context& io, const std::string& sensorName,
+    const std::string& gpioName, const std::string& sensorConfiguration) :
+    ItemInterface(
+        static_cast<sdbusplus::bus::bus&>(*conn),
+        ("/xyz/openbmc_project/sensors/cpu/" + escapeName(sensorName)).c_str(),
+        ItemInterface::action::defer_emit),
+    std::enable_shared_from_this<ProcessorStatus>(),
+    name(escapeName(sensorName)), gpio(gpioName), objServer(objectServer),
+    procPresentEvent(io)
+{
+    sensorInterface = objectServer.add_interface(
+        ("/xyz/openbmc_project/sensors/cpu/" + escapeName(sensorName)).c_str(),
+        CpuInterface::interface);
+
+    fs::path p(sensorConfiguration);
+    AssociationList assocs = {};
+    assocs.emplace_back(
+        std::make_tuple("chassis", "all_sensors", p.parent_path().string()));
+    sdbusplus::xyz::openbmc_project::Association::server::Definitions::
+        associations(assocs);
+
+    if (!sensorInterface->initialize())
+    {
+        std::cerr << "error initializing sensor interface\n";
+    }
+    setupEvent(conn, gpioName, procPresentLine, procPresentEvent);
+}
+
+ProcessorStatus::~ProcessorStatus()
+{
+    objServer.remove_interface(sensorInterface);
+}
+
+bool ProcessorStatus::setupEvent(
+    std::shared_ptr<sdbusplus::asio::connection>& conn,
+    const std::string& procGpioName, gpiod::line& gpioLine,
+    boost::asio::posix::stream_descriptor& gpioEventDescriptor)
+{
+    // Find the GPIO line
+    gpioLine = gpiod::find_line(procGpioName);
+    if (!gpioLine)
+    {
+        std::cerr << "Failed to find the line\n";
+
+        return false;
+    }
+
+    try
+    {
+        gpioLine.request({"proc-sensor", gpiod::line_request::EVENT_BOTH_EDGES,
+                          gpiod::line_request::FLAG_ACTIVE_LOW});
+    }
+    catch (std::exception&)
+    {
+        std::cerr << "Failed to request events\n";
+        return false;
+    }
+
+    bool state = (gpioLine.get_value() == 1);
+    std::vector<std::string> logData;
+    sdbusplus::xyz::openbmc_project::Inventory::server::Item::present(state);
+
+    int gpioLineFd = gpioLine.event_get_fd();
+    if (gpioLineFd < 0)
+    {
+        std::cerr << "Failed to get fd\n";
+        return false;
+    }
+
+    gpioEventDescriptor.assign(gpioLineFd);
+
+    logData.push_back(name);
+    logData.push_back("PresenceDetected");
+    logData.push_back(processorPath + name);
+    logData.push_back("SensorProcessorPresence");
+    if (state)
+    {
+        addSelEntry(conn, logData, procPresence, state);
+    }
+
+    monitor(conn, logData, procPresence, gpioEventDescriptor, gpioLine);
+
+    return true;
+}
+
+void ProcessorStatus::monitor(
+    std::shared_ptr<sdbusplus::asio::connection>& conn,
+    const std::vector<std::string>& logData,
+    const std::vector<uint8_t> procPresence,
+    boost::asio::posix::stream_descriptor& event, gpiod::line& line)
+{
+
+    event.async_wait(
+        boost::asio::posix::stream_descriptor::wait_read,
+        [this, &conn, &event, &line, &logData,
+         &procPresence](const boost::system::error_code ec) {
+            if (ec)
+            {
+                std::cerr << " fd handler error: " << ec.message() << "\n";
+                return;
+            }
+            gpiod::line_event lineEvent = line.event_read();
+            sdbusplus::xyz::openbmc_project::Inventory::server::Item::present(
+                lineEvent.event_type == gpiod::line_event::FALLING_EDGE);
+
+            addSelEntry(conn, logData, procPresence,
+                        lineEvent.event_type ==
+                            gpiod::line_event::FALLING_EDGE);
+            // Start monitoring for next event
+            monitor(conn, logData, procPresence, event, line);
+        });
+}
diff --git a/src/ProcessorStatus.hpp b/src/ProcessorStatus.hpp
new file mode 100644
index 0000000..71f8013
--- /dev/null
+++ b/src/ProcessorStatus.hpp
@@ -0,0 +1,59 @@
+#pragma once
+
+#include <Utils.hpp>
+#include <boost/asio/deadline_timer.hpp>
+#include <boost/asio/io_service.hpp>
+#include <boost/asio/posix/stream_descriptor.hpp>
+#include <boost/asio/streambuf.hpp>
+#include <gpiod.hpp>
+#include <sdbusplus/asio/object_server.hpp>
+#include <xyz/openbmc_project/Association/Definitions/server.hpp>
+#include <xyz/openbmc_project/Inventory/Item/Cpu/server.hpp>
+#include <xyz/openbmc_project/Inventory/Item/server.hpp>
+
+#include <memory>
+#include <optional>
+#include <stdexcept>
+#include <string>
+#include <vector>
+
+namespace fs = std::filesystem;
+
+using ItemInterface = sdbusplus::server::object::object<
+    sdbusplus::xyz::openbmc_project::Inventory::server::Item,
+    sdbusplus::xyz::openbmc_project::Association::server::Definitions>;
+
+using CpuInterface =
+    sdbusplus::xyz::openbmc_project::Inventory::Item::server::Cpu;
+
+class ProcessorStatus :
+    public ItemInterface,
+    public std::enable_shared_from_this<ProcessorStatus>
+{
+  public:
+    ProcessorStatus(sdbusplus::asio::object_server& objectServer,
+                    std::shared_ptr<sdbusplus::asio::connection>& conn,
+                    boost::asio::io_context& io, const std::string& sensorName,
+                    const std::string& gpioName,
+                    const std::string& sensorConfiguration);
+    ~ProcessorStatus() override;
+
+    std::string name;
+    std::string gpio;
+
+  private:
+    sdbusplus::asio::object_server& objServer;
+    std::shared_ptr<sdbusplus::asio::dbus_interface> sensorInterface;
+    std::shared_ptr<sdbusplus::asio::dbus_interface> association;
+    // GPIO Lines and Event Descriptors
+    gpiod::line procPresentLine;
+    boost::asio::posix::stream_descriptor procPresentEvent;
+    bool setupEvent(std::shared_ptr<sdbusplus::asio::connection>& conn,
+                    const std::string& gpioName, gpiod::line& gpioLine,
+                    boost::asio::posix::stream_descriptor& gpioEventDescriptor);
+    void monitor(std::shared_ptr<sdbusplus::asio::connection>& conn,
+                 const std::vector<std::string>& logData,
+                 const std::vector<uint8_t> procPresence,
+                 boost::asio::posix::stream_descriptor& event,
+                 gpiod::line& line);
+};
diff --git a/src/ProcessorStatusMain.cpp b/src/ProcessorStatusMain.cpp
new file mode 100644
index 0000000..c02b1f4
--- /dev/null
+++ b/src/ProcessorStatusMain.cpp
@@ -0,0 +1,174 @@
+#include <ProcessorStatus.hpp>
+#include <VariantVisitors.hpp>
+#include <boost/algorithm/string/case_conv.hpp>
+#include <boost/algorithm/string/predicate.hpp>
+#include <boost/algorithm/string/replace.hpp>
+#include <boost/container/flat_set.hpp>
+#include <sdbusplus/bus/match.hpp>
+
+#include <functional>
+#include <memory>
+#include <optional>
+#include <regex>
+#include <string>
+#include <variant>
+#include <vector>
+
+static constexpr const char* sensorType = "Cpustatus";
+
+void createSensors(
+    boost::asio::io_context& io, sdbusplus::asio::object_server& objectServer,
+    boost::container::flat_map<std::string, std::shared_ptr<ProcessorStatus>>&
+        sensors,
+    std::shared_ptr<sdbusplus::asio::connection>& dbusConnection,
+    const std::shared_ptr<boost::container::flat_set<std::string>>&
+        sensorsChanged)
+{
+    auto getter = std::make_shared<GetSensorConfiguration>(
+        dbusConnection,
+        [&io, &objectServer, &sensors, &dbusConnection,
+         sensorsChanged](const ManagedObjectType& sensorConfigurations) {
+            bool firstScan = sensorsChanged == nullptr;
+            const std::string* interfacePath = nullptr;
+            const std::pair<std::string, SensorBaseConfigMap>*
+                baseConfiguration = nullptr;
+
+            for (const auto& [path, cfgData] : sensorConfigurations)
+            {
+                // clear it out each loop
+                baseConfiguration = nullptr;
+                auto sensorBase = cfgData.find(configInterfaceName(sensorType));
+                if (sensorBase == cfgData.end())
+                {
+                    continue;
+                }
+                baseConfiguration = &(*sensorBase);
+                interfacePath = &path.str;
+
+                if (baseConfiguration == nullptr)
+                {
+                    std::cerr
+                        << "error finding base configuration for sensor types"
+                        << "\n";
+                    continue;
+                }
+                auto findSensorName = baseConfiguration->second.find("Name");
+                if (findSensorName == baseConfiguration->second.end())
+                {
+                    std::cerr << "could not determine configuration name"
+                              << "\n";
+                    continue;
+                }
+                std::string sensorName =
+                    std::get<std::string>(findSensorName->second);
+
+                auto findGpioName = baseConfiguration->second.find("GpioName");
+                if (findGpioName == baseConfiguration->second.end())
+                {
+                    std::cerr << "could not determine gpio name"
+                              << "\n";
+                    continue;
+                }
+                std::string gpioName =
+                    std::get<std::string>(findGpioName->second);
+
+                // on rescans, only update sensors we were signaled by
+                auto findSensor = sensors.find(sensorName);
+                if (!firstScan && findSensor != sensors.end())
+                {
+                    bool found = false;
+                    for (auto it = sensorsChanged->begin();
+                         it != sensorsChanged->end(); it++)
+                    {
+                        if (findSensor->second &&
+                            boost::ends_with(*it, findSensor->second->name))
+                        {
+                            sensorsChanged->erase(it);
+                            findSensor->second = nullptr;
+                            found = true;
+                            break;
+                        }
+                    }
+                    if (!found)
+                    {
+                        continue;
+                    }
+                }
+
+                auto findPolarity = baseConfiguration->second.find("Polarity");
+                if (findPolarity == baseConfiguration->second.end())
+                {
+                    std::cerr << "could not determine configuration polarity"
+                              << "\n";
+                    continue;
+                }
+                std::string polarity =
+                    std::get<std::string>(findPolarity->second);
+
+                auto& sensorConstruct = sensors[sensorName];
+                sensorConstruct = nullptr;
+
+                sensorConstruct = std::make_shared<ProcessorStatus>(
+                    objectServer, dbusConnection, io, sensorName, gpioName,
+                    *interfacePath);
+            }
+        });
+
+    getter->getConfiguration(std::vector<std::string>{sensorType});
+}
+
+int main()
+{
+    boost::asio::io_context io;
+    auto systemBus = std::make_shared<sdbusplus::asio::connection>(io);
+    sdbusplus::asio::object_server objectServer(systemBus, true);
+    objectServer.add_manager("/xyz/openbmc_project/sensors");
+    systemBus->request_name("xyz.openbmc_project.ProcessorStatus");
+    boost::container::flat_map<std::string, std::shared_ptr<ProcessorStatus>>
+        sensors;
+    std::vector<std::unique_ptr<sdbusplus::bus::match::match>> matches;
+    auto sensorsChanged =
+        std::make_shared<boost::container::flat_set<std::string>>();
+
+    //  io.post([&]() {
+    boost::asio::post(io, [&]() {
+        createSensors(io, objectServer, sensors, systemBus, nullptr);
+    });
+
+    boost::asio::deadline_timer filterTimer(io);
+    std::function<void(sdbusplus::message::message&)> eventHandler =
+        [&](sdbusplus::message::message& message) {
+            if (message.is_method_error())
+            {
+                std::cerr << "callback method error\n";
+                return;
+            }
+            sensorsChanged->insert(message.get_path());
+            // this implicitly cancels the timer
+            filterTimer.expires_from_now(boost::posix_time::seconds(1));
+
+            filterTimer.async_wait([&](const boost::system::error_code& ec) {
+                if (ec == boost::asio::error::operation_aborted)
+                {
+                    /* we were canceled*/
+                    return;
+                }
+                if (ec)
+                {
+                    std::cerr << "timer error\n";
+                    return;
+                }
+                createSensors(io, objectServer, sensors, systemBus,
+                              sensorsChanged);
+            });
+        };
+
+    auto match = std::make_unique<sdbusplus::bus::match::match>(
+        static_cast<sdbusplus::bus::bus&>(*systemBus),
+        "type='signal',member='PropertiesChanged',path_namespace='" +
+            std::string(inventoryPath) + "',arg0namespace='" +
+            configInterfaceName(sensorType) + "'",
+        eventHandler);
+    matches.emplace_back(std::move(match));
+    io.run();
+}
diff --git a/src/Utils.cpp b/src/Utils.cpp
index 4fb49ef..727d3ab 100644
--- a/src/Utils.cpp
+++ b/src/Utils.cpp
@@ -46,6 +46,45 @@ static std::unique_ptr<sdbusplus::bus::match_t> powerMatch = nullptr;
 static std::unique_ptr<sdbusplus::bus::match_t> postMatch = nullptr;
 static std::unique_ptr<sdbusplus::bus::match_t> chassisMatch = nullptr;
 
+void addSelEntry(std::shared_ptr<sdbusplus::asio::connection>& conn,
+                 const std::vector<std::string> logData,
+                 const std::vector<uint8_t> eventData, bool assert)
+{
+    const std::string sensorName = logData[0];
+    const std::string eventName = logData[1];
+    const std::string sensorPath = logData[2];
+    const std::string redfishId = "OpenBMC.0.1." + logData[3];
+
+    // Log Redfish event
+    if (assert)
+    {
+        lg2::info("{EVENT} assert", "EVENT", eventName, "REDFISH_MESSAGE_ID",
+                  redfishId, "REDFISH_MESSAGE_ARGS",
+                  (sensorName + "," + eventName));
+    }
+    else
+    {
+        lg2::info("{EVENT} deassert", "EVENT", eventName, "REDFISH_MESSAGE_ID",
+                  redfishId, "REDFISH_MESSAGE_ARGS",
+                  (sensorName + "," + eventName));
+    }
+
+    // Log into IPMI SEL event
+    auto method = conn->new_method_call(ipmiService, ipmiObjPath, ipmiIntf,
+                                        ipmiSelAddMethod);
+    method.append(ipmiSELAddMessage, sensorPath, eventData, assert,
+                  selBMCGenID);
+    try
+    {
+        auto reply = conn->call(method);
+    }
+    catch (sdbusplus::exception_t&)
+    {
+        std::cerr << "error adding SEL Event for " << sensorPath << "\n";
+        return;
+    }
+}
+
 /**
  * return the contents of a file
  * @param[in] hwmonFile - the path to the file to read
diff --git a/src/Utils.hpp b/src/Utils.hpp
index cd8fa9b..5754017 100644
--- a/src/Utils.hpp
+++ b/src/Utils.hpp
@@ -5,6 +5,7 @@
 #include <boost/algorithm/string/replace.hpp>
 #include <boost/asio/steady_timer.hpp>
 #include <boost/container/flat_map.hpp>
+#include <phosphor-logging/lg2.hpp>
 #include <sdbusplus/asio/connection.hpp>
 #include <sdbusplus/asio/object_server.hpp>
 #include <sdbusplus/message/types.hpp>
@@ -30,6 +31,18 @@ constexpr const char* cpuInventoryPath =
     "/xyz/openbmc_project/inventory/system/chassis/motherboard";
 const std::regex illegalDbusRegex("[^A-Za-z0-9_]");
 
+static const std::string ipmiSELAddMessage = "";
+static constexpr uint16_t selBMCGenID = 0x0020;
+// Processor sensor
+static const std::string processorPath = "/xyz/openbmc_project/sensors/cpu/";
+static const std::vector<uint8_t> procPresence{0x07, 0xFF, 0xFF};
+
+// IPMI Sel
+static constexpr const char* ipmiService = "xyz.openbmc_project.Logging.IPMI";
+static constexpr const char* ipmiObjPath = "/xyz/openbmc_project/Logging/IPMI";
+static constexpr const char* ipmiIntf = "xyz.openbmc_project.Logging.IPMI";
+static constexpr const char* ipmiSelAddMethod = "IpmiSelAdd";
+
 using BasicVariantType =
     std::variant<std::vector<std::string>, std::string, int64_t, uint64_t,
                  double, int32_t, uint32_t, int16_t, uint16_t, uint8_t, bool>;
@@ -45,11 +58,19 @@ using GetSubTreeType = std::vector<
               std::vector<std::pair<std::string, std::vector<std::string>>>>>;
 using Association = std::tuple<std::string, std::string, std::string>;
 
+using AssociationList =
+    std::vector<std::tuple<std::string, std::string, std::string>>;
+
 inline std::string escapeName(const std::string& sensorName)
 {
     return boost::replace_all_copy(sensorName, " ", "_");
 }
 
+// Add IPMI & Refish Log
+void addSelEntry(std::shared_ptr<sdbusplus::asio::connection>& conn,
+                 std::vector<std::string> logData,
+                 std::vector<uint8_t> eventData, bool assert);
+
 enum class PowerState
 {
     on,
diff --git a/src/meson.build b/src/meson.build
index 0adbabc..d50b191 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -244,3 +244,19 @@ if get_option('external').enabled()
         install: true,
     )
 endif
+
+if get_option('procstatus').enabled()
+    executable(
+        'processorstatus',
+        'ProcessorStatus.cpp',
+        'ProcessorStatusMain.cpp',
+        dependencies: [
+            default_deps,
+            gpiodcxx,
+            utils_dep,
+        ],
+        cpp_args: uring_args,
+        install: true,
+    )
+endif
+
-- 
2.25.1

