From 22b2c87de926d4d96f0779c3f38d7b88fb1c2b2e Mon Sep 17 00:00:00 2001
From: vipinc <vipinc@ami.com>
Date: Fri, 29 Dec 2023 04:42:30 +0530
Subject: [PATCH 1/1] Digital discrete sensor support

Description:
- New service called "digitaldiscrete" added as a
part of dbus-sensors to expose digital sensors.
- Will have hook methods to implement sensor or
platform specific code to read a physical or sofrtware
sensors.

Tested:
- Able to build successfully and "chassis on" sensors listing
as expected.

After Chassis Power Off:(de-asserted event showing)
root@AMIOT-baec3739424c:~# ipmitool chassis power off
Chassis Power Control: Down/Off
root@AMIOT-baec3739424c:~# ipmitool sensor list
PSU1 Out Current | 36.000     | Amps       | ok    | na        | na        | na        | 164.000   | 180.000   | na
Chassis on       | 0x0        | discrete   | 0x0100| na        | na        | na        | na        | na        | na

root@AMIOT-baec3739424c:~# ipmitool sdr elist
PSU1 Out Current | 04h | ok  |  0.1 | 1 Amps
Chassis on       | 05h | ok  | 19.1 | State Deasserted

SDR record ID   : 0x0005
SDR record type : 0x02
SDR record next : 0x0006
SDR record bytes: 43
Getting 23 bytes from SDR at offset 5
Getting 20 bytes from SDR at offset 28
Sensor ID              : Chassis on (0x5)
 Entity ID             : 19.1
 Sensor Type (Discrete): Power Unit
 States Asserted       : Power Unit
                         [State Deasserted]

After Chassis power On:(asserted event showing)
root@AMIOT-baec3739424c:~# ipmitool chassis power on
Chassis Power Control: Up/On
root@AMIOT-baec3739424c:~# ipmitool sensor list
PSU1 Out Current | 33.000     | Amps       | ok    | na        | na        | na        | 164.000   | 180.000   | na
Chassis on       | 0x0        | discrete   | 0x0200| na        | na        | na        | na        | na        | na

root@AMIOT-baec3739424c:~# ipmitool sdr elist
PSU1 Out Current | 04h | ok  |  0.1 | 48 Amps
Chassis on       | 05h | ok  | 19.1 | State Asserted

SDR record ID   : 0x0005
SDR record type : 0x02
SDR record next : 0x0006
SDR record bytes: 43
Getting 23 bytes from SDR at offset 5
Getting 20 bytes from SDR at offset 28
Sensor ID              : Chassis on (0x5)
 Entity ID             : 19.1
 Sensor Type (Discrete): Power Unit
 States Asserted       : Power Unit
                         [State Asserted]

Signed-off-by: vipinc <vipinc@ami.com>
---
 meson_options.txt                             |   1 +
 service_files/meson.build                     |   1 +
 ...yz.openbmc_project.digitaldiscrete.service |  13 ++
 src/DigitalDiscrete.cpp                       | 129 +++++++++++++
 src/DigitalDiscrete.hpp                       |  61 ++++++
 src/DigitalDiscreteMain.cpp                   | 175 ++++++++++++++++++
 src/meson.build                               |  15 ++
 7 files changed, 395 insertions(+)
 create mode 100644 service_files/xyz.openbmc_project.digitaldiscrete.service
 create mode 100644 src/DigitalDiscrete.cpp
 create mode 100644 src/DigitalDiscrete.hpp
 create mode 100644 src/DigitalDiscreteMain.cpp

diff --git a/meson_options.txt b/meson_options.txt
index 248426a..98de415 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -10,6 +10,7 @@ option('nvme', type: 'feature', value: 'enabled', description: 'Enable NVMe sens
 option('psu', type: 'feature', value: 'enabled', description: 'Enable PSU sensor.',)
 option('external', type: 'feature', value: 'enabled', description: 'Enable External sensor.',)
 option('powerunit', type: 'feature', value: 'disabled', description: 'Enable powerunit status sensor.',)
+option('digital', type: 'feature', value: 'disabled', description: 'Enable digital discrete sensor',)
 option('tests', type: 'feature', value: 'enabled', description: 'Build tests.',)
 option('validate-unsecure-feature', type : 'feature', value : 'disabled', description : 'Enables unsecure features required by validation. Note: mustbe turned off for production images.',)
 option('insecure-sensor-override', type : 'feature', value : 'disabled', description : 'Enables Sensor override feature without any check.',)
diff --git a/service_files/meson.build b/service_files/meson.build
index dcb9808..15cfd2a 100644
--- a/service_files/meson.build
+++ b/service_files/meson.build
@@ -18,6 +18,7 @@ unit_files = [
     ['osstatus', 'xyz.openbmc_project.osstatus.service'],
     ['batterystatus', 'xyz.openbmc_project.batterystatus.service'],
     ['acpidevice', 'xyz.openbmc_project.acpidevicestatus.service'],
+    ['digital', 'xyz.openbmc_project.digitaldiscrete.service'],
 ]
 
 foreach tuple : unit_files
diff --git a/service_files/xyz.openbmc_project.digitaldiscrete.service b/service_files/xyz.openbmc_project.digitaldiscrete.service
new file mode 100644
index 0000000..473b47d
--- /dev/null
+++ b/service_files/xyz.openbmc_project.digitaldiscrete.service
@@ -0,0 +1,13 @@
+[Unit]
+Description=Digital discrete sensor
+StopWhenUnneeded=false
+Requires=xyz.openbmc_project.EntityManager.service
+After=xyz.openbmc_project.EntityManager.service
+
+[Service]
+Restart=always
+RestartSec=5
+ExecStart=/usr/bin/digitaldiscrete
+
+[Install]
+WantedBy=multi-user.target
diff --git a/src/DigitalDiscrete.cpp b/src/DigitalDiscrete.cpp
new file mode 100644
index 0000000..c005bce
--- /dev/null
+++ b/src/DigitalDiscrete.cpp
@@ -0,0 +1,129 @@
+#include <unistd.h>
+
+#include <DigitalDiscrete.hpp>
+
+#include <exception>
+#include <fstream>
+#include <iostream>
+#include <optional>
+#include <string>
+#include <vector>
+
+DigitalDiscrete::DigitalDiscrete(
+    sdbusplus::asio::object_server& objectServer,
+    std::shared_ptr<sdbusplus::asio::connection>& conn,
+    boost::asio::io_context& io __attribute__((unused)),
+    const std::string& sensorName, const std::string& sensorConfiguration,
+    unsigned int& eventType, unsigned int& subType) :
+    Discrete(escapeName(sensorName), sensorConfiguration, conn),
+    objServer(objectServer), eveType(eventType), subType(subType)
+{
+    sensorInterface = objectServer.add_interface(
+        "/xyz/openbmc_project/sensors/chassisstate/" + name,
+        "xyz.openbmc_project.Sensor.State");
+
+    association = objectServer.add_interface(
+        "/xyz/openbmc_project/sensors/chassisstate/" + name,
+        association::interface);
+    setInitialProperties();
+}
+
+DigitalDiscrete::~DigitalDiscrete()
+{
+    objServer.remove_interface(sensorInterface);
+    objServer.remove_interface(association);
+}
+
+void DigitalDiscrete::setupRead(void)
+{
+
+    deviceFunction = {
+        {static_cast<unsigned int>(DigitalType::State),
+         [this]() { monitorState(); }},
+        {static_cast<unsigned int>(DigitalType::Failure),
+         [this]() { monitorFailure(); }},
+        {static_cast<unsigned int>(DigitalType::Limit),
+         [this]() { monitorLimit(); }},
+        {static_cast<unsigned int>(DigitalType::Performance),
+         [this]() { monitorPerformance(); }},
+        {static_cast<unsigned int>(DigitalType::Presence),
+         [this]() { monitorPresence(); }},
+        {static_cast<unsigned int>(DigitalType::Enabled),
+         [this]() { monitorEnabled(); }},
+    };
+
+    auto it = deviceFunction.find(eveType);
+    if (it != deviceFunction.end())
+    {
+        it->second();
+    }
+}
+
+void DigitalDiscrete::monitorState(void)
+{
+
+    // write sensor specific code
+    auto powerStatusMatcherCallback = [this](sdbusplus::message_t& msg) {
+        std::cerr << "power state changed\n";
+        std::string objectName;
+        boost::container::flat_map<std::string, std::variant<std::string>>
+            values;
+
+        std::vector<uint8_t> eventData(selEvtDataMaxSize, 0xFF);
+        bool assertion = true;
+        std::vector<std::string> logData;
+        logData.push_back(name);
+
+        msg.read(objectName, values);
+        auto findState = values.find(powerProperty);
+        if (findState != values.end())
+        {
+            if (std::get<std::string>(findState->second) ==
+                "xyz.openbmc_project.State.Host.HostState.Off")
+            {
+                updateState(sensorInterface, 0x01);
+                eventData[0] = static_cast<uint8_t>(0x00);
+                logData.push_back("State Deasserted");
+            }
+            else
+            {
+                updateState(sensorInterface, 0x02);
+                eventData[0] = static_cast<uint8_t>(0x01);
+                logData.push_back("State Asserted");
+            }
+
+            logData.push_back(baseObj + name);
+            logData.push_back("DigitalState");
+
+            addSelEntry(dbusConnection, logData, eventData, assertion);
+        }
+    };
+
+    powerMonitor =
+        setupDbusMatch(powerPath, powerInterface, powerStatusMatcherCallback);
+}
+
+void DigitalDiscrete::monitorFailure(void)
+{
+    // Implement code for digital failure sensor
+}
+
+void DigitalDiscrete::monitorLimit(void)
+{
+    // Implement code for digital limit sensor
+}
+
+void DigitalDiscrete::monitorPerformance(void)
+{
+    // Implement code for digital performance sensor
+}
+
+void DigitalDiscrete::monitorPresence(void)
+{
+    // Implement code for digital presence sensor
+}
+
+void DigitalDiscrete::monitorEnabled(void)
+{
+    // Implement code for digital presence sensor
+}
diff --git a/src/DigitalDiscrete.hpp b/src/DigitalDiscrete.hpp
new file mode 100644
index 0000000..d285263
--- /dev/null
+++ b/src/DigitalDiscrete.hpp
@@ -0,0 +1,61 @@
+#pragma once
+
+#include <Discrete.hpp>
+#include <Utils.hpp>
+#include <boost/asio/deadline_timer.hpp>
+#include <boost/asio/io_service.hpp>
+#include <boost/container/flat_map.hpp>
+#include <sdbusplus/asio/object_server.hpp>
+
+#include <memory>
+#include <optional>
+#include <stdexcept>
+#include <string>
+#include <vector>
+
+enum class DigitalType : unsigned int
+{
+    State = 0x03,
+    Failure,
+    Limit,
+    Performance,
+    Presence = 0x08,
+    Enabled,
+};
+
+namespace fs = std::filesystem;
+
+class DigitalDiscrete :
+    public Discrete,
+    public std::enable_shared_from_this<DigitalDiscrete>
+{
+  public:
+    DigitalDiscrete(sdbusplus::asio::object_server& objectServer,
+                    std::shared_ptr<sdbusplus::asio::connection>& conn,
+                    boost::asio::io_context& io, const std::string& sensorName,
+                    const std::string& sensorConfiguration,
+                    unsigned int& eventType, unsigned int& subType);
+    ~DigitalDiscrete() override;
+
+    static constexpr size_t selEvtDataMaxSize = 3;
+    std::string baseObj = "/xyz/openbmc_project/sensors/chassisstate/";
+    void setupRead(void);
+
+  private:
+    sdbusplus::asio::object_server& objServer;
+    unsigned int eveType;
+    unsigned int subType;
+    std::map<unsigned int, std::function<void(void)>> deviceFunction;
+    std::shared_ptr<sdbusplus::bus::match_t> powerMonitor;
+    void monitorState(void);
+    void monitorFailure(void);
+    void monitorLimit(void);
+    void monitorPerformance(void);
+    void monitorPresence(void);
+    void monitorEnabled(void);
+
+    const static constexpr char* powerInterface =
+        "xyz.openbmc_project.State.Host";
+    const static constexpr char* powerPath = "/xyz/openbmc_project/state/host0";
+    const static constexpr char* powerProperty = "CurrentHostState";
+};
diff --git a/src/DigitalDiscreteMain.cpp b/src/DigitalDiscreteMain.cpp
new file mode 100644
index 0000000..2b67a54
--- /dev/null
+++ b/src/DigitalDiscreteMain.cpp
@@ -0,0 +1,175 @@
+#include <DigitalDiscrete.hpp>
+#include <VariantVisitors.hpp>
+#include <boost/algorithm/string/case_conv.hpp>
+#include <boost/algorithm/string/predicate.hpp>
+#include <boost/algorithm/string/replace.hpp>
+#include <boost/container/flat_set.hpp>
+#include <sdbusplus/bus/match.hpp>
+
+#include <functional>
+#include <memory>
+#include <optional>
+#include <regex>
+#include <string>
+#include <variant>
+#include <vector>
+
+static constexpr auto sensorTypes{std::to_array<const char*>({"Digital"})};
+
+void createSensors(
+    boost::asio::io_context& io, sdbusplus::asio::object_server& objectServer,
+    boost::container::flat_map<std::string, std::shared_ptr<DigitalDiscrete>>&
+        sensors,
+    std::shared_ptr<sdbusplus::asio::connection>& dbusConnection,
+    const std::shared_ptr<boost::container::flat_set<std::string>>&
+        sensorsChanged)
+{
+    auto getter = std::make_shared<GetSensorConfiguration>(
+        dbusConnection,
+        [&io, &objectServer, &sensors, &dbusConnection,
+         sensorsChanged](const ManagedObjectType& sensorConfigurations) {
+            bool firstScan = sensorsChanged == nullptr;
+            const std::string* interfacePath = nullptr;
+            const std::pair<std::string, SensorBaseConfigMap>*
+                baseConfiguration = nullptr;
+
+            for (const auto& [path, cfgData] : sensorConfigurations)
+            {
+                // clear it out each loop
+                baseConfiguration = nullptr;
+                // find base configuration
+                for (const char* type : sensorTypes)
+                {
+                    auto sensorBase = cfgData.find(configInterfaceName(type));
+                    if (sensorBase != cfgData.end())
+                    {
+                        baseConfiguration = &(*sensorBase);
+                        break;
+                    }
+                }
+                interfacePath = &path.str;
+
+                if (baseConfiguration == nullptr)
+                {
+                    std::cerr
+                        << "error finding base configuration for sensor types"
+                        << "\n";
+                    continue;
+                }
+                auto findSensorName = baseConfiguration->second.find("Name");
+                if (findSensorName == baseConfiguration->second.end())
+                {
+                    std::cerr << "could not determine configuration name"
+                              << "\n";
+                    continue;
+                }
+                std::string sensorName =
+                    std::get<std::string>(findSensorName->second);
+
+                auto findEventType =
+                    baseConfiguration->second.find("EventType");
+                if (findEventType == baseConfiguration->second.end())
+                {
+                    std::cerr << "could not determine configuration event type"
+                              << "\n";
+                    continue;
+                }
+                unsigned int eventType = std::visit(
+                    VariantToUnsignedIntVisitor(), findEventType->second);
+
+                auto findSubType = baseConfiguration->second.find("SubType");
+                if (findSubType == baseConfiguration->second.end())
+                {
+                    std::cerr << "could not determine configuration sub type"
+                              << "\n";
+                    continue;
+                }
+                unsigned int subType = std::visit(VariantToUnsignedIntVisitor(),
+                                                  findSubType->second);
+
+                // on rescans, only update sensors we were signaled by
+                auto findSensor = sensors.find(sensorName);
+                if (!firstScan && findSensor != sensors.end())
+                {
+                    bool found = false;
+                    for (auto it = sensorsChanged->begin();
+                         it != sensorsChanged->end(); it++)
+                    {
+                        if (findSensor->second &&
+                            boost::ends_with(*it, findSensor->second->name))
+                        {
+                            sensorsChanged->erase(it);
+                            findSensor->second = nullptr;
+                            found = true;
+                            break;
+                        }
+                    }
+                    if (!found)
+                    {
+                        continue;
+                    }
+                }
+
+                auto& sensorConstruct = sensors[sensorName];
+                sensorConstruct = nullptr;
+
+                sensorConstruct = std::make_shared<DigitalDiscrete>(
+                    objectServer, dbusConnection, io, sensorName,
+                    *interfacePath, eventType, subType);
+                sensorConstruct->setupRead();
+            }
+        });
+
+    getter->getConfiguration(
+        std::vector<std::string>{sensorTypes.begin(), sensorTypes.end()});
+}
+
+int main()
+{
+    boost::asio::io_context io;
+    auto systemBus = std::make_shared<sdbusplus::asio::connection>(io);
+    sdbusplus::asio::object_server objectServer(systemBus, true);
+    objectServer.add_manager("/xyz/openbmc_project/sensors");
+    systemBus->request_name("xyz.openbmc_project.DigitalDiscrete");
+    boost::container::flat_map<std::string, std::shared_ptr<DigitalDiscrete>>
+        sensors;
+    auto sensorsChanged =
+        std::make_shared<boost::container::flat_set<std::string>>();
+
+    boost::asio::post(io, [&]() {
+        createSensors(io, objectServer, sensors, systemBus, nullptr);
+    });
+
+    boost::asio::steady_timer filterTimer(io);
+    std::function<void(sdbusplus::message_t&)> eventHandler =
+        [&](sdbusplus::message_t& message) {
+            if (message.is_method_error())
+            {
+                std::cerr << "callback method error\n";
+                return;
+            }
+            sensorsChanged->insert(message.get_path());
+            // this implicitly cancels the timer
+            filterTimer.expires_after(std::chrono::seconds(1));
+
+            filterTimer.async_wait([&](const boost::system::error_code& ec) {
+                if (ec == boost::asio::error::operation_aborted)
+                {
+                    /* we were canceled*/
+                    return;
+                }
+                if (ec)
+                {
+                    std::cerr << "timer error\n";
+                    return;
+                }
+                createSensors(io, objectServer, sensors, systemBus,
+                              sensorsChanged);
+            });
+        };
+
+    std::vector<std::unique_ptr<sdbusplus::bus::match_t>> matches =
+        setupPropertiesChangedMatches(*systemBus, sensorTypes, eventHandler);
+
+    io.run();
+}
diff --git a/src/meson.build b/src/meson.build
index 5cffb9c..3e7355b 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -359,3 +359,18 @@ if get_option('acpidevice').enabled()
         install: true,
     )
 endif
+
+if get_option('digital').enabled()
+    executable(
+        'digitaldiscrete',
+        'DigitalDiscrete.cpp',
+        'DigitalDiscreteMain.cpp',
+        dependencies: [
+            default_deps,
+            utils_dep,
+        ],
+        cpp_args: uring_args,
+        install: true,
+    )
+endif
+
-- 
2.25.1

