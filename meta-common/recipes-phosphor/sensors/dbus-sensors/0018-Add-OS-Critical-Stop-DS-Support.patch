From 65b4d41a6bb45949166db6c4c2c9629ac3232dbf Mon Sep 17 00:00:00 2001
From: vipinc <vipinc@ami.com>
Date: Mon, 11 Sep 2023 18:20:35 +0530
Subject: [PATCH] Add OS Critical Stop Discrete Sensor Support

This patch add OS Critical Sensor support. When Critical events occurs in
Operating System, BMC have limitation to identify the event. So in these
cases BIOS will be notify  BMC using IPMI add SEL entry command. In order
to properly log the event sensors are requiried as we are using Dynamic sensors
in OneTree. This Patch will create and expose the D-Bus object for the sensor
based on the EM configuration.

Tested in INTEL Archercity:
1) Verified the sensor is listing in IPMI sensor and sdr list

root@AMIOT-c208ad8319c9:~# ipmitool sensor | grep -i Disc
OS Stop Status   | 0x0        | discrete   | 0x0000| na        | na        | na        | na        | na        | na
root@AMIOT-c208ad8319c9:~#

root@AMIOT-c208ad8319c9:~# ipmitool sdr get "OS Stop Status"
Sensor ID              : OS Stop Status (0x10)
 Entity ID             : 35.1 (Operating System)
 Sensor Type (Discrete): OS Critical Stop (0x20)
 Sensor Reading        : 0h
 Event Message Control : Per-threshold
 Event Status          : Event Messages Disabled
 Event Enable          : Event Messages Disabled
 OEM                   : 0

2) Verified the Sensor state is updated when Add SEL entry command is triggered
for OS Critical Stop sensor

// Before triggering add SEL command:
root@AMIOT-c208ad8319c9:~# ipmitool sdr elist | grep "OS Stop Status"
OS Stop Status   | 10h | ok  | 35.1 |
// After triggering add SEL command:
root@AMIOT-c208ad8319c9:~# ipmitool raw 0x0a 0x44 0x00 0x00 0x02 0x00 0x00 0x00 0x00 0x41 0x00 0x04 0x20 0x00 0x6f 0x01 0xff 0xff
 05 00
root@AMIOT-c208ad8319c9:~#
root@AMIOT-c208ad8319c9:~# ipmitool sdr elist | grep "OS Stop Status"
OS Stop Status   | 10h | ok  | 35.1 | Run-time critical stop
root@AMIOT-c208ad8319c9:~#
root@AMIOT-c208ad8319c9:~# ipmitool sel list
   5 | 09/11/23 | 06:19:12 UTC | OS Critical Stop #0x10 | Run-time critical stop | Asserted
root@AMIOT-c208ad8319c9:~#

Signed-off-by: vipinc <vipinc@ami.com>
---
 meson_options.txt                             |   2 +
 service_files/meson.build                     |   1 +
 .../xyz.openbmc_project.osstatus.service      |  13 ++
 src/OSStatus.cpp                              |  33 ++++
 src/OSStatus.hpp                              |  33 ++++
 src/OSStatusMain.cpp                          | 152 ++++++++++++++++++
 src/Utils.hpp                                 |   2 +
 src/meson.build                               |  13 ++
 8 files changed, 249 insertions(+)
 create mode 100644 service_files/xyz.openbmc_project.osstatus.service
 create mode 100644 src/OSStatus.cpp
 create mode 100644 src/OSStatus.hpp
 create mode 100644 src/OSStatusMain.cpp

diff --git a/meson_options.txt b/meson_options.txt
index c2e3402..c3028db 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -17,3 +17,5 @@ option('procstatus', type: 'feature', value: 'enabled', description: 'Enable pro
 option('system', type: 'feature', value: 'disabled', description: 'Enable system sensor watchdog2 status.',)
 option('acpisystem', type: 'feature', value: 'disabled', description: 'Enable acpi system status sensor.',)
 option('psustatus', type: 'feature', value: 'disabled', description: 'Enable PSU Status sensor.',)
+option('osstatus', type: 'feature', value: 'disabled', description: 'Enable OS Critical sensor.',)
+
diff --git a/service_files/meson.build b/service_files/meson.build
index 398c6b2..cfb66bf 100644
--- a/service_files/meson.build
+++ b/service_files/meson.build
@@ -15,6 +15,7 @@ unit_files = [
     ['powerunit', 'xyz.openbmc_project.powerunitstatus.service'],
     ['acpisystem', 'xyz.openbmc_project.acpisystemstatus.service'],
     ['psustatus', 'xyz.openbmc_project.psustatus.service'],
+    ['osstatus', 'xyz.openbmc_project.osstatus.service'],
 ]
 
 foreach tuple : unit_files
diff --git a/service_files/xyz.openbmc_project.osstatus.service b/service_files/xyz.openbmc_project.osstatus.service
new file mode 100644
index 0000000..514eaf0
--- /dev/null
+++ b/service_files/xyz.openbmc_project.osstatus.service
@@ -0,0 +1,13 @@
+[Unit]
+Description=OS Critical Sensor
+StopWhenUnneeded=false
+Requires=xyz.openbmc_project.EntityManager.service
+After=xyz.openbmc_project.EntityManager.service
+
+[Service]
+Restart=always
+RestartSec=5
+ExecStart=/usr/bin/osstatus
+
+[Install]
+WantedBy=multi-user.target
diff --git a/src/OSStatus.cpp b/src/OSStatus.cpp
new file mode 100644
index 0000000..eb27c52
--- /dev/null
+++ b/src/OSStatus.cpp
@@ -0,0 +1,33 @@
+#include <unistd.h>
+
+#include <OSStatus.hpp>
+#include <boost/asio/read_until.hpp>
+#include <boost/date_time/posix_time/posix_time.hpp>
+
+#include <fstream>
+#include <iostream>
+#include <limits>
+#include <optional>
+#include <string>
+#include <vector>
+
+OSStatus::OSStatus(sdbusplus::asio::object_server& objectServer,
+                   std::shared_ptr<sdbusplus::asio::connection>& conn,
+                   const std::string& sensorName,
+                   const std::string& sensorConfiguration) :
+    Discrete(escapeName(sensorName), sensorConfiguration, conn),
+    objServer(objectServer)
+{
+    sensorInterface =
+        objectServer.add_interface("/xyz/openbmc_project/sensors/os/" + name,
+                                   "xyz.openbmc_project.Sensor.State");
+
+    association = objectServer.add_interface(
+        "/xyz/openbmc_project/sensors/os/" + name, association::interface);
+    setInitialProperties();
+}
+
+OSStatus::~OSStatus()
+{
+    objServer.remove_interface(sensorInterface);
+}
diff --git a/src/OSStatus.hpp b/src/OSStatus.hpp
new file mode 100644
index 0000000..0155536
--- /dev/null
+++ b/src/OSStatus.hpp
@@ -0,0 +1,33 @@
+#pragma once
+
+#include <Discrete.hpp>
+#include <Utils.hpp>
+#include <boost/asio/deadline_timer.hpp>
+#include <boost/asio/io_service.hpp>
+#include <boost/asio/posix/stream_descriptor.hpp>
+#include <sdbusplus/asio/object_server.hpp>
+#include <xyz/openbmc_project/Association/Definitions/server.hpp>
+
+#include <memory>
+#include <optional>
+#include <stdexcept>
+#include <string>
+#include <vector>
+
+namespace fs = std::filesystem;
+
+class OSStatus : public Discrete, public std::enable_shared_from_this<OSStatus>
+{
+  public:
+    OSStatus(sdbusplus::asio::object_server& objectServer,
+             std::shared_ptr<sdbusplus::asio::connection>& conn,
+             const std::string& sensorName,
+             const std::string& sensorConfiguration);
+    ~OSStatus() override;
+
+    std::string status;
+
+  private:
+    sdbusplus::asio::object_server& objServer;
+    std::shared_ptr<sdbusplus::bus::match::match> osEventMatcher;
+};
diff --git a/src/OSStatusMain.cpp b/src/OSStatusMain.cpp
new file mode 100644
index 0000000..a86ebbb
--- /dev/null
+++ b/src/OSStatusMain.cpp
@@ -0,0 +1,152 @@
+#include <OSStatus.hpp>
+#include <VariantVisitors.hpp>
+#include <boost/algorithm/string/case_conv.hpp>
+#include <boost/algorithm/string/predicate.hpp>
+#include <boost/algorithm/string/replace.hpp>
+#include <boost/container/flat_set.hpp>
+#include <sdbusplus/bus/match.hpp>
+
+#include <functional>
+#include <memory>
+#include <optional>
+#include <regex>
+#include <string>
+#include <variant>
+#include <vector>
+
+static constexpr const char* sensorType = "OSCritical";
+void createSensors(
+    boost::asio::io_context& io, sdbusplus::asio::object_server& objectServer,
+    boost::container::flat_map<std::string, std::shared_ptr<OSStatus>>& sensors,
+    std::shared_ptr<sdbusplus::asio::connection>& dbusConnection,
+    const std::shared_ptr<boost::container::flat_set<std::string>>&
+        sensorsChanged)
+{
+    auto getter = std::make_shared<GetSensorConfiguration>(
+        dbusConnection,
+        [&io, &objectServer, &sensors, &dbusConnection,
+         sensorsChanged](const ManagedObjectType& sensorConfigurations) {
+            bool firstScan = sensorsChanged == nullptr;
+            const std::string* interfacePath = nullptr;
+            const std::pair<std::string, SensorBaseConfigMap>*
+                baseConfiguration = nullptr;
+
+            for (const auto& [path, cfgData] : sensorConfigurations)
+            {
+
+                // clear it out each loop
+                baseConfiguration = nullptr;
+                auto sensorBase = cfgData.find(configInterfaceName(sensorType));
+                if (sensorBase == cfgData.end())
+                {
+                    continue;
+                }
+                baseConfiguration = &(*sensorBase);
+                interfacePath = &path.str;
+
+                if (baseConfiguration == nullptr)
+                {
+                    std::cerr
+                        << "error finding base configuration for sensor types"
+                        << "\n";
+                    continue;
+                }
+
+                auto findSensorName = baseConfiguration->second.find("Name");
+                if (findSensorName == baseConfiguration->second.end())
+                {
+                    std::cerr << "could not determine configuration name for "
+                              << "\n";
+                    continue;
+                }
+                std::string sensorName =
+                    std::get<std::string>(findSensorName->second);
+
+                // on rescans, only update sensors we were signaled by
+                auto findSensor = sensors.find(sensorName);
+                if (!firstScan && findSensor != sensors.end())
+                {
+                    bool found = false;
+                    for (auto it = sensorsChanged->begin();
+                         it != sensorsChanged->end(); it++)
+                    {
+                        if (findSensor->second &&
+                            boost::ends_with(*it, findSensor->second->name))
+                        {
+                            sensorsChanged->erase(it);
+                            findSensor->second = nullptr;
+                            found = true;
+                            break;
+                        }
+                    }
+                    if (!found)
+                    {
+                        continue;
+                    }
+                }
+
+                auto& sensorConstruct = sensors[sensorName];
+                sensorConstruct = nullptr;
+
+                sensorConstruct = std::make_shared<OSStatus>(
+                    objectServer, dbusConnection, sensorName, *interfacePath);
+            }
+        });
+
+    getter->getConfiguration(std::vector<std::string>{sensorType});
+}
+
+int main()
+{
+    boost::asio::io_context io;
+    auto systemBus = std::make_shared<sdbusplus::asio::connection>(io);
+    sdbusplus::asio::object_server objectServer(systemBus, true);
+    objectServer.add_manager("/xyz/openbmc_project/sensors");
+    systemBus->request_name("xyz.openbmc_project.OSSStatusSensor");
+    boost::container::flat_map<std::string, std::shared_ptr<OSStatus>> sensors;
+    std::vector<std::unique_ptr<sdbusplus::bus::match::match>> matches;
+    auto sensorsChanged =
+        std::make_shared<boost::container::flat_set<std::string>>();
+
+    boost::asio::post(io, [&]() {
+        createSensors(io, objectServer, sensors, systemBus, nullptr);
+    });
+
+    boost::asio::deadline_timer filterTimer(io);
+    std::function<void(sdbusplus::message::message&)> eventHandler =
+        [&](sdbusplus::message::message& message) {
+            if (message.is_method_error())
+            {
+                std::cerr << "callback method error\n";
+                return;
+            }
+            sensorsChanged->insert(message.get_path());
+            // this implicitly cancels the timer
+            filterTimer.expires_from_now(boost::posix_time::seconds(1));
+
+            filterTimer.async_wait([&](const boost::system::error_code& ec) {
+                if (ec == boost::asio::error::operation_aborted)
+                {
+                    /* we were canceled*/
+                    return;
+                }
+                if (ec)
+                {
+                    std::cerr << "timer error\n";
+                    return;
+                }
+                createSensors(io, objectServer, sensors, systemBus,
+                              sensorsChanged);
+            });
+        };
+
+    auto match = std::make_unique<sdbusplus::bus::match::match>(
+        static_cast<sdbusplus::bus::bus&>(*systemBus),
+        "type='signal',member='PropertiesChanged',path_namespace='" +
+            std::string(inventoryPath) + "',arg0namespace='" +
+            configInterfaceName(sensorType) + "'",
+        eventHandler);
+    matches.emplace_back(std::move(match));
+
+    io.run();
+}
diff --git a/src/Utils.hpp b/src/Utils.hpp
index 5754017..5d3cbdd 100644
--- a/src/Utils.hpp
+++ b/src/Utils.hpp
@@ -33,6 +33,8 @@ const std::regex illegalDbusRegex("[^A-Za-z0-9_]");
 
 static const std::string ipmiSELAddMessage = "";
 static constexpr uint16_t selBMCGenID = 0x0020;
+static constexpr uint8_t osCriticalStop = 0x20;
+
 // Processor sensor
 static const std::string processorPath = "/xyz/openbmc_project/sensors/cpu/";
 static const std::vector<uint8_t> procPresence{0x07, 0xFF, 0xFF};
diff --git a/src/meson.build b/src/meson.build
index 3d6cc38..8fb6e44 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -317,3 +317,16 @@ if get_option('psustatus').enabled()
         )
 endif
 
+if get_option('osstatus').enabled()
+    executable(
+        'osstatus',
+        'OSStatus.cpp',
+        'OSStatusMain.cpp',
+        dependencies: [
+            default_deps,
+            utils_dep,
+        ],
+        cpp_args: uring_args,
+        install: true,
+        )
+endif
-- 
2.25.1

