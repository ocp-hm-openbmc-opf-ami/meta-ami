From 28e4519de7b3adf3ed7552ca05034851e8ec65d4 Mon Sep 17 00:00:00 2001
From: krishna <krishnar@ami.com>
Date: Tue, 22 Aug 2023 09:48:58 +0530
Subject: [PATCH 14/14] ACPI-System-discrete-sensor

---
 ...z.openbmc_project.acpisystemstatus.service |  13 ++
 src/ACPISystemStatus.cpp                      |  98 ++++++++++++
 src/ACPISystemStatus.hpp                      |  51 ++++++
 src/ACPISystemStatusMain.cpp                  | 150 ++++++++++++++++++
 4 files changed, 312 insertions(+)
 create mode 100644 service_files/xyz.openbmc_project.acpisystemstatus.service
 create mode 100644 src/ACPISystemStatus.cpp
 create mode 100644 src/ACPISystemStatus.hpp
 create mode 100644 src/ACPISystemStatusMain.cpp

diff --git a/service_files/xyz.openbmc_project.acpisystemstatus.service b/service_files/xyz.openbmc_project.acpisystemstatus.service
new file mode 100644
index 00000000..3983d803
--- /dev/null
+++ b/service_files/xyz.openbmc_project.acpisystemstatus.service
@@ -0,0 +1,13 @@
+[Unit]
+Description=ACPI System Status
+StopWhenUnneeded=false
+Requires=xyz.openbmc_project.EntityManager.service
+After=xyz.openbmc_project.EntityManager.service
+
+[Service]
+Restart=always
+RestartSec=5
+ExecStart=/usr/bin/acpisystemstatus
+
+[Install]
+WantedBy=multi-user.target
diff --git a/src/ACPISystemStatus.cpp b/src/ACPISystemStatus.cpp
new file mode 100644
index 00000000..96348373
--- /dev/null
+++ b/src/ACPISystemStatus.cpp
@@ -0,0 +1,98 @@
+#include <unistd.h>
+
+#include <ACPISystemStatus.hpp>
+
+#include <exception>
+#include <fstream>
+#include <iostream>
+#include <optional>
+#include <string>
+#include <vector>
+
+ACPISystemStatus::ACPISystemStatus(
+    sdbusplus::asio::object_server& objectServer,
+    std::shared_ptr<sdbusplus::asio::connection>& conn,
+    const std::string& sensorName, const std::string& sensorConfiguration) :
+    Discrete(escapeName(sensorName), sensorConfiguration, conn),
+    objServer(objectServer)
+{
+
+    sensorInterface = objectServer.add_interface(
+        "/xyz/openbmc_project/sensors/acpisystem/" + name,
+        "xyz.openbmc_project.Sensor.State");
+
+    association = objectServer.add_interface(
+        "/xyz/openbmc_project/sensors/acpisystem/" + name,
+        association::interface);
+    setInitialProperties();
+
+    monitorState(conn);
+}
+
+ACPISystemStatus::~ACPISystemStatus()
+{
+    objServer.remove_interface(sensorInterface);
+    objServer.remove_interface(association);
+}
+
+void ACPISystemStatus::propertyInitialize(
+    std::shared_ptr<sdbusplus::asio::connection>& conn)
+{
+
+    reading = reading | (1 << static_cast<uint16_t>(ACPI::LEGACY_OFF));
+    if (getHostStatus(conn) == static_cast<uint8_t>(HostState::Running))
+    {
+        reading = reading | (1 << static_cast<uint16_t>(ACPI::S0_G0));
+    }
+    else if (getHostStatus(conn) == static_cast<uint8_t>(HostState::Off))
+    {
+        reading = reading | (1 << static_cast<uint16_t>(ACPI::S4_S5));
+    }
+    else
+    {
+        reading = reading | (1 << static_cast<uint16_t>(ACPI::Unknown));
+    }
+    updateState(sensorInterface, reading);
+}
+
+void ACPISystemStatus::monitorState(
+    std::shared_ptr<sdbusplus::asio::connection>& conn)
+{
+
+    propertyInitialize(conn);
+    auto powerStatusMatcherCallback = [this, conn](sdbusplus::message_t& msg) {
+        std::cerr << "power state changed\n";
+        std::string objectName;
+        boost::container::flat_map<std::string, std::variant<std::string>>
+            values;
+        reading = 0;
+        reading = reading | (1 << static_cast<uint16_t>(ACPI::LEGACY_OFF));
+        msg.read(objectName, values);
+        auto findState = values.find(power::property);
+        if (findState != values.end())
+        {
+            if (std::get<std::string>(findState->second) ==
+                "xyz.openbmc_project.State.Host.HostState.Running")
+            {
+                std::cerr << "chassis powered on\n";
+                reading = reading | (1 << static_cast<uint16_t>(ACPI::S0_G0));
+            }
+
+            else if (std::get<std::string>(findState->second) ==
+                     "xyz.openbmc_project.State.Host.HostState.Off")
+            {
+                reading = reading | (1 << static_cast<uint16_t>(ACPI::S4_S5));
+                std::cerr << "chassis powered off\n";
+            }
+            else
+            {
+                reading = reading | (1 << static_cast<uint16_t>(ACPI::Unknown));
+                std::cerr << "chassis unknown\n";
+            }
+            updateState(sensorInterface, reading);
+        }
+    };
+
+    powerMonitor = setupDbusMatch(power::path, power::interface,
+                                  powerStatusMatcherCallback);
+}
diff --git a/src/ACPISystemStatus.hpp b/src/ACPISystemStatus.hpp
new file mode 100644
index 00000000..08ea06c2
--- /dev/null
+++ b/src/ACPISystemStatus.hpp
@@ -0,0 +1,51 @@
+#include <Discrete.hpp>
+#include <Utils.hpp>
+#include <boost/asio/deadline_timer.hpp>
+#include <boost/asio/io_context.hpp>
+#include <boost/container/flat_map.hpp>
+#include <sdbusplus/asio/object_server.hpp>
+
+#include <memory>
+#include <optional>
+#include <stdexcept>
+#include <string>
+#include <vector>
+
+namespace fs = std::filesystem;
+
+enum class ACPI
+{
+    S0_G0,
+    S1,
+    S2,
+    S3,
+    S4,
+    S5_G2,
+    S4_S5,
+    G3,
+    SLEEP,
+    G1_SLEEP,
+    OVERRIDE,
+    LEGACY_ON,
+    LEGACY_OFF,
+    Unknown,
+};
+
+class ACPISystemStatus :
+    public Discrete,
+    public std::enable_shared_from_this<ACPISystemStatus>
+{
+  public:
+    ACPISystemStatus(sdbusplus::asio::object_server& objectServer,
+                     std::shared_ptr<sdbusplus::asio::connection>& conn,
+                     const std::string& sensorName,
+                     const std::string& sensorConfiguration);
+    ~ACPISystemStatus() override;
+
+  private:
+    uint16_t reading = 0;
+    sdbusplus::asio::object_server& objServer;
+    std::shared_ptr<sdbusplus::bus::match_t> powerMonitor;
+    void monitorState(std::shared_ptr<sdbusplus::asio::connection>& conn);
+    void propertyInitialize(std::shared_ptr<sdbusplus::asio::connection>& conn);
+};
diff --git a/src/ACPISystemStatusMain.cpp b/src/ACPISystemStatusMain.cpp
new file mode 100644
index 00000000..0a8c0e1c
--- /dev/null
+++ b/src/ACPISystemStatusMain.cpp
@@ -0,0 +1,150 @@
+#include <ACPISystemStatus.hpp>
+#include <VariantVisitors.hpp>
+#include <boost/algorithm/string/case_conv.hpp>
+#include <boost/algorithm/string/predicate.hpp>
+#include <boost/algorithm/string/replace.hpp>
+#include <boost/container/flat_set.hpp>
+#include <sdbusplus/bus/match.hpp>
+
+#include <functional>
+#include <memory>
+#include <optional>
+#include <regex>
+#include <string>
+#include <variant>
+#include <vector>
+
+static constexpr const char* sensorType = "ACPISystem";
+
+void createSensors(
+    boost::asio::io_context& io, sdbusplus::asio::object_server& objectServer,
+    boost::container::flat_map<std::string, std::shared_ptr<ACPISystemStatus>>&
+        sensors,
+    std::shared_ptr<sdbusplus::asio::connection>& dbusConnection,
+    const std::shared_ptr<boost::container::flat_set<std::string>>&
+        sensorsChanged)
+{
+    auto getter = std::make_shared<GetSensorConfiguration>(
+        dbusConnection,
+        [&io, &objectServer, &sensors, &dbusConnection,
+         sensorsChanged](const ManagedObjectType& sensorConfigurations) {
+        bool firstScan = sensorsChanged == nullptr;
+        const std::string* interfacePath = nullptr;
+        const std::pair<std::string, SensorBaseConfigMap>* baseConfiguration =
+            nullptr;
+
+        for (const auto& [path, cfgData] : sensorConfigurations)
+        {
+            // clear it out each loop
+            baseConfiguration = nullptr;
+            auto sensorBase = cfgData.find(configInterfaceName(sensorType));
+            if (sensorBase == cfgData.end())
+            {
+                continue;
+            }
+            baseConfiguration = &(*sensorBase);
+            interfacePath = &path.str;
+
+            if (baseConfiguration == nullptr)
+            {
+                std::cerr << "error finding base configuration for sensor types"
+                          << "\n";
+                continue;
+            }
+            auto findSensorName = baseConfiguration->second.find("Name");
+            if (findSensorName == baseConfiguration->second.end())
+            {
+                std::cerr << "could not determine configuration name"
+                          << "\n";
+                continue;
+            }
+            std::string sensorName =
+                std::get<std::string>(findSensorName->second);
+
+            // on rescans, only update sensors we were signaled by
+            auto findSensor = sensors.find(sensorName);
+            if (!firstScan && findSensor != sensors.end())
+            {
+                bool found = false;
+                for (auto it = sensorsChanged->begin();
+                     it != sensorsChanged->end(); it++)
+                {
+                    if (findSensor->second &&
+                        boost::ends_with(*it, findSensor->second->name))
+                    {
+                        sensorsChanged->erase(it);
+                        findSensor->second = nullptr;
+                        found = true;
+                        break;
+                    }
+                }
+                if (!found)
+                {
+                    continue;
+                }
+            }
+            auto& sensorConstruct = sensors[sensorName];
+            sensorConstruct = nullptr;
+
+            sensorConstruct = std::make_shared<ACPISystemStatus>(
+                objectServer, dbusConnection, sensorName, *interfacePath);
+        }
+        });
+
+    getter->getConfiguration(std::vector<std::string>{sensorType});
+}
+
+int main()
+{
+    boost::asio::io_context io;
+    auto systemBus = std::make_shared<sdbusplus::asio::connection>(io);
+    sdbusplus::asio::object_server objectServer(systemBus, true);
+    objectServer.add_manager("/xyz/openbmc_project/sensors");
+    systemBus->request_name("xyz.openbmc_project.ACPISystemStatus");
+
+    boost::container::flat_map<std::string, std::shared_ptr<ACPISystemStatus>>
+        sensors;
+    std::vector<std::unique_ptr<sdbusplus::bus::match::match>> matches;
+    auto sensorsChanged =
+        std::make_shared<boost::container::flat_set<std::string>>();
+
+    boost::asio::post(io, [&]() {
+        createSensors(io, objectServer, sensors, systemBus, nullptr);
+    });
+
+    boost::asio::deadline_timer filterTimer(io);
+    std::function<void(sdbusplus::message::message&)> eventHandler =
+        [&](sdbusplus::message::message& message) {
+        if (message.is_method_error())
+        {
+            std::cerr << "callback method error\n";
+            return;
+        }
+        sensorsChanged->insert(message.get_path());
+        // this implicitly cancels the timer
+        filterTimer.expires_from_now(boost::posix_time::seconds(1));
+        filterTimer.async_wait([&](const boost::system::error_code& ec) {
+            if (ec == boost::asio::error::operation_aborted)
+            {
+                /* we were canceled*/
+                return;
+            }
+            if (ec)
+            {
+                std::cerr << "timer error\n";
+                return;
+            }
+            createSensors(io, objectServer, sensors, systemBus, sensorsChanged);
+        });
+    };
+
+    auto match = std::make_unique<sdbusplus::bus::match::match>(
+        static_cast<sdbusplus::bus::bus&>(*systemBus),
+        "type='signal',member='PropertiesChanged',path_namespace='" +
+            std::string(inventoryPath) + "',arg0namespace='" +
+            configInterfaceName(sensorType) + "'",
+        eventHandler);
+    matches.emplace_back(std::move(match));
+
+    io.run();
+}
-- 
2.41.0

--- a/src/Discrete.hpp	2023-08-22 10:30:16.377906603 +0530
+++ b/src/Discrete.hpp	2023-08-22 10:30:52.590474713 +0530
@@ -12,6 +12,14 @@
 #include <vector>
 
 constexpr const char* sensorStateInterface = "xyz.openbmc_project.Sensor.State";
+using value = std::variant<uint8_t, uint16_t, std::string>;
+
+enum class HostState
+{
+     Running,
+     Off,
+     Unknown,
+};
 
 struct Discrete
 {
@@ -77,4 +85,35 @@
                 std::string(path) + "',arg0='" + std::string(interface) + "'",
             std::move(statusCallback));
     }
+
+uint8_t getHostStatus(std::shared_ptr<sdbusplus::asio::connection> conn)
+{
+    std::string pwrStatus;
+    value variant;
+    try
+    {
+        auto method = conn->new_method_call(power::busname, power::path,
+                                            properties::interface,properties::get);
+        method.append(power::interface, "CurrentHostState");
+        auto reply = conn->call(method);
+        reply.read(variant);
+        pwrStatus = std::get<std::string>(variant);
+    }
+    catch (sdbusplus::exception_t& e)
+    {
+
+        std::cerr<<"Failed to get getHostStatus Value";
+        return (static_cast<uint8_t>(HostState::Unknown)) ;
+    }
+    if (pwrStatus == "xyz.openbmc_project.State.Host.HostState.Running")
+    {
+            return (static_cast<uint8_t>(HostState::Running)) ;
+    }
+    else if (pwrStatus == "xyz.openbmc_project.State.Host.HostState.Off")
+    {
+            return (static_cast<uint8_t>(HostState::Off)) ;
+    }
+    return (static_cast<uint8_t>(HostState::Unknown)) ;
+}
+
 };
--- a/meson_options.txt	2023-08-22 10:30:16.397906914 +0530
+++ b/meson_options.txt	2023-08-22 10:30:52.522473637 +0530
@@ -15,3 +15,4 @@
 option('insecure-sensor-override', type : 'feature', value : 'disabled', description : 'Enables Sensor override feature without any check.',)
 option('procstatus', type: 'feature', value: 'enabled', description: 'Enable processor status sensor.',)
 option('system', type: 'feature', value: 'disabled', description: 'Enable system sensor watchdog2 status.',)
+option('acpisystem', type: 'feature', value: 'disabled', description: 'Enable acpi system status sensor.',)
--- a/src/meson.build	2023-08-22 10:30:16.385906727 +0530
+++ b/src/meson.build	2023-08-22 10:30:52.582474587 +0530
@@ -288,3 +288,16 @@
     )
 endif
 
+if get_option('acpisystem').enabled()
+    executable(
+        'acpisystemstatus',
+        'ACPISystemStatus.cpp',
+        'ACPISystemStatusMain.cpp',
+        dependencies: [
+            default_deps,
+            utils_dep,
+        ],
+        cpp_args: uring_args,
+        install: true,
+    )
+endif
--- a/service_files/meson.build	2023-08-22 10:30:16.365906416 +0530
+++ b/service_files/meson.build	2023-08-22 10:30:52.570474396 +0530
@@ -13,6 +13,7 @@
     ['procstatus', 'xyz.openbmc_project.processorstatus.service'],
     ['system', 'xyz.openbmc_project.systemsensor.service'],
     ['powerunit', 'xyz.openbmc_project.powerunitstatus.service'],
+    ['acpisystem', 'xyz.openbmc_project.acpisystemstatus.service'],
 ]
 
 foreach tuple : unit_files
