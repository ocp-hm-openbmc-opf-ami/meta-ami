From 3d9dfa71eb11bab64008c804aa9a91f3bceb07cc Mon Sep 17 00:00:00 2001
From: selvaganapathi <selvaganapathim@ami.com>
Date: Wed, 23 Nov 2022 01:30:14 +0530
Subject: [PATCH 1/1] Add DCMI command handler support

Implement DCMI command handlers, using node-manager
service

Signed-off-by: selvaganapathi <selvaganapathim@ami.com>
---
 nm-ipmi-lib/include/utility.hpp |  71 +++++++
 nm-ipmi-lib/src/nm_commands.cpp | 343 +++++++++++++++++++++++++-------
 2 files changed, 337 insertions(+), 77 deletions(-)

diff --git a/nm-ipmi-lib/include/utility.hpp b/nm-ipmi-lib/include/utility.hpp
index 0550300..1ef9bd1 100644
--- a/nm-ipmi-lib/include/utility.hpp
+++ b/nm-ipmi-lib/include/utility.hpp
@@ -54,6 +54,16 @@ using StatDomainEnergyResponse =
                   uint1_t,  // MeasurementState
                   uint1_t>;
 
+using StatDCMIResponse = ipmi::RspType<uint16_t, // Current Power
+                                       uint16_t, // Minimum Power
+                                       uint16_t, // Maximum Power
+                                       uint16_t, // Average Power
+                                       uint32_t, // IPMI Timestamp
+                                       uint32_t, // Statistic Reporting Period
+                                       uint6_t,  // Reserved
+                                       uint1_t,  // Power Reading State
+                                       uint1_t>; // Reserved
+
 using StatDomainResponse = ipmi::RspType<uint16_t, // Current Value
                                          uint16_t, // Minimum Value
                                          uint16_t, // Maximum Value
@@ -326,6 +336,17 @@ enum class StatsMode
     perPolicyThrottling = 0x13,
 };
 
+enum class DCMIMode
+{
+    sysPower = 0x01,
+    enhancedSysPower = 0x02,
+};
+
+static const std::map<uint8_t, std::string> DCMIModeToDBusMap = {
+    {types::enum_cast<uint8_t>(DCMIMode::sysPower), "sysPower"},
+    {types::enum_cast<uint8_t>(DCMIMode::enhancedSysPower), "enhancedSysPower"},
+};
+
 static const std::map<uint5_t, std::string> statModeToDBusMap = {
     {types::enum_cast<uint5_t>(StatsMode::power), "Power"},
     {types::enum_cast<uint5_t>(StatsMode::inletTemp), "Inlet temperature"},
@@ -366,6 +387,56 @@ void policyStateToBitFlags(const int state, uint1_t& operationalState,
     }
 }
 
+StatDCMIResponse responseDCMIStat(ipmi::Context::ptr ctx,
+                                  const std::string& statType, uint4_t domainId)
+{
+    uint1_t administrativeState = 0;
+    uint1_t measurementState = 0;
+
+    NmService nmService(ctx);
+    // get enablement status
+    if (const std::optional<bool> domainEn =
+            nmService.isDomainEnabled(domainId))
+    {
+        administrativeState = (*domainEn) ? 1 : 0;
+    }
+    else
+    {
+        LOGGER_ERR << "Cannot get domain Enabled state";
+        return ipmi::responseUnspecifiedError();
+    };
+
+    // getting statistics
+    boost::system::error_code ec;
+    NmStatistics nmStatistics;
+    const AllStatisticsValues allStats =
+        ctx->bus->yield_method_call<AllStatisticsValues>(
+            ctx->yield, ec, nmService.getServiceName(),
+            nmService.getDomainPath(domainId), kStatisticsInterface,
+            "GetStatistics");
+    if (const ipmi::Cc cc = getCc(ctx->cmd, ec))
+    {
+        return ipmi::response(cc);
+    }
+
+    if (allStats.find(statType) == allStats.end())
+    {
+        return ipmi::response(ccInvalidMode);
+    }
+
+    if (!parseStatValuesMap(allStats, statType, nmStatistics, measurementState))
+    {
+        LOGGER_ERR << "Cannot parse statistics";
+        return ipmi::responseUnspecifiedError();
+    }
+
+    return ipmi::responseSuccess(nmStatistics.currentValue,
+                                 nmStatistics.minValue, nmStatistics.maxValue,
+                                 nmStatistics.avgValue, nmStatistics.timestamp,
+                                 nmStatistics.statReportingPeriod, uint1_t(0),
+                                 measurementState, uint1_t(0));
+}
+
 StatPolicyResponse responsePolicyStat(ipmi::Context::ptr ctx,
                                       const std::string& statType,
                                       uint4_t domainId, uint8_t policyId)
diff --git a/nm-ipmi-lib/src/nm_commands.cpp b/nm-ipmi-lib/src/nm_commands.cpp
index c4c614c..2c45663 100644
--- a/nm-ipmi-lib/src/nm_commands.cpp
+++ b/nm-ipmi-lib/src/nm_commands.cpp
@@ -1491,8 +1491,7 @@ ipmi::RspType<uint8_t, // Group Extension Identification
  * @returns IPMI response
  **/
 
-ipmi::RspType<uint8_t,  // Group Extension Identification
-              uint16_t, // Current Power
+ipmi::RspType<uint16_t, // Current Power
               uint16_t, // Minimum Power
               uint16_t, // Maximum Power
               uint16_t, // Average Power
@@ -1501,29 +1500,102 @@ ipmi::RspType<uint8_t,  // Group Extension Identification
               uint6_t,  // Reserved
               uint1_t,  // Power Reading State
               uint1_t>  // Reserved
-    getPowerReading(uint8_t mode, uint8_t averageTimePeriods,
-                    uint8_t /* reserved */)
+    getPowerReading(ipmi::Context::ptr ctx, uint8_t mode,
+                    uint8_t averageTimePeriods, uint8_t reserved)
 {
-    // TODO - Prepare proper handler implementation
-    //
-    // Below are variables declared and sucessful response with proper params,
-    // that can be used within handler implementation.
-    //
-    // uint8_t groupExten = 0;
-    // uint16_t currentPower = 0;
-    // uint16_t minimumPower = 0;
-    // uint16_t maximumPower = 0;
-    // uint16_t averagePower = 0;
-    // uint32_t timestamp = 0;
-    // uint32_t reportingTimePeriod = 0;
-    // uint1_t powerReadingState = 0;
-    //
-    // return ipmi::responseSuccess(groupExten, currentPower, minimumPower,
-    //                             maximumPower, averagePower, timestamp,
-    //                             reportingTimePeriod, uint6_t(0) reserved,
-    // powerReadingState, uint1_t(0) reserved);
     LOG_ENTRY;
-    return ipmi::responseInvalidCommand();
+
+    uint8_t policyId = 64;
+    uint8_t domainId = 0;
+
+    const auto& modePair = DCMIModeToDBusMap.find(mode);
+    if (reserved != 0 || modePair == DCMIModeToDBusMap.cend() ||
+        (mode == 0x01 && averageTimePeriods != 0x00) || mode == 0x02)
+    {
+        return ipmi::responseInvalidFieldRequest();
+    }
+
+    boost::system::error_code ec;
+    NmService nmService(ctx);
+    ipmi::Cc cc = nmService.verifyDomainAndPolicyPresence(domainId, policyId);
+    // get stats from domain
+    if (cc == ccInvalidDomainId)
+    {
+        return ipmi::response(cc);
+    }
+
+    std::string statType = statModeToDBusMap.at(0x01);
+    return responseDCMIStat(ctx, statType, domainId);
+}
+
+ipmi::RspType<uint16_t, // reserved
+              uint8_t,  // Exception Actions
+              uint16_t, // Requested Power Limit
+              uint32_t, // Correction Time
+              uint16_t, // reserved
+              uint32_t> // Statistics Sampling Period
+    responseGetDCMIPolicy(ipmi::Context::ptr ctx, const uint4_t& domainId,
+                          const uint8_t& policyId)
+{
+    LOG_ENTRY;
+    uint1_t sendAlert = 0;
+    uint1_t shutdown = 0;
+    uint8_t action = 0;
+    uint16_t targetLimit = 0;
+    uint32_t correctionTimeLimit = 0;
+    uint32_t statReportingPeriod = 0;
+
+    NmService nmService(ctx);
+
+    ipmi::PropertyMap propMap;
+    boost::system::error_code ec;
+    ec = getAllDbusProperties(ctx, nmService.getServiceName(),
+                              nmService.getPolicyPath(domainId, policyId),
+                              kPolicyAttributesInterface, propMap);
+    if (ec)
+    {
+        LOGGER_ERR << "Failed to getAll Policy properties, err: "
+                   << ec.message();
+        return ipmi::responseUnspecifiedError();
+    }
+    try
+    {
+        parseLimitException(std::get<int>(propMap.at("LimitException")),
+                            sendAlert, shutdown);
+        targetLimit = std::get<uint16_t>(propMap.at("Limit"));
+        correctionTimeLimit = std::get<uint32_t>(propMap.at("CorrectionInMs"));
+        statReportingPeriod =
+            std::get<uint16_t>(propMap.at("StatisticsReportingPeriod"));
+    }
+    catch (const std::exception& e)
+    {
+        LOGGER_ERR << "Error while parsing policy attributes, ex: " << e.what();
+        return ipmi::responseUnspecifiedError();
+    }
+
+    if (sendAlert && shutdown)
+    {
+        action = 0x01;
+    }
+    else if (sendAlert)
+    {
+        action = 0x11;
+    }
+    else
+    {
+        action = 0x00;
+    }
+
+    if (!(*nmService.isNmEnabled()) ||
+        !(*nmService.isDomainEnabled(domainId)) ||
+        !(*nmService.isPolicyEnabled(domainId, policyId)))
+    {
+        return ipmi::response(ccPowerLimitNotSet, 0, action, targetLimit,
+                              correctionTimeLimit, 0, statReportingPeriod);
+    }
+
+    return ipmi::responseSuccess(0, action, targetLimit, correctionTimeLimit, 0,
+                                 statReportingPeriod);
 }
 
 /**
@@ -1535,30 +1607,35 @@ ipmi::RspType<uint8_t,  // Group Extension Identification
  * @returns IPMI response
  **/
 
-ipmi::RspType<uint8_t,  // Group Extension Identification
-              uint16_t, // reserved
+ipmi::RspType<uint16_t, // reserved
               uint8_t,  // Exception Actions
               uint16_t, // Requested Power Limit
               uint32_t, // Correction Time
               uint16_t, // reserved
               uint16_t> // Statistics Sampling Period
-    getPowerLimit(uint8_t groupExten, uint16_t /* reserved */)
+    getPowerLimit(ipmi::Context::ptr ctx, uint16_t reserved)
 {
-    // TODO - Prepare proper handler implementation
-    //
-    // Below are variables declared and sucessful response with proper params,
-    // that can be used within handler implementation.
-    //
-    // uint8_t exceptionActions = 0;
-    // uint16_t powerLimit = 0;
-    // uint32_t correctionTime = 0;
-    // uint16_t statSamplingPeriod = 0;
-    //
-    // return ipmi::responseSuccess(groupExten, uint16_t(0) reserved,
-    //                             exceptionActions, powerLimit, correctionTime,
-    //                             uint16_t(0) reserved, statSamplingPeriod);
     LOG_ENTRY;
-    return ipmi::responseInvalidCommand();
+
+    uint8_t policyId = 64;
+    uint8_t domainId = 0;
+
+    if (reserved != 0)
+    {
+        return ipmi::responseInvalidFieldRequest();
+    }
+    boost::system::error_code ec;
+    ipmi::ObjectValueTree objMap;
+
+    NmService nmService(ctx);
+    const ipmi::Cc cc =
+        nmService.verifyDomainAndPolicyPresence(domainId, policyId);
+    if (cc == ccInvalidDomainId || cc == ccInvalidPolicyId)
+    {
+        return ipmi::response(ccPowerLimitNotSet, 0, 0, 0, 0, 0, 0);
+    }
+
+    return responseGetDCMIPolicy(ctx, domainId, policyId);
 }
 
 /**
@@ -1575,20 +1652,108 @@ ipmi::RspType<uint8_t,  // Group Extension Identification
  * @returns IPMI response
  **/
 
-ipmi::RspType<uint8_t> // Group Extension Identification
-    setPowerLimit(uint8_t groupExten, uint24_t /* reserved */,
-                  uint8_t exceptionActions, uint16_t powerLimit,
-                  uint32_t correctionTime, uint16_t /* reserved */,
-                  uint16_t statSamplingPeriod)
+ipmi::RspType<> setPowerLimit(ipmi::Context::ptr ctx, uint24_t reserved1,
+                              uint8_t exceptionActions, uint16_t powerLimit,
+                              uint32_t correctionTime, uint16_t reserved2,
+                              uint16_t statSamplingPeriod)
 {
-    // TODO - Prepare proper handler implementation
-    //
-    // Below is sucessful response with proper params,
-    // that can be used within handler implementation.
-    //
-    // return ipmi::responseSuccess(groupExten);
     LOG_ENTRY;
-    return ipmi::responseInvalidCommand();
+
+    if (reserved1 != 0 || reserved2 != 0 || exceptionActions >= 0x12)
+    {
+        return ipmi::responseInvalidFieldRequest();
+    }
+
+    boost::system::error_code ec;
+    int limitExc = 0;
+    const PolicySuspendPeriods suspendPeriods;
+    const PolicyThresholds thresholds;
+    const uint8_t componentId = kComponentIdAll;
+    uint8_t domainId = 0;
+    uint8_t policyId = 64;
+
+    if (exceptionActions == 0x00)
+    {
+        limitExc = 0;
+    }
+    else if (exceptionActions == 0x01)
+    {
+        limitExc = 3;
+    }
+    else if (exceptionActions == 0x11)
+    {
+        limitExc = 2;
+    }
+
+    const auto policyParamsTuple =
+        std::make_tuple(correctionTime,           // 0 - correctionInMs
+                        powerLimit,               // 1 - limit
+                        statSamplingPeriod,       // 2 - statReportingPeriod
+                        0,                        // 3 - policyStorage
+                        0,                        // 4 - powerCorrectionType
+                        limitExc,                 // 5 - limitException
+                        suspendPeriods,           // 6 - suspendPeriods
+                        thresholds,               // 7 - thresholds
+                        componentId,              // 8 - componentId
+                        static_cast<uint16_t>(0), // 9- triggerLimit
+                        "AlwaysOn"                // 10- triggerType
+        );
+
+    NmService nmService(ctx);
+    ipmi::Cc cc = nmService.verifyDomainAndPolicyPresence(domainId, policyId);
+    if (cc == ccInvalidDomainId)
+    {
+        return ipmi::responseUnspecifiedError();
+    }
+
+    if (cc == ccInvalidPolicyId)
+    {
+        // Create action
+        if (!isPolicyIdInRange(ctx, policyId))
+        {
+            return ipmi::responseUnspecifiedError();
+        }
+        auto policyPath =
+            ctx->bus->yield_method_call<sdbusplus::message::object_path>(
+                ctx->yield, ec, nmService.getServiceName(),
+                nmService.getDomainPath(domainId), kPolicyManagerInterface,
+                "CreateWithId", std::to_string(policyId), policyParamsTuple);
+        cc = getCc(ctx->cmd, ec);
+        if (cc)
+        {
+            return ipmi::response(cc);
+        }
+        LOGGER_INFO << "Policy created: " << std::string{policyPath};
+    }
+    else
+    {
+        // Update action
+        ctx->bus->yield_method_call<void>(
+            ctx->yield, ec, nmService.getServiceName(),
+            nmService.getPolicyPath(domainId, policyId),
+            kPolicyAttributesInterface, "Update", policyParamsTuple);
+        cc = getCc(ctx->cmd, ec);
+        if (cc)
+        {
+            return ipmi::response(cc);
+        }
+        LOGGER_INFO << "Policy updated: "
+                    << nmService.getPolicyPath(domainId, policyId);
+    }
+    ec.clear();
+    ec = setDbusProperty(ctx, nmService.getServiceName(),
+                         nmService.getPolicyPath(domainId, policyId).c_str(),
+                         kObjectEnableInterface, "Enabled", true);
+
+    if (ec)
+    {
+        LOGGER_ERR << "Failed to enable Policy: "
+                   << nmService.getPolicyPath(domainId, policyId)
+                   << ", error: " << ec.message();
+        return ipmi::responseUnspecifiedError();
+    }
+
+    return ipmi::responseSuccess();
 }
 
 /**
@@ -1601,17 +1766,45 @@ ipmi::RspType<uint8_t> // Group Extension Identification
  *  @returns IPMI response
  **/
 
-ipmi::RspType<uint8_t> // Group Extension Identification
-    activatePowerLimit(uint8_t groupExten, uint8_t powerLimitActivation)
+ipmi::RspType<> activatePowerLimit(ipmi::Context::ptr ctx,
+                                   uint8_t powerLimitActivation,
+                                   uint16_t reserved)
 {
-    // TODO - Prepare proper handler implementation
-    //
-    // Below is sucessful response with proper params,
-    // that can be used within handler implementation.
-    //
-    // return ipmi::responseSuccess(groupExten);
     LOG_ENTRY;
-    return ipmi::responseInvalidCommand();
+
+    uint8_t domainId = 0;
+    uint8_t policyId = 64;
+
+    if (reserved != 0)
+    {
+        return ipmi::responseInvalidFieldRequest();
+    }
+
+    NmService nmService(ctx);
+    ipmi::Cc cc = nmService.verifyDomainAndPolicyPresence(domainId, policyId);
+
+    std::string pathToObjectToSetState;
+    bool enableObject;
+
+    if (cc != ipmi::ccSuccess)
+    {
+        return ipmi::response(ccPowerLimitNotSet);
+    }
+    pathToObjectToSetState = nmService.getPolicyPath(domainId, policyId);
+    enableObject = powerLimitActivation ? true : false;
+
+    // Try to set state for NodeManager, Domain or Policy object
+    boost::system::error_code ec =
+        setDbusProperty(ctx, nmService.getServiceName(), pathToObjectToSetState,
+                        kObjectEnableInterface, "Enabled", enableObject);
+    if (ec)
+    {
+        LOGGER_ERR << "Failed to disable/enable Node Manager component, error: "
+                   << ec.message() << ", path: " << pathToObjectToSetState;
+        return ipmi::responseUnspecifiedError();
+    }
+
+    return ipmi::responseSuccess();
 }
 
 /**
@@ -1744,24 +1937,20 @@ void registerNmIpmiFunctions(void)
     //                      intel::DCMI::cmdGetDCMICapabilityInfo,
     //                      ipmi::Privilege::User, getDCMICapabilityInfo);
 
-    // TODO - Uncomment after command handler implementation
-    // ipmi::registerHandler(ipmi::prioOemBase, intel::netFnDCMI,
-    //                      intel::DCMI::cmdGetPowerReading,
-    //                      ipmi::Privilege::User, getPowerReading);
+    ipmi::registerGroupHandler(ipmi::prioOpenBmcBase, ipmi::groupDCMI,
+                               intel::DCMI::cmdGetPowerReading,
+                               ipmi::Privilege::User, getPowerReading);
 
-    // TODO - Uncomment after command handler implementation
-    // ipmi::registerHandler(ipmi::prioOemBase, intel::netFnDCMI,
-    //                      intel::DCMI::cmdGetPowerLimit,
-    //                      ipmi::Privilege::User, getPowerLimit);
+    ipmi::registerGroupHandler(ipmi::prioOpenBmcBase, ipmi::groupDCMI,
+                               intel::DCMI::cmdGetPowerLimit,
+                               ipmi::Privilege::User, getPowerLimit);
 
-    // TODO - Uncomment after command handler implementation
-    // ipmi::registerHandler(ipmi::prioOemBase, intel::netFnDCMI,
-    //                      intel::DCMI::cmdSetPowerLimit,
-    //                      ipmi::Privilege::Admin, setPowerLimit);
+    ipmi::registerGroupHandler(ipmi::prioOpenBmcBase, ipmi::groupDCMI,
+                               intel::DCMI::cmdSetPowerLimit,
+                               ipmi::Privilege::Admin, setPowerLimit);
 
-    // TODO - Uncomment after command handler implementation
-    // ipmi::registerHandler(ipmi::prioOemBase, intel::netFnDCMI,
-    //                      intel::DCMI::cmdActivatePowerLimit,
-    //                      ipmi::Privilege::Admin, activatePowerLimit);
+    ipmi::registerGroupHandler(ipmi::prioOpenBmcBase, ipmi::groupDCMI,
+                               intel::DCMI::cmdActivatePowerLimit,
+                               ipmi::Privilege::Admin, activatePowerLimit);
 }
 } // namespace nmipmi
-- 
2.25.1

